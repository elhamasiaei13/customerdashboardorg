{"ast":null,"code":"/*\n Highcharts JS v8.0.2 (2020-03-03)\n\n (c) 2009-2018 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function (aa, R) {\n  \"object\" === typeof module && module.exports ? (R[\"default\"] = R, module.exports = aa.document ? R(aa) : R) : \"function\" === typeof define && define.amd ? define(\"highcharts/highcharts\", function () {\n    return R(aa);\n  }) : (aa.Highcharts && aa.Highcharts.error(16, !0), aa.Highcharts = R(aa));\n})(\"undefined\" !== typeof window ? window : this, function (aa) {\n  function R(e, g, X, u) {\n    e.hasOwnProperty(g) || (e[g] = u.apply(null, X));\n  }\n\n  var p = {};\n  R(p, \"parts/Globals.js\", [], function () {\n    var e = \"undefined\" !== typeof aa ? aa : \"undefined\" !== typeof window ? window : {},\n        g = e.document,\n        X = e.navigator && e.navigator.userAgent || \"\",\n        u = g && g.createElementNS && !!g.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGRect,\n        p = /(edge|msie|trident)/i.test(X) && !e.opera,\n        L = -1 !== X.indexOf(\"Firefox\"),\n        E = -1 !== X.indexOf(\"Chrome\"),\n        A = L && 4 > parseInt(X.split(\"Firefox/\")[1], 10);\n    return {\n      product: \"Highcharts\",\n      version: \"8.0.2\",\n      deg2rad: 2 * Math.PI / 360,\n      doc: g,\n      hasBidiBug: A,\n      hasTouch: !!e.TouchEvent,\n      isMS: p,\n      isWebKit: -1 !== X.indexOf(\"AppleWebKit\"),\n      isFirefox: L,\n      isChrome: E,\n      isSafari: !E && -1 !== X.indexOf(\"Safari\"),\n      isTouchDevice: /(Mobile|Android|Windows Phone)/.test(X),\n      SVG_NS: \"http://www.w3.org/2000/svg\",\n      chartCount: 0,\n      seriesTypes: {},\n      symbolSizes: {},\n      svg: u,\n      win: e,\n      marginNames: [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"],\n      noop: function () {},\n      charts: [],\n      dateFormats: {}\n    };\n  });\n  R(p, \"parts/Utilities.js\", [p[\"parts/Globals.js\"]], function (e) {\n    function g() {\n      var b,\n          a = arguments,\n          q = {},\n          d = function (b, a) {\n        \"object\" !== typeof b && (b = {});\n        Y(a, function (q, c) {\n          !M(q, !0) || m(q) || v(q) ? b[c] = a[c] : b[c] = d(b[c] || {}, q);\n        });\n        return b;\n      };\n\n      !0 === a[0] && (q = a[1], a = Array.prototype.slice.call(a, 2));\n      var c = a.length;\n\n      for (b = 0; b < c; b++) q = d(q, a[b]);\n\n      return q;\n    }\n\n    function X(b, a, q) {\n      var d;\n      r(a) ? c(q) ? b.setAttribute(a, q) : b && b.getAttribute && ((d = b.getAttribute(a)) || \"class\" !== a || (d = b.getAttribute(a + \"Name\"))) : Y(a, function (a, q) {\n        b.setAttribute(q, a);\n      });\n      return d;\n    }\n\n    function u() {\n      for (var b = arguments, a = b.length, q = 0; q < a; q++) {\n        var d = b[q];\n        if (\"undefined\" !== typeof d && null !== d) return d;\n      }\n    }\n\n    function p(b, a) {\n      if (!b) return a;\n      var q = b.split(\".\").reverse();\n      if (1 === q.length) return a[b];\n\n      for (b = q.pop(); \"undefined\" !== typeof b && \"undefined\" !== typeof a && null !== a;) a = a[b], b = q.pop();\n\n      return a;\n    }\n\n    e.timers = [];\n\n    var L = e.charts,\n        E = e.doc,\n        A = e.win,\n        C = e.error = function (b, a, q, d) {\n      var c = H(b),\n          n = c ? \"Highcharts error #\" + b + \": www.highcharts.com/errors/\" + b + \"/\" : b.toString(),\n          x = function () {\n        if (a) throw Error(n);\n        A.console && console.log(n);\n      };\n\n      if (\"undefined\" !== typeof d) {\n        var f = \"\";\n        c && (n += \"?\");\n        e.objectEach(d, function (b, a) {\n          f += \"\\n\" + a + \": \" + b;\n          c && (n += encodeURI(a) + \"=\" + encodeURI(b));\n        });\n        n += f;\n      }\n\n      q ? e.fireEvent(q, \"displayError\", {\n        code: b,\n        message: n,\n        params: d\n      }, x) : x();\n    },\n        J = function () {\n      function b(b, a, q) {\n        this.options = a;\n        this.elem = b;\n        this.prop = q;\n      }\n\n      b.prototype.dSetter = function () {\n        var b = this.paths[0],\n            a = this.paths[1],\n            q = [],\n            d = this.now,\n            c = b.length;\n        if (1 === d) q = this.toD;else if (c === a.length && 1 > d) for (; c--;) {\n          var n = parseFloat(b[c]);\n          q[c] = isNaN(n) || \"A\" === a[c - 4] || \"A\" === a[c - 5] ? a[c] : d * parseFloat(\"\" + (a[c] - n)) + n;\n        } else q = a;\n        this.elem.attr(\"d\", q, null, !0);\n      };\n\n      b.prototype.update = function () {\n        var b = this.elem,\n            a = this.prop,\n            q = this.now,\n            d = this.options.step;\n        if (this[a + \"Setter\"]) this[a + \"Setter\"]();else b.attr ? b.element && b.attr(a, q, null, !0) : b.style[a] = q + this.unit;\n        d && d.call(b, q, this);\n      };\n\n      b.prototype.run = function (b, a, q) {\n        var d = this,\n            c = d.options,\n            n = function (b) {\n          return n.stopped ? !1 : d.step(b);\n        },\n            x = A.requestAnimationFrame || function (b) {\n          setTimeout(b, 13);\n        },\n            f = function () {\n          for (var b = 0; b < e.timers.length; b++) e.timers[b]() || e.timers.splice(b--, 1);\n\n          e.timers.length && x(f);\n        };\n\n        b !== a || this.elem[\"forceAnimate:\" + this.prop] ? (this.startTime = +new Date(), this.start = b, this.end = a, this.unit = q, this.now = this.start, this.pos = 0, n.elem = this.elem, n.prop = this.prop, n() && 1 === e.timers.push(n) && x(f)) : (delete c.curAnim[this.prop], c.complete && 0 === Object.keys(c.curAnim).length && c.complete.call(this.elem));\n      };\n\n      b.prototype.step = function (b) {\n        var a = +new Date(),\n            q = this.options,\n            d = this.elem,\n            c = q.complete,\n            n = q.duration,\n            x = q.curAnim;\n        if (d.attr && !d.element) b = !1;else if (b || a >= n + this.startTime) {\n          this.now = this.end;\n          this.pos = 1;\n          this.update();\n          var f = x[this.prop] = !0;\n          Y(x, function (b) {\n            !0 !== b && (f = !1);\n          });\n          f && c && c.call(d);\n          b = !1;\n        } else this.pos = q.easing((a - this.startTime) / n), this.now = this.start + (this.end - this.start) * this.pos, this.update(), b = !0;\n        return b;\n      };\n\n      b.prototype.initPath = function (b, a, q) {\n        function d(b) {\n          for (B = b.length; B--;) {\n            var a = \"M\" === b[B] || \"L\" === b[B];\n            var q = /[a-zA-Z]/.test(b[B + 3]);\n            a && q && b.splice(B + 1, 0, b[B + 1], b[B + 2], b[B + 1], b[B + 2]);\n          }\n        }\n\n        function c(b, a) {\n          for (; b.length < V;) {\n            b[0] = a[V - b.length];\n            var q = b.slice(0, Q);\n            [].splice.apply(b, [0, 0].concat(q));\n            l && (q = b.slice(b.length - Q), [].splice.apply(b, [b.length, 0].concat(q)), B--);\n          }\n\n          b[0] = \"M\";\n        }\n\n        function n(b, a) {\n          for (var q = (V - b.length) / Q; 0 < q && q--;) k = b.slice().splice(b.length / y - Q, Q * y), k[0] = a[V - Q - q * Q], G && (k[Q - 6] = k[Q - 2], k[Q - 5] = k[Q - 1]), [].splice.apply(b, [b.length / y, 0].concat(k)), l && q--;\n        }\n\n        a = a || \"\";\n        var x = b.startX,\n            f = b.endX,\n            G = -1 < a.indexOf(\"C\"),\n            Q = G ? 7 : 3,\n            k,\n            B;\n        a = a.split(\" \");\n        q = q.slice();\n        var l = b.isArea,\n            y = l ? 2 : 1;\n        G && (d(a), d(q));\n\n        if (x && f) {\n          for (B = 0; B < x.length; B++) if (x[B] === f[0]) {\n            var h = B;\n            break;\n          } else if (x[0] === f[f.length - x.length + B]) {\n            h = B;\n            var t = !0;\n            break;\n          } else if (x[x.length - 1] === f[f.length - x.length + B]) {\n            h = x.length - B;\n            break;\n          }\n\n          \"undefined\" === typeof h && (a = []);\n        }\n\n        if (a.length && H(h)) {\n          var V = q.length + h * y * Q;\n          t ? (c(a, q), n(q, a)) : (c(q, a), n(a, q));\n        }\n\n        return [a, q];\n      };\n\n      b.prototype.fillSetter = function () {\n        e.Fx.prototype.strokeSetter.apply(this, arguments);\n      };\n\n      b.prototype.strokeSetter = function () {\n        this.elem.attr(this.prop, e.color(this.start).tweenTo(e.color(this.end), this.pos), null, !0);\n      };\n\n      return b;\n    }();\n\n    e.Fx = J;\n    e.merge = g;\n\n    var z = e.pInt = function (b, a) {\n      return parseInt(b, a || 10);\n    },\n        r = e.isString = function (b) {\n      return \"string\" === typeof b;\n    },\n        D = e.isArray = function (b) {\n      b = Object.prototype.toString.call(b);\n      return \"[object Array]\" === b || \"[object Array Iterator]\" === b;\n    },\n        M = e.isObject = function (b, a) {\n      return !!b && \"object\" === typeof b && (!a || !D(b));\n    },\n        v = e.isDOMElement = function (b) {\n      return M(b) && \"number\" === typeof b.nodeType;\n    },\n        m = e.isClass = function (b) {\n      var a = b && b.constructor;\n      return !(!M(b, !0) || v(b) || !a || !a.name || \"Object\" === a.name);\n    },\n        H = e.isNumber = function (b) {\n      return \"number\" === typeof b && !isNaN(b) && Infinity > b && -Infinity < b;\n    },\n        f = e.erase = function (b, a) {\n      for (var q = b.length; q--;) if (b[q] === a) {\n        b.splice(q, 1);\n        break;\n      }\n    },\n        c = e.defined = function (b) {\n      return \"undefined\" !== typeof b && null !== b;\n    };\n\n    e.attr = X;\n\n    var l = e.splat = function (b) {\n      return D(b) ? b : [b];\n    },\n        h = e.syncTimeout = function (b, a, q) {\n      if (0 < a) return setTimeout(b, a, q);\n      b.call(0, q);\n      return -1;\n    },\n        d = e.clearTimeout = function (b) {\n      c(b) && clearTimeout(b);\n    },\n        a = e.extend = function (b, a) {\n      var q;\n      b || (b = {});\n\n      for (q in a) b[q] = a[q];\n\n      return b;\n    };\n\n    e.pick = u;\n\n    var k = e.css = function (b, q) {\n      e.isMS && !e.svg && q && \"undefined\" !== typeof q.opacity && (q.filter = \"alpha(opacity=\" + 100 * q.opacity + \")\");\n      a(b.style, q);\n    },\n        t = e.createElement = function (b, q, d, c, n) {\n      b = E.createElement(b);\n      q && a(b, q);\n      n && k(b, {\n        padding: \"0\",\n        border: \"none\",\n        margin: \"0\"\n      });\n      d && k(b, d);\n      c && c.appendChild(b);\n      return b;\n    },\n        w = e.extendClass = function (b, q) {\n      var d = function () {};\n\n      d.prototype = new b();\n      a(d.prototype, q);\n      return d;\n    },\n        y = e.pad = function (b, a, q) {\n      return Array((a || 2) + 1 - String(b).replace(\"-\", \"\").length).join(q || \"0\") + b;\n    },\n        F = e.relativeLength = function (b, a, q) {\n      return /%$/.test(b) ? a * parseFloat(b) / 100 + (q || 0) : parseFloat(b);\n    },\n        I = e.wrap = function (b, a, q) {\n      var d = b[a];\n\n      b[a] = function () {\n        var b = Array.prototype.slice.call(arguments),\n            a = arguments,\n            c = this;\n\n        c.proceed = function () {\n          d.apply(c, arguments.length ? arguments : a);\n        };\n\n        b.unshift(d);\n        b = q.apply(this, b);\n        c.proceed = null;\n        return b;\n      };\n    },\n        S = e.format = function (b, a, q) {\n      var d = \"{\",\n          c = !1,\n          n = [],\n          x = /f$/,\n          f = /\\.([0-9])/,\n          G = e.defaultOptions.lang,\n          k = q && q.time || e.time;\n\n      for (q = q && q.numberFormatter || Q; b;) {\n        var B = b.indexOf(d);\n        if (-1 === B) break;\n        var l = b.slice(0, B);\n\n        if (c) {\n          l = l.split(\":\");\n          d = p(l.shift() || \"\", a);\n          if (l.length && \"number\" === typeof d) if (l = l.join(\":\"), x.test(l)) {\n            var y = parseInt((l.match(f) || [\"\", \"-1\"])[1], 10);\n            null !== d && (d = q(d, y, G.decimalPoint, -1 < l.indexOf(\",\") ? G.thousandsSep : \"\"));\n          } else d = k.dateFormat(l, d);\n          n.push(d);\n        } else n.push(l);\n\n        b = b.slice(B + 1);\n        d = (c = !c) ? \"}\" : \"{\";\n      }\n\n      n.push(b);\n      return n.join(\"\");\n    },\n        O = e.getMagnitude = function (b) {\n      return Math.pow(10, Math.floor(Math.log(b) / Math.LN10));\n    },\n        N = e.normalizeTickInterval = function (b, a, q, d, c) {\n      var n = b;\n      q = u(q, 1);\n      var x = b / q;\n      a || (a = c ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === d && (1 === q ? a = a.filter(function (b) {\n        return 0 === b % 1;\n      }) : .1 >= q && (a = [1 / q])));\n\n      for (d = 0; d < a.length && !(n = a[d], c && n * q >= b || !c && x <= (a[d] + (a[d + 1] || a[d])) / 2); d++);\n\n      return n = P(n * q, -Math.round(Math.log(.001) / Math.LN10));\n    },\n        n = e.stableSort = function (b, a) {\n      var q = b.length,\n          d,\n          c;\n\n      for (c = 0; c < q; c++) b[c].safeI = c;\n\n      b.sort(function (b, q) {\n        d = a(b, q);\n        return 0 === d ? b.safeI - q.safeI : d;\n      });\n\n      for (c = 0; c < q; c++) delete b[c].safeI;\n    },\n        b = e.arrayMin = function (b) {\n      for (var a = b.length, q = b[0]; a--;) b[a] < q && (q = b[a]);\n\n      return q;\n    },\n        B = e.arrayMax = function (b) {\n      for (var a = b.length, q = b[0]; a--;) b[a] > q && (q = b[a]);\n\n      return q;\n    },\n        x = e.destroyObjectProperties = function (b, a) {\n      Y(b, function (q, d) {\n        q && q !== a && q.destroy && q.destroy();\n        delete b[d];\n      });\n    },\n        T = e.discardElement = function (b) {\n      var a = e.garbageBin;\n      a || (a = t(\"div\"));\n      b && a.appendChild(b);\n      a.innerHTML = \"\";\n    },\n        P = e.correctFloat = function (b, a) {\n      return parseFloat(b.toPrecision(a || 14));\n    },\n        W = e.setAnimation = function (b, a) {\n      a.renderer.globalAnimation = u(b, a.options.chart.animation, !0);\n    },\n        U = e.animObject = function (b) {\n      return M(b) ? g(b) : {\n        duration: b ? 500 : 0\n      };\n    },\n        q = e.timeUnits = {\n      millisecond: 1,\n      second: 1E3,\n      minute: 6E4,\n      hour: 36E5,\n      day: 864E5,\n      week: 6048E5,\n      month: 24192E5,\n      year: 314496E5\n    },\n        Q = e.numberFormat = function (b, a, q, d) {\n      b = +b || 0;\n      a = +a;\n      var c = e.defaultOptions.lang,\n          n = (b.toString().split(\".\")[1] || \"\").split(\"e\")[0].length,\n          x = b.toString().split(\"e\");\n      if (-1 === a) a = Math.min(n, 20);else if (!H(a)) a = 2;else if (a && x[1] && 0 > x[1]) {\n        var f = a + +x[1];\n        0 <= f ? (x[0] = (+x[0]).toExponential(f).split(\"e\")[0], a = f) : (x[0] = x[0].split(\".\")[0] || 0, b = 20 > a ? (x[0] * Math.pow(10, x[1])).toFixed(a) : 0, x[1] = 0);\n      }\n      var G = (Math.abs(x[1] ? x[0] : b) + Math.pow(10, -Math.max(a, n) - 1)).toFixed(a);\n      n = String(z(G));\n      f = 3 < n.length ? n.length % 3 : 0;\n      q = u(q, c.decimalPoint);\n      d = u(d, c.thousandsSep);\n      b = (0 > b ? \"-\" : \"\") + (f ? n.substr(0, f) + d : \"\");\n      b += n.substr(f).replace(/(\\d{3})(?=\\d)/g, \"$1\" + d);\n      a && (b += q + G.slice(-a));\n      x[1] && 0 !== +b && (b += \"e\" + x[1]);\n      return b;\n    };\n\n    Math.easeInOutSine = function (b) {\n      return -.5 * (Math.cos(Math.PI * b) - 1);\n    };\n\n    var Z = e.getStyle = function (b, a, q) {\n      if (\"width\" === a) return a = Math.min(b.offsetWidth, b.scrollWidth), q = b.getBoundingClientRect && b.getBoundingClientRect().width, q < a && q >= a - 1 && (a = Math.floor(q)), Math.max(0, a - e.getStyle(b, \"padding-left\") - e.getStyle(b, \"padding-right\"));\n      if (\"height\" === a) return Math.max(0, Math.min(b.offsetHeight, b.scrollHeight) - e.getStyle(b, \"padding-top\") - e.getStyle(b, \"padding-bottom\"));\n      A.getComputedStyle || C(27, !0);\n      if (b = A.getComputedStyle(b, void 0)) b = b.getPropertyValue(a), u(q, \"opacity\" !== a) && (b = z(b));\n      return b;\n    },\n        ca = e.inArray = function (b, a, q) {\n      return a.indexOf(b, q);\n    },\n        G = e.find = Array.prototype.find ? function (b, a) {\n      return b.find(a);\n    } : function (b, a) {\n      var q,\n          d = b.length;\n\n      for (q = 0; q < d; q++) if (a(b[q], q)) return b[q];\n    };\n\n    e.keys = Object.keys;\n\n    var V = e.offset = function (b) {\n      var a = E.documentElement;\n      b = b.parentElement || b.parentNode ? b.getBoundingClientRect() : {\n        top: 0,\n        left: 0\n      };\n      return {\n        top: b.top + (A.pageYOffset || a.scrollTop) - (a.clientTop || 0),\n        left: b.left + (A.pageXOffset || a.scrollLeft) - (a.clientLeft || 0)\n      };\n    },\n        ba = e.stop = function (b, a) {\n      for (var q = e.timers.length; q--;) e.timers[q].elem !== b || a && a !== e.timers[q].prop || (e.timers[q].stopped = !0);\n    },\n        Y = e.objectEach = function (b, a, q) {\n      for (var d in b) Object.hasOwnProperty.call(b, d) && a.call(q || b[d], b[d], d, b);\n    };\n\n    Y({\n      map: \"map\",\n      each: \"forEach\",\n      grep: \"filter\",\n      reduce: \"reduce\",\n      some: \"some\"\n    }, function (b, a) {\n      e[a] = function (a) {\n        return Array.prototype[b].apply(a, [].slice.call(arguments, 1));\n      };\n    });\n\n    var fa = e.addEvent = function (b, a, q, d) {\n      void 0 === d && (d = {});\n      var c = b.addEventListener || e.addEventListenerPolyfill;\n      var n = \"function\" === typeof b && b.prototype ? b.prototype.protoEvents = b.prototype.protoEvents || {} : b.hcEvents = b.hcEvents || {};\n      e.Point && b instanceof e.Point && b.series && b.series.chart && (b.series.chart.runTrackerClick = !0);\n      c && c.call(b, a, q, !1);\n      n[a] || (n[a] = []);\n      n[a].push({\n        fn: q,\n        order: \"number\" === typeof d.order ? d.order : Infinity\n      });\n      n[a].sort(function (b, a) {\n        return b.order - a.order;\n      });\n      return function () {\n        da(b, a, q);\n      };\n    },\n        da = e.removeEvent = function (b, a, q) {\n      function d(a, q) {\n        var d = b.removeEventListener || e.removeEventListenerPolyfill;\n        d && d.call(b, a, q, !1);\n      }\n\n      function c(q) {\n        var c;\n\n        if (b.nodeName) {\n          if (a) {\n            var n = {};\n            n[a] = !0;\n          } else n = q;\n\n          Y(n, function (b, a) {\n            if (q[a]) for (c = q[a].length; c--;) d(a, q[a][c].fn);\n          });\n        }\n      }\n\n      var n;\n      [\"protoEvents\", \"hcEvents\"].forEach(function (x, f) {\n        var G = (f = f ? b : b.prototype) && f[x];\n        G && (a ? (n = G[a] || [], q ? (G[a] = n.filter(function (b) {\n          return q !== b.fn;\n        }), d(a, q)) : (c(G), G[a] = [])) : (c(G), f[x] = {}));\n      });\n    },\n        ha = e.fireEvent = function (b, q, d, c) {\n      var n;\n      d = d || {};\n\n      if (E.createEvent && (b.dispatchEvent || b.fireEvent)) {\n        var x = E.createEvent(\"Events\");\n        x.initEvent(q, !0, !0);\n        a(x, d);\n        b.dispatchEvent ? b.dispatchEvent(x) : b.fireEvent(q, x);\n      } else d.target || a(d, {\n        preventDefault: function () {\n          d.defaultPrevented = !0;\n        },\n        target: b,\n        type: q\n      }), function (a, q) {\n        void 0 === a && (a = []);\n        void 0 === q && (q = []);\n        var c = 0,\n            x = 0,\n            f = a.length + q.length;\n\n        for (n = 0; n < f; n++) !1 === (a[c] ? q[x] ? a[c].order <= q[x].order ? a[c++] : q[x++] : a[c++] : q[x++]).fn.call(b, d) && d.preventDefault();\n      }(b.protoEvents && b.protoEvents[q], b.hcEvents && b.hcEvents[q]);\n\n      c && !d.defaultPrevented && c.call(b, d);\n    },\n        ia = e.animate = function (b, a, q) {\n      var d,\n          c = \"\",\n          n,\n          x;\n\n      if (!M(q)) {\n        var f = arguments;\n        q = {\n          duration: f[2],\n          easing: f[3],\n          complete: f[4]\n        };\n      }\n\n      H(q.duration) || (q.duration = 400);\n      q.easing = \"function\" === typeof q.easing ? q.easing : Math[q.easing] || Math.easeInOutSine;\n      q.curAnim = g(a);\n      Y(a, function (f, G) {\n        ba(b, G);\n        x = new J(b, q, G);\n        n = null;\n        \"d\" === G ? (x.paths = x.initPath(b, b.d, a.d), x.toD = a.d, d = 0, n = 1) : b.attr ? d = b.attr(G) : (d = parseFloat(Z(b, G)) || 0, \"opacity\" !== G && (c = \"px\"));\n        n || (n = f);\n        n && n.match && n.match(\"px\") && (n = n.replace(/px/g, \"\"));\n        x.run(d, n, c);\n      });\n    },\n        ja = e.seriesType = function (b, a, q, d, c) {\n      var n = e.getOptions(),\n          x = e.seriesTypes;\n      n.plotOptions[b] = g(n.plotOptions[a], q);\n      x[b] = w(x[a] || function () {}, d);\n      x[b].prototype.type = b;\n      c && (x[b].prototype.pointClass = w(e.Point, c));\n      return x[b];\n    },\n        ea = e.uniqueKey = function () {\n      var b = Math.random().toString(36).substring(2, 9),\n          a = 0;\n      return function () {\n        return \"highcharts-\" + b + \"-\" + a++;\n      };\n    }(),\n        ka = e.isFunction = function (b) {\n      return \"function\" === typeof b;\n    };\n\n    A.jQuery && (A.jQuery.fn.highcharts = function () {\n      var b = [].slice.call(arguments);\n      if (this[0]) return b[0] ? (new e[r(b[0]) ? b.shift() : \"Chart\"](this[0], b[0], b[1]), this) : L[X(this[0], \"data-highcharts-chart\")];\n    });\n    return {\n      Fx: J,\n      addEvent: fa,\n      animate: ia,\n      animObject: U,\n      arrayMax: B,\n      arrayMin: b,\n      attr: X,\n      clamp: function (b, a, q) {\n        return b > a ? b < q ? b : q : a;\n      },\n      clearTimeout: d,\n      correctFloat: P,\n      createElement: t,\n      css: k,\n      defined: c,\n      destroyObjectProperties: x,\n      discardElement: T,\n      erase: f,\n      error: C,\n      extend: a,\n      extendClass: w,\n      find: G,\n      fireEvent: ha,\n      format: S,\n      getMagnitude: O,\n      getNestedProperty: p,\n      getStyle: Z,\n      inArray: ca,\n      isArray: D,\n      isClass: m,\n      isDOMElement: v,\n      isFunction: ka,\n      isNumber: H,\n      isObject: M,\n      isString: r,\n      merge: g,\n      normalizeTickInterval: N,\n      numberFormat: Q,\n      objectEach: Y,\n      offset: V,\n      pad: y,\n      pick: u,\n      pInt: z,\n      relativeLength: F,\n      removeEvent: da,\n      seriesType: ja,\n      setAnimation: W,\n      splat: l,\n      stableSort: n,\n      stop: ba,\n      syncTimeout: h,\n      timeUnits: q,\n      uniqueKey: ea,\n      wrap: I\n    };\n  });\n  R(p, \"parts/Color.js\", [p[\"parts/Globals.js\"], p[\"parts/Utilities.js\"]], function (e, g) {\n    var X = g.isNumber,\n        u = g.merge,\n        p = g.pInt;\n\n    g = function () {\n      function e(e) {\n        this.parsers = [{\n          regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n          parse: function (e) {\n            return [p(e[1]), p(e[2]), p(e[3]), parseFloat(e[4], 10)];\n          }\n        }, {\n          regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n          parse: function (e) {\n            return [p(e[1]), p(e[2]), p(e[3]), 1];\n          }\n        }];\n        this.rgba = [];\n        this.init(e);\n      }\n\n      e.parse = function (g) {\n        return new e(g);\n      };\n\n      e.prototype.init = function (g) {\n        var A, C;\n        if ((this.input = g = e.names[g && g.toLowerCase ? g.toLowerCase() : \"\"] || g) && g.stops) this.stops = g.stops.map(function (r) {\n          return new e(r[1]);\n        });else {\n          if (g && g.charAt && \"#\" === g.charAt()) {\n            var u = g.length;\n            g = parseInt(g.substr(1), 16);\n            7 === u ? A = [(g & 16711680) >> 16, (g & 65280) >> 8, g & 255, 1] : 4 === u && (A = [(g & 3840) >> 4 | (g & 3840) >> 8, (g & 240) >> 4 | g & 240, (g & 15) << 4 | g & 15, 1]);\n          }\n\n          if (!A) for (C = this.parsers.length; C-- && !A;) {\n            var z = this.parsers[C];\n            (u = z.regex.exec(g)) && (A = z.parse(u));\n          }\n        }\n        this.rgba = A || [];\n      };\n\n      e.prototype.get = function (e) {\n        var g = this.input,\n            C = this.rgba;\n\n        if (\"undefined\" !== typeof this.stops) {\n          var E = u(g);\n          E.stops = [].concat(E.stops);\n          this.stops.forEach(function (g, r) {\n            E.stops[r] = [E.stops[r][0], g.get(e)];\n          });\n        } else E = C && X(C[0]) ? \"rgb\" === e || !e && 1 === C[3] ? \"rgb(\" + C[0] + \",\" + C[1] + \",\" + C[2] + \")\" : \"a\" === e ? C[3] : \"rgba(\" + C.join(\",\") + \")\" : g;\n\n        return E;\n      };\n\n      e.prototype.brighten = function (e) {\n        var g,\n            u = this.rgba;\n        if (this.stops) this.stops.forEach(function (g) {\n          g.brighten(e);\n        });else if (X(e) && 0 !== e) for (g = 0; 3 > g; g++) u[g] += p(255 * e), 0 > u[g] && (u[g] = 0), 255 < u[g] && (u[g] = 255);\n        return this;\n      };\n\n      e.prototype.setOpacity = function (e) {\n        this.rgba[3] = e;\n        return this;\n      };\n\n      e.prototype.tweenTo = function (e, g) {\n        var u = this.rgba,\n            A = e.rgba;\n        A.length && u && u.length ? (e = 1 !== A[3] || 1 !== u[3], g = (e ? \"rgba(\" : \"rgb(\") + Math.round(A[0] + (u[0] - A[0]) * (1 - g)) + \",\" + Math.round(A[1] + (u[1] - A[1]) * (1 - g)) + \",\" + Math.round(A[2] + (u[2] - A[2]) * (1 - g)) + (e ? \",\" + (A[3] + (u[3] - A[3]) * (1 - g)) : \"\") + \")\") : g = e.input || \"none\";\n        return g;\n      };\n\n      e.names = {\n        white: \"#ffffff\",\n        black: \"#000000\"\n      };\n      return e;\n    }();\n\n    e.Color = g;\n    e.color = g.parse;\n    return e.Color;\n  });\n  R(p, \"parts/SvgRenderer.js\", [p[\"parts/Globals.js\"], p[\"parts/Color.js\"], p[\"parts/Utilities.js\"]], function (e, g, p) {\n    var u = g.parse,\n        K = p.addEvent,\n        L = p.animate,\n        E = p.animObject,\n        A = p.attr,\n        C = p.createElement,\n        J = p.css,\n        z = p.defined,\n        r = p.destroyObjectProperties,\n        D = p.erase,\n        M = p.extend,\n        v = p.inArray,\n        m = p.isArray,\n        H = p.isNumber,\n        f = p.isObject,\n        c = p.isString,\n        l = p.merge,\n        h = p.objectEach,\n        d = p.pick,\n        a = p.pInt,\n        k = p.removeEvent,\n        t = p.splat,\n        w = p.stop,\n        y = p.uniqueKey,\n        F = e.charts,\n        I = e.deg2rad,\n        S = e.doc,\n        O = e.hasTouch,\n        N = e.isFirefox,\n        n = e.isMS,\n        b = e.isWebKit,\n        B = e.noop,\n        x = e.svg,\n        T = e.SVG_NS,\n        P = e.symbolSizes,\n        W = e.win;\n\n    var U = e.SVGElement = function () {\n      return this;\n    };\n\n    M(U.prototype, {\n      opacity: 1,\n      SVG_NS: T,\n      textProps: \"direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline cursor\".split(\" \"),\n      init: function (b, a) {\n        this.element = \"span\" === a ? C(a) : S.createElementNS(this.SVG_NS, a);\n        this.renderer = b;\n        e.fireEvent(this, \"afterInit\");\n      },\n      animate: function (b, a, c) {\n        var q = E(d(a, this.renderer.globalAnimation, !0));\n        d(S.hidden, S.msHidden, S.webkitHidden, !1) && (q.duration = 0);\n        0 !== q.duration ? (c && (q.complete = c), L(this, b, q)) : (this.attr(b, void 0, c), h(b, function (b, a) {\n          q.step && q.step.call(this, b, {\n            prop: a,\n            pos: 1\n          });\n        }, this));\n        return this;\n      },\n      complexColor: function (b, a, d) {\n        var q = this.renderer,\n            c,\n            n,\n            x,\n            f,\n            k,\n            Q,\n            B,\n            t,\n            w,\n            P,\n            Z,\n            T = [],\n            v;\n        e.fireEvent(this.renderer, \"complexColor\", {\n          args: arguments\n        }, function () {\n          b.radialGradient ? n = \"radialGradient\" : b.linearGradient && (n = \"linearGradient\");\n          n && (x = b[n], k = q.gradients, B = b.stops, P = d.radialReference, m(x) && (b[n] = x = {\n            x1: x[0],\n            y1: x[1],\n            x2: x[2],\n            y2: x[3],\n            gradientUnits: \"userSpaceOnUse\"\n          }), \"radialGradient\" === n && P && !z(x.gradientUnits) && (f = x, x = l(x, q.getRadialAttr(P, f), {\n            gradientUnits: \"userSpaceOnUse\"\n          })), h(x, function (b, a) {\n            \"id\" !== a && T.push(a, b);\n          }), h(B, function (b) {\n            T.push(b);\n          }), T = T.join(\",\"), k[T] ? Z = k[T].attr(\"id\") : (x.id = Z = y(), k[T] = Q = q.createElement(n).attr(x).add(q.defs), Q.radAttr = f, Q.stops = [], B.forEach(function (b) {\n            0 === b[1].indexOf(\"rgba\") ? (c = u(b[1]), t = c.get(\"rgb\"), w = c.get(\"a\")) : (t = b[1], w = 1);\n            b = q.createElement(\"stop\").attr({\n              offset: b[0],\n              \"stop-color\": t,\n              \"stop-opacity\": w\n            }).add(Q);\n            Q.stops.push(b);\n          })), v = \"url(\" + q.url + \"#\" + Z + \")\", d.setAttribute(a, v), d.gradient = T, b.toString = function () {\n            return v;\n          });\n        });\n      },\n      applyTextOutline: function (b) {\n        var a = this.element,\n            q;\n        -1 !== b.indexOf(\"contrast\") && (b = b.replace(/contrast/g, this.renderer.getContrast(a.style.fill)));\n        b = b.split(\" \");\n        var d = b[b.length - 1];\n\n        if ((q = b[0]) && \"none\" !== q && e.svg) {\n          this.fakeTS = !0;\n          b = [].slice.call(a.getElementsByTagName(\"tspan\"));\n          this.ySetter = this.xSetter;\n          q = q.replace(/(^[\\d\\.]+)(.*?)$/g, function (b, a, q) {\n            return 2 * a + q;\n          });\n          this.removeTextOutline(b);\n          var c = a.textContent ? /^[\\u0591-\\u065F\\u066A-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC]/.test(a.textContent) : !1;\n          var n = a.firstChild;\n          b.forEach(function (b, x) {\n            0 === x && (b.setAttribute(\"x\", a.getAttribute(\"x\")), x = a.getAttribute(\"y\"), b.setAttribute(\"y\", x || 0), null === x && a.setAttribute(\"y\", 0));\n            x = b.cloneNode(!0);\n            A(c && !N ? b : x, {\n              \"class\": \"highcharts-text-outline\",\n              fill: d,\n              stroke: d,\n              \"stroke-width\": q,\n              \"stroke-linejoin\": \"round\"\n            });\n            a.insertBefore(x, n);\n          });\n          c && N && b[0] && (b = b[0].cloneNode(!0), b.textContent = \" \", a.insertBefore(b, n));\n        }\n      },\n      removeTextOutline: function (b) {\n        for (var a = b.length, q; a--;) q = b[a], \"highcharts-text-outline\" === q.getAttribute(\"class\") && D(b, this.element.removeChild(q));\n      },\n      symbolCustomAttribs: \"x y width height r start end innerR anchorX anchorY rounded\".split(\" \"),\n      attr: function (b, a, d, c) {\n        var q = this.element,\n            n,\n            x = this,\n            f,\n            k,\n            B = this.symbolCustomAttribs;\n\n        if (\"string\" === typeof b && \"undefined\" !== typeof a) {\n          var Q = b;\n          b = {};\n          b[Q] = a;\n        }\n\n        \"string\" === typeof b ? x = (this[b + \"Getter\"] || this._defaultGetter).call(this, b, q) : (h(b, function (a, d) {\n          f = !1;\n          c || w(this, d);\n          this.symbolName && -1 !== v(d, B) && (n || (this.symbolAttr(b), n = !0), f = !0);\n          !this.rotation || \"x\" !== d && \"y\" !== d || (this.doTransform = !0);\n          f || (k = this[d + \"Setter\"] || this._defaultSetter, k.call(this, a, d, q), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(d) && this.updateShadows(d, a, k));\n        }, this), this.afterSetters());\n        d && d.call(this);\n        return x;\n      },\n      afterSetters: function () {\n        this.doTransform && (this.updateTransform(), this.doTransform = !1);\n      },\n      updateShadows: function (b, a, d) {\n        for (var q = this.shadows, c = q.length; c--;) d.call(q[c], \"height\" === b ? Math.max(a - (q[c].cutHeight || 0), 0) : \"d\" === b ? this.d : a, b, q[c]);\n      },\n      addClass: function (b, a) {\n        var q = a ? \"\" : this.attr(\"class\") || \"\";\n        b = (b || \"\").split(/ /g).reduce(function (b, a) {\n          -1 === q.indexOf(a) && b.push(a);\n          return b;\n        }, q ? [q] : []).join(\" \");\n        b !== q && this.attr(\"class\", b);\n        return this;\n      },\n      hasClass: function (b) {\n        return -1 !== (this.attr(\"class\") || \"\").split(\" \").indexOf(b);\n      },\n      removeClass: function (b) {\n        return this.attr(\"class\", (this.attr(\"class\") || \"\").replace(c(b) ? new RegExp(\" ?\" + b + \" ?\") : b, \"\"));\n      },\n      symbolAttr: function (b) {\n        var a = this;\n        \"x y r start end width height innerR anchorX anchorY clockwise\".split(\" \").forEach(function (q) {\n          a[q] = d(b[q], a[q]);\n        });\n        a.attr({\n          d: a.renderer.symbols[a.symbolName](a.x, a.y, a.width, a.height, a)\n        });\n      },\n      clip: function (b) {\n        return this.attr(\"clip-path\", b ? \"url(\" + this.renderer.url + \"#\" + b.id + \")\" : \"none\");\n      },\n      crisp: function (b, a) {\n        a = a || b.strokeWidth || 0;\n        var q = Math.round(a) % 2 / 2;\n        b.x = Math.floor(b.x || this.x || 0) + q;\n        b.y = Math.floor(b.y || this.y || 0) + q;\n        b.width = Math.floor((b.width || this.width || 0) - 2 * q);\n        b.height = Math.floor((b.height || this.height || 0) - 2 * q);\n        z(b.strokeWidth) && (b.strokeWidth = a);\n        return b;\n      },\n      css: function (b) {\n        var q = this.styles,\n            d = {},\n            c = this.element,\n            n = \"\",\n            f = !q,\n            k = [\"textOutline\", \"textOverflow\", \"width\"];\n        b && b.color && (b.fill = b.color);\n        q && h(b, function (b, a) {\n          b !== q[a] && (d[a] = b, f = !0);\n        });\n\n        if (f) {\n          q && (b = M(q, d));\n          if (b) if (null === b.width || \"auto\" === b.width) delete this.textWidth;else if (\"text\" === c.nodeName.toLowerCase() && b.width) var B = this.textWidth = a(b.width);\n          this.styles = b;\n          B && !x && this.renderer.forExport && delete b.width;\n\n          if (c.namespaceURI === this.SVG_NS) {\n            var l = function (b, a) {\n              return \"-\" + a.toLowerCase();\n            };\n\n            h(b, function (b, a) {\n              -1 === k.indexOf(a) && (n += a.replace(/([A-Z])/g, l) + \":\" + b + \";\");\n            });\n            n && A(c, \"style\", n);\n          } else J(c, b);\n\n          this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), b && b.textOutline && this.applyTextOutline(b.textOutline));\n        }\n\n        return this;\n      },\n      getStyle: function (b) {\n        return W.getComputedStyle(this.element || this, \"\").getPropertyValue(b);\n      },\n      strokeWidth: function () {\n        if (!this.renderer.styledMode) return this[\"stroke-width\"] || 0;\n        var b = this.getStyle(\"stroke-width\"),\n            d = 0;\n        if (b.indexOf(\"px\") === b.length - 2) d = a(b);else if (\"\" !== b) {\n          var c = S.createElementNS(T, \"rect\");\n          A(c, {\n            width: b,\n            \"stroke-width\": 0\n          });\n          this.element.parentNode.appendChild(c);\n          d = c.getBBox().width;\n          c.parentNode.removeChild(c);\n        }\n        return d;\n      },\n      on: function (b, a) {\n        var q = this,\n            d = q.element;\n        O && \"click\" === b ? (d.ontouchstart = function (b) {\n          q.touchEventFired = Date.now();\n          b.preventDefault();\n          a.call(d, b);\n        }, d.onclick = function (b) {\n          (-1 === W.navigator.userAgent.indexOf(\"Android\") || 1100 < Date.now() - (q.touchEventFired || 0)) && a.call(d, b);\n        }) : d[\"on\" + b] = a;\n        return this;\n      },\n      setRadialReference: function (b) {\n        var a = this.renderer.gradients[this.element.gradient];\n        this.element.radialReference = b;\n        a && a.radAttr && a.animate(this.renderer.getRadialAttr(b, a.radAttr));\n        return this;\n      },\n      translate: function (b, a) {\n        return this.attr({\n          translateX: b,\n          translateY: a\n        });\n      },\n      invert: function (b) {\n        this.inverted = b;\n        this.updateTransform();\n        return this;\n      },\n      updateTransform: function () {\n        var b = this.translateX || 0,\n            a = this.translateY || 0,\n            c = this.scaleX,\n            n = this.scaleY,\n            x = this.inverted,\n            f = this.rotation,\n            k = this.matrix,\n            B = this.element;\n        x && (b += this.width, a += this.height);\n        b = [\"translate(\" + b + \",\" + a + \")\"];\n        z(k) && b.push(\"matrix(\" + k.join(\",\") + \")\");\n        x ? b.push(\"rotate(90) scale(-1,1)\") : f && b.push(\"rotate(\" + f + \" \" + d(this.rotationOriginX, B.getAttribute(\"x\"), 0) + \" \" + d(this.rotationOriginY, B.getAttribute(\"y\") || 0) + \")\");\n        (z(c) || z(n)) && b.push(\"scale(\" + d(c, 1) + \" \" + d(n, 1) + \")\");\n        b.length && B.setAttribute(\"transform\", b.join(\" \"));\n      },\n      toFront: function () {\n        var b = this.element;\n        b.parentNode.appendChild(b);\n        return this;\n      },\n      align: function (b, a, n) {\n        var q,\n            x = {};\n        var f = this.renderer;\n        var k = f.alignedObjects;\n        var B, Q;\n\n        if (b) {\n          if (this.alignOptions = b, this.alignByTranslate = a, !n || c(n)) this.alignTo = q = n || \"renderer\", D(k, this), k.push(this), n = null;\n        } else b = this.alignOptions, a = this.alignByTranslate, q = this.alignTo;\n\n        n = d(n, f[q], f);\n        q = b.align;\n        f = b.verticalAlign;\n        k = (n.x || 0) + (b.x || 0);\n        var l = (n.y || 0) + (b.y || 0);\n        \"right\" === q ? B = 1 : \"center\" === q && (B = 2);\n        B && (k += (n.width - (b.width || 0)) / B);\n        x[a ? \"translateX\" : \"x\"] = Math.round(k);\n        \"bottom\" === f ? Q = 1 : \"middle\" === f && (Q = 2);\n        Q && (l += (n.height - (b.height || 0)) / Q);\n        x[a ? \"translateY\" : \"y\"] = Math.round(l);\n        this[this.placed ? \"animate\" : \"attr\"](x);\n        this.placed = !0;\n        this.alignAttr = x;\n        return this;\n      },\n      getBBox: function (b, a) {\n        var q,\n            c = this.renderer,\n            n = this.element,\n            x = this.styles,\n            f = this.textStr,\n            k,\n            B = c.cache,\n            l = c.cacheKeys,\n            Q = n.namespaceURI === this.SVG_NS;\n        a = d(a, this.rotation, 0);\n        var y = c.styledMode ? n && U.prototype.getStyle.call(n, \"font-size\") : x && x.fontSize;\n\n        if (z(f)) {\n          var h = f.toString();\n          -1 === h.indexOf(\"<\") && (h = h.replace(/[0-9]/g, \"0\"));\n          h += [\"\", a, y, this.textWidth, x && x.textOverflow].join();\n        }\n\n        h && !b && (q = B[h]);\n\n        if (!q) {\n          if (Q || c.forExport) {\n            try {\n              (k = this.fakeTS && function (b) {\n                [].forEach.call(n.querySelectorAll(\".highcharts-text-outline\"), function (a) {\n                  a.style.display = b;\n                });\n              }) && k(\"none\"), q = n.getBBox ? M({}, n.getBBox()) : {\n                width: n.offsetWidth,\n                height: n.offsetHeight\n              }, k && k(\"\");\n            } catch (ea) {\n              \"\";\n            }\n\n            if (!q || 0 > q.width) q = {\n              width: 0,\n              height: 0\n            };\n          } else q = this.htmlGetBBox();\n\n          c.isSVG && (b = q.width, c = q.height, Q && (q.height = c = {\n            \"11px,17\": 14,\n            \"13px,20\": 16\n          }[x && x.fontSize + \",\" + Math.round(c)] || c), a && (x = a * I, q.width = Math.abs(c * Math.sin(x)) + Math.abs(b * Math.cos(x)), q.height = Math.abs(c * Math.cos(x)) + Math.abs(b * Math.sin(x))));\n\n          if (h && 0 < q.height) {\n            for (; 250 < l.length;) delete B[l.shift()];\n\n            B[h] || l.push(h);\n            B[h] = q;\n          }\n        }\n\n        return q;\n      },\n      show: function (b) {\n        return this.attr({\n          visibility: b ? \"inherit\" : \"visible\"\n        });\n      },\n      hide: function (b) {\n        b ? this.attr({\n          y: -9999\n        }) : this.attr({\n          visibility: \"hidden\"\n        });\n        return this;\n      },\n      fadeOut: function (b) {\n        var a = this;\n        a.animate({\n          opacity: 0\n        }, {\n          duration: b || 150,\n          complete: function () {\n            a.attr({\n              y: -9999\n            });\n          }\n        });\n      },\n      add: function (b) {\n        var a = this.renderer,\n            q = this.element;\n        b && (this.parentGroup = b);\n        this.parentInverted = b && b.inverted;\n        \"undefined\" !== typeof this.textStr && a.buildText(this);\n        this.added = !0;\n        if (!b || b.handleZ || this.zIndex) var d = this.zIndexSetter();\n        d || (b ? b.element : a.box).appendChild(q);\n        if (this.onAdd) this.onAdd();\n        return this;\n      },\n      safeRemoveChild: function (b) {\n        var a = b.parentNode;\n        a && a.removeChild(b);\n      },\n      destroy: function () {\n        var b = this,\n            a = b.element || {},\n            d = b.renderer,\n            c = d.isSVG && \"SPAN\" === a.nodeName && b.parentGroup,\n            n = a.ownerSVGElement,\n            x = b.clipPath;\n        a.onclick = a.onmouseout = a.onmouseover = a.onmousemove = a.point = null;\n        w(b);\n        x && n && ([].forEach.call(n.querySelectorAll(\"[clip-path],[CLIP-PATH]\"), function (b) {\n          -1 < b.getAttribute(\"clip-path\").indexOf(x.element.id) && b.removeAttribute(\"clip-path\");\n        }), b.clipPath = x.destroy());\n\n        if (b.stops) {\n          for (n = 0; n < b.stops.length; n++) b.stops[n] = b.stops[n].destroy();\n\n          b.stops = null;\n        }\n\n        b.safeRemoveChild(a);\n\n        for (d.styledMode || b.destroyShadows(); c && c.div && 0 === c.div.childNodes.length;) a = c.parentGroup, b.safeRemoveChild(c.div), delete c.div, c = a;\n\n        b.alignTo && D(d.alignedObjects, b);\n        h(b, function (a, d) {\n          b[d] && b[d].parentGroup === b && b[d].destroy && b[d].destroy();\n          delete b[d];\n        });\n      },\n      shadow: function (b, a, c) {\n        var q = [],\n            n,\n            x = this.element;\n        if (!b) this.destroyShadows();else if (!this.shadows) {\n          var f = d(b.width, 3);\n          var k = (b.opacity || .15) / f;\n          var B = this.parentInverted ? \"(-1,-1)\" : \"(\" + d(b.offsetX, 1) + \", \" + d(b.offsetY, 1) + \")\";\n\n          for (n = 1; n <= f; n++) {\n            var l = x.cloneNode(0);\n            var h = 2 * f + 1 - 2 * n;\n            A(l, {\n              stroke: b.color || \"#000000\",\n              \"stroke-opacity\": k * n,\n              \"stroke-width\": h,\n              transform: \"translate\" + B,\n              fill: \"none\"\n            });\n            l.setAttribute(\"class\", (l.getAttribute(\"class\") || \"\") + \" highcharts-shadow\");\n            c && (A(l, \"height\", Math.max(A(l, \"height\") - h, 0)), l.cutHeight = h);\n            a ? a.element.appendChild(l) : x.parentNode && x.parentNode.insertBefore(l, x);\n            q.push(l);\n          }\n\n          this.shadows = q;\n        }\n        return this;\n      },\n      destroyShadows: function () {\n        (this.shadows || []).forEach(function (b) {\n          this.safeRemoveChild(b);\n        }, this);\n        this.shadows = void 0;\n      },\n      xGetter: function (b) {\n        \"circle\" === this.element.nodeName && (\"x\" === b ? b = \"cx\" : \"y\" === b && (b = \"cy\"));\n        return this._defaultGetter(b);\n      },\n      _defaultGetter: function (b) {\n        b = d(this[b + \"Value\"], this[b], this.element ? this.element.getAttribute(b) : null, 0);\n        /^[\\-0-9\\.]+$/.test(b) && (b = parseFloat(b));\n        return b;\n      },\n      dSetter: function (b, a, d) {\n        b && b.join && (b = b.join(\" \"));\n        /(NaN| {2}|^$)/.test(b) && (b = \"M 0 0\");\n        this[a] !== b && (d.setAttribute(a, b), this[a] = b);\n      },\n      dashstyleSetter: function (b) {\n        var d,\n            q = this[\"stroke-width\"];\n        \"inherit\" === q && (q = 1);\n\n        if (b = b && b.toLowerCase()) {\n          b = b.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n\n          for (d = b.length; d--;) b[d] = a(b[d]) * q;\n\n          b = b.join(\",\").replace(/NaN/g, \"none\");\n          this.element.setAttribute(\"stroke-dasharray\", b);\n        }\n      },\n      alignSetter: function (b) {\n        var a = {\n          left: \"start\",\n          center: \"middle\",\n          right: \"end\"\n        };\n        a[b] && (this.alignValue = b, this.element.setAttribute(\"text-anchor\", a[b]));\n      },\n      opacitySetter: function (b, a, d) {\n        this[a] = b;\n        d.setAttribute(a, b);\n      },\n      titleSetter: function (b) {\n        var a = this.element.getElementsByTagName(\"title\")[0];\n        a || (a = S.createElementNS(this.SVG_NS, \"title\"), this.element.appendChild(a));\n        a.firstChild && a.removeChild(a.firstChild);\n        a.appendChild(S.createTextNode(String(d(b, \"\")).replace(/<[^>]*>/g, \"\").replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\")));\n      },\n      textSetter: function (b) {\n        b !== this.textStr && (delete this.bBox, delete this.textPxLength, this.textStr = b, this.added && this.renderer.buildText(this));\n      },\n      setTextPath: function (b, a) {\n        var d = this.element,\n            q = {\n          textAnchor: \"text-anchor\"\n        },\n            c = !1,\n            n = this.textPathWrapper,\n            x = !n;\n        a = l(!0, {\n          enabled: !0,\n          attributes: {\n            dy: -5,\n            startOffset: \"50%\",\n            textAnchor: \"middle\"\n          }\n        }, a);\n        var f = a.attributes;\n\n        if (b && a && a.enabled) {\n          n && null === n.element.parentNode ? (x = !0, n = n.destroy()) : n && this.removeTextOutline.call(n.parentGroup, [].slice.call(d.getElementsByTagName(\"tspan\")));\n          this.options && this.options.padding && (f.dx = -this.options.padding);\n          n || (this.textPathWrapper = n = this.renderer.createElement(\"textPath\"), c = !0);\n          var k = n.element;\n          (a = b.element.getAttribute(\"id\")) || b.element.setAttribute(\"id\", a = y());\n          if (x) for (b = d.getElementsByTagName(\"tspan\"); b.length;) b[0].setAttribute(\"y\", 0), H(f.dx) && b[0].setAttribute(\"x\", -f.dx), k.appendChild(b[0]);\n          c && n.add({\n            element: this.text ? this.text.element : d\n          });\n          k.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", this.renderer.url + \"#\" + a);\n          z(f.dy) && (k.parentNode.setAttribute(\"dy\", f.dy), delete f.dy);\n          z(f.dx) && (k.parentNode.setAttribute(\"dx\", f.dx), delete f.dx);\n          h(f, function (b, a) {\n            k.setAttribute(q[a] || a, b);\n          });\n          d.removeAttribute(\"transform\");\n          this.removeTextOutline.call(n, [].slice.call(d.getElementsByTagName(\"tspan\")));\n          this.text && !this.renderer.styledMode && this.attr({\n            fill: \"none\",\n            \"stroke-width\": 0\n          });\n          this.applyTextOutline = this.updateTransform = B;\n        } else n && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(d, b), this.updateTransform(), this.options.rotation && this.applyTextOutline(this.options.style.textOutline));\n\n        return this;\n      },\n      destroyTextPath: function (b, a) {\n        var d = b.getElementsByTagName(\"text\")[0];\n\n        if (d) {\n          if (d.removeAttribute(\"dx\"), d.removeAttribute(\"dy\"), a.element.setAttribute(\"id\", \"\"), d.getElementsByTagName(\"textPath\").length) {\n            for (b = this.textPathWrapper.element.childNodes; b.length;) d.appendChild(b[0]);\n\n            d.removeChild(this.textPathWrapper.element);\n          }\n        } else if (b.getAttribute(\"dx\") || b.getAttribute(\"dy\")) b.removeAttribute(\"dx\"), b.removeAttribute(\"dy\");\n\n        this.textPathWrapper = this.textPathWrapper.destroy();\n      },\n      fillSetter: function (b, a, d) {\n        \"string\" === typeof b ? d.setAttribute(a, b) : b && this.complexColor(b, a, d);\n      },\n      visibilitySetter: function (b, a, d) {\n        \"inherit\" === b ? d.removeAttribute(a) : this[a] !== b && d.setAttribute(a, b);\n        this[a] = b;\n      },\n      zIndexSetter: function (b, d) {\n        var c = this.renderer,\n            q = this.parentGroup,\n            n = (q || c).element || c.box,\n            x = this.element,\n            f = !1;\n        c = n === c.box;\n        var k = this.added;\n        var B;\n        z(b) ? (x.setAttribute(\"data-z-index\", b), b = +b, this[d] === b && (k = !1)) : z(this[d]) && x.removeAttribute(\"data-z-index\");\n        this[d] = b;\n\n        if (k) {\n          (b = this.zIndex) && q && (q.handleZ = !0);\n          d = n.childNodes;\n\n          for (B = d.length - 1; 0 <= B && !f; B--) {\n            q = d[B];\n            k = q.getAttribute(\"data-z-index\");\n            var l = !z(k);\n            if (q !== x) if (0 > b && l && !c && !B) n.insertBefore(x, d[B]), f = !0;else if (a(k) <= b || l && (!z(b) || 0 <= b)) n.insertBefore(x, d[B + 1] || null), f = !0;\n          }\n\n          f || (n.insertBefore(x, d[c ? 3 : 0] || null), f = !0);\n        }\n\n        return f;\n      },\n      _defaultSetter: function (b, a, d) {\n        d.setAttribute(a, b);\n      }\n    });\n    U.prototype.yGetter = U.prototype.xGetter;\n\n    U.prototype.translateXSetter = U.prototype.translateYSetter = U.prototype.rotationSetter = U.prototype.verticalAlignSetter = U.prototype.rotationOriginXSetter = U.prototype.rotationOriginYSetter = U.prototype.scaleXSetter = U.prototype.scaleYSetter = U.prototype.matrixSetter = function (b, a) {\n      this[a] = b;\n      this.doTransform = !0;\n    };\n\n    U.prototype[\"stroke-widthSetter\"] = U.prototype.strokeSetter = function (b, a, d) {\n      this[a] = b;\n      this.stroke && this[\"stroke-width\"] ? (U.prototype.fillSetter.call(this, this.stroke, \"stroke\", d), d.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0) : \"stroke-width\" === a && 0 === b && this.hasStroke ? (d.removeAttribute(\"stroke\"), this.hasStroke = !1) : this.renderer.styledMode && this[\"stroke-width\"] && (d.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0);\n    };\n\n    g = e.SVGRenderer = function () {\n      this.init.apply(this, arguments);\n    };\n\n    M(g.prototype, {\n      Element: U,\n      SVG_NS: T,\n      init: function (a, d, c, n, x, f, k) {\n        var q = this.createElement(\"svg\").attr({\n          version: \"1.1\",\n          \"class\": \"highcharts-root\"\n        });\n        k || q.css(this.getStyle(n));\n        n = q.element;\n        a.appendChild(n);\n        A(a, \"dir\", \"ltr\");\n        -1 === a.innerHTML.indexOf(\"xmlns\") && A(n, \"xmlns\", this.SVG_NS);\n        this.isSVG = !0;\n        this.box = n;\n        this.boxWrapper = q;\n        this.alignedObjects = [];\n        this.url = (N || b) && S.getElementsByTagName(\"base\").length ? W.location.href.split(\"#\")[0].replace(/<[^>]*>/g, \"\").replace(/([\\('\\)])/g, \"\\\\$1\").replace(/ /g, \"%20\") : \"\";\n        this.createElement(\"desc\").add().element.appendChild(S.createTextNode(\"Created with Highcharts 8.0.2\"));\n        this.defs = this.createElement(\"defs\").add();\n        this.allowHTML = f;\n        this.forExport = x;\n        this.styledMode = k;\n        this.gradients = {};\n        this.cache = {};\n        this.cacheKeys = [];\n        this.imgCount = 0;\n        this.setSize(d, c, !1);\n        var B;\n        N && a.getBoundingClientRect && (d = function () {\n          J(a, {\n            left: 0,\n            top: 0\n          });\n          B = a.getBoundingClientRect();\n          J(a, {\n            left: Math.ceil(B.left) - B.left + \"px\",\n            top: Math.ceil(B.top) - B.top + \"px\"\n          });\n        }, d(), this.unSubPixelFix = K(W, \"resize\", d));\n      },\n      definition: function (b) {\n        function a(b, c) {\n          var n;\n          t(b).forEach(function (b) {\n            var q = d.createElement(b.tagName),\n                x = {};\n            h(b, function (b, a) {\n              \"tagName\" !== a && \"children\" !== a && \"textContent\" !== a && (x[a] = b);\n            });\n            q.attr(x);\n            q.add(c || d.defs);\n            b.textContent && q.element.appendChild(S.createTextNode(b.textContent));\n            a(b.children || [], q);\n            n = q;\n          });\n          return n;\n        }\n\n        var d = this;\n        return a(b);\n      },\n      getStyle: function (b) {\n        return this.style = M({\n          fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif',\n          fontSize: \"12px\"\n        }, b);\n      },\n      setStyle: function (b) {\n        this.boxWrapper.css(this.getStyle(b));\n      },\n      isHidden: function () {\n        return !this.boxWrapper.getBBox().width;\n      },\n      destroy: function () {\n        var b = this.defs;\n        this.box = null;\n        this.boxWrapper = this.boxWrapper.destroy();\n        r(this.gradients || {});\n        this.gradients = null;\n        b && (this.defs = b.destroy());\n        this.unSubPixelFix && this.unSubPixelFix();\n        return this.alignedObjects = null;\n      },\n      createElement: function (b) {\n        var a = new this.Element();\n        a.init(this, b);\n        return a;\n      },\n      draw: B,\n      getRadialAttr: function (b, a) {\n        return {\n          cx: b[0] - b[2] / 2 + a.cx * b[2],\n          cy: b[1] - b[2] / 2 + a.cy * b[2],\n          r: a.r * b[2]\n        };\n      },\n      truncate: function (b, a, d, c, n, x, f) {\n        var q = this,\n            k = b.rotation,\n            B,\n            l = c ? 1 : 0,\n            G = (d || c).length,\n            h = G,\n            y = [],\n            t = function (b) {\n          a.firstChild && a.removeChild(a.firstChild);\n          b && a.appendChild(S.createTextNode(b));\n        },\n            w = function (x, k) {\n          k = k || x;\n          if (\"undefined\" === typeof y[k]) if (a.getSubStringLength) try {\n            y[k] = n + a.getSubStringLength(0, c ? k + 1 : k);\n          } catch (la) {\n            \"\";\n          } else q.getSpanWidth && (t(f(d || c, x)), y[k] = n + q.getSpanWidth(b, a));\n          return y[k];\n        },\n            P;\n\n        b.rotation = 0;\n        var Q = w(a.textContent.length);\n\n        if (P = n + Q > x) {\n          for (; l <= G;) h = Math.ceil((l + G) / 2), c && (B = f(c, h)), Q = w(h, B && B.length - 1), l === G ? l = G + 1 : Q > x ? G = h - 1 : l = h;\n\n          0 === G ? t(\"\") : d && G === d.length - 1 || t(B || f(d || c, h));\n        }\n\n        c && c.splice(0, h);\n        b.actualWidth = Q;\n        b.rotation = k;\n        return P;\n      },\n      escapes: {\n        \"&\": \"&amp;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        \"'\": \"&#39;\",\n        '\"': \"&quot;\"\n      },\n      buildText: function (b) {\n        var c = b.element,\n            n = this,\n            q = n.forExport,\n            f = d(b.textStr, \"\").toString(),\n            k = -1 !== f.indexOf(\"<\"),\n            B = c.childNodes,\n            l,\n            y = A(c, \"x\"),\n            t = b.styles,\n            w = b.textWidth,\n            P = t && t.lineHeight,\n            m = t && t.textOutline,\n            v = t && \"ellipsis\" === t.textOverflow,\n            e = t && \"nowrap\" === t.whiteSpace,\n            F = t && t.fontSize,\n            W,\n            I = B.length;\n        t = w && !b.added && this.box;\n\n        var H = function (b) {\n          var d;\n          n.styledMode || (d = /(px|em)$/.test(b && b.style.fontSize) ? b.style.fontSize : F || n.style.fontSize || 12);\n          return P ? a(P) : n.fontMetrics(d, b.getAttribute(\"style\") ? b : c).h;\n        },\n            r = function (b, a) {\n          h(n.escapes, function (d, c) {\n            a && -1 !== a.indexOf(d) || (b = b.toString().replace(new RegExp(d, \"g\"), c));\n          });\n          return b;\n        },\n            U = function (b, a) {\n          var d = b.indexOf(\"<\");\n          b = b.substring(d, b.indexOf(\">\") - d);\n          d = b.indexOf(a + \"=\");\n          if (-1 !== d && (d = d + a.length + 1, a = b.charAt(d), '\"' === a || \"'\" === a)) return b = b.substring(d + 1), b.substring(0, b.indexOf(a));\n        },\n            g = /<br.*?>/g;\n\n        var N = [f, v, e, P, m, F, w].join();\n\n        if (N !== b.textCache) {\n          for (b.textCache = N; I--;) c.removeChild(B[I]);\n\n          k || m || v || w || -1 !== f.indexOf(\" \") && (!e || g.test(f)) ? (t && t.appendChild(c), k ? (f = n.styledMode ? f.replace(/<(b|strong)>/g, '<span class=\"highcharts-strong\">').replace(/<(i|em)>/g, '<span class=\"highcharts-emphasized\">') : f.replace(/<(b|strong)>/g, '<span style=\"font-weight:bold\">').replace(/<(i|em)>/g, '<span style=\"font-style:italic\">'), f = f.replace(/<a/g, \"<span\").replace(/<\\/(b|strong|i|em|a)>/g, \"</span>\").split(g)) : f = [f], f = f.filter(function (b) {\n            return \"\" !== b;\n          }), f.forEach(function (a, d) {\n            var f = 0,\n                k = 0;\n            a = a.replace(/^\\s+|\\s+$/g, \"\").replace(/<span/g, \"|||<span\").replace(/<\\/span>/g, \"</span>|||\");\n            var B = a.split(\"|||\");\n            B.forEach(function (a) {\n              if (\"\" !== a || 1 === B.length) {\n                var G = {},\n                    h = S.createElementNS(n.SVG_NS, \"tspan\"),\n                    t,\n                    P;\n                (t = U(a, \"class\")) && A(h, \"class\", t);\n                if (t = U(a, \"style\")) t = t.replace(/(;| |^)color([ :])/, \"$1fill$2\"), A(h, \"style\", t);\n                (P = U(a, \"href\")) && !q && (A(h, \"onclick\", 'location.href=\"' + P + '\"'), A(h, \"class\", \"highcharts-anchor\"), n.styledMode || J(h, {\n                  cursor: \"pointer\"\n                }));\n                a = r(a.replace(/<[a-zA-Z\\/](.|\\n)*?>/g, \"\") || \" \");\n\n                if (\" \" !== a) {\n                  h.appendChild(S.createTextNode(a));\n                  f ? G.dx = 0 : d && null !== y && (G.x = y);\n                  A(h, G);\n                  c.appendChild(h);\n                  !f && W && (!x && q && J(h, {\n                    display: \"block\"\n                  }), A(h, \"dy\", H(h)));\n\n                  if (w) {\n                    var Q = a.replace(/([^\\^])-/g, \"$1- \").split(\" \");\n                    G = !e && (1 < B.length || d || 1 < Q.length);\n                    P = 0;\n                    var m = H(h);\n                    if (v) l = n.truncate(b, h, a, void 0, 0, Math.max(0, w - parseInt(F || 12, 10)), function (b, a) {\n                      return b.substring(0, a) + \"\\u2026\";\n                    });else if (G) for (; Q.length;) Q.length && !e && 0 < P && (h = S.createElementNS(T, \"tspan\"), A(h, {\n                      dy: m,\n                      x: y\n                    }), t && A(h, \"style\", t), h.appendChild(S.createTextNode(Q.join(\" \").replace(/- /g, \"-\"))), c.appendChild(h)), n.truncate(b, h, null, Q, 0 === P ? k : 0, w, function (b, a) {\n                      return Q.slice(0, a).join(\" \").replace(/- /g, \"-\");\n                    }), k = b.actualWidth, P++;\n                  }\n\n                  f++;\n                }\n              }\n            });\n            W = W || c.childNodes.length;\n          }), v && l && b.attr(\"title\", r(b.textStr, [\"&lt;\", \"&gt;\"])), t && t.removeChild(c), m && b.applyTextOutline && b.applyTextOutline(m)) : c.appendChild(S.createTextNode(r(f)));\n        }\n      },\n      getContrast: function (b) {\n        b = u(b).rgba;\n        b[0] *= 1;\n        b[1] *= 1.2;\n        b[2] *= .5;\n        return 459 < b[0] + b[1] + b[2] ? \"#000000\" : \"#FFFFFF\";\n      },\n      button: function (b, a, d, c, x, f, k, B, h, t) {\n        var q = this.label(b, a, d, h, null, null, t, null, \"button\"),\n            G = 0,\n            y = this.styledMode;\n        q.attr(l({\n          padding: 8,\n          r: 2\n        }, x));\n\n        if (!y) {\n          x = l({\n            fill: \"#f7f7f7\",\n            stroke: \"#cccccc\",\n            \"stroke-width\": 1,\n            style: {\n              color: \"#333333\",\n              cursor: \"pointer\",\n              fontWeight: \"normal\"\n            }\n          }, x);\n          var w = x.style;\n          delete x.style;\n          f = l(x, {\n            fill: \"#e6e6e6\"\n          }, f);\n          var P = f.style;\n          delete f.style;\n          k = l(x, {\n            fill: \"#e6ebf5\",\n            style: {\n              color: \"#000000\",\n              fontWeight: \"bold\"\n            }\n          }, k);\n          var Q = k.style;\n          delete k.style;\n          B = l(x, {\n            style: {\n              color: \"#cccccc\"\n            }\n          }, B);\n          var m = B.style;\n          delete B.style;\n        }\n\n        K(q.element, n ? \"mouseover\" : \"mouseenter\", function () {\n          3 !== G && q.setState(1);\n        });\n        K(q.element, n ? \"mouseout\" : \"mouseleave\", function () {\n          3 !== G && q.setState(G);\n        });\n\n        q.setState = function (b) {\n          1 !== b && (q.state = G = b);\n          q.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][b || 0]);\n          y || q.attr([x, f, k, B][b || 0]).css([w, P, Q, m][b || 0]);\n        };\n\n        y || q.attr(x).css(M({\n          cursor: \"default\"\n        }, w));\n        return q.on(\"click\", function (b) {\n          3 !== G && c.call(q, b);\n        });\n      },\n      crispLine: function (b, a) {\n        b[1] === b[4] && (b[1] = b[4] = Math.round(b[1]) - a % 2 / 2);\n        b[2] === b[5] && (b[2] = b[5] = Math.round(b[2]) + a % 2 / 2);\n        return b;\n      },\n      path: function (b) {\n        var a = this.styledMode ? {} : {\n          fill: \"none\"\n        };\n        m(b) ? a.d = b : f(b) && M(a, b);\n        return this.createElement(\"path\").attr(a);\n      },\n      circle: function (b, a, d) {\n        b = f(b) ? b : \"undefined\" === typeof b ? {} : {\n          x: b,\n          y: a,\n          r: d\n        };\n        a = this.createElement(\"circle\");\n\n        a.xSetter = a.ySetter = function (b, a, d) {\n          d.setAttribute(\"c\" + a, b);\n        };\n\n        return a.attr(b);\n      },\n      arc: function (b, a, d, c, n, x) {\n        f(b) ? (c = b, a = c.y, d = c.r, b = c.x) : c = {\n          innerR: c,\n          start: n,\n          end: x\n        };\n        b = this.symbol(\"arc\", b, a, d, d, c);\n        b.r = d;\n        return b;\n      },\n      rect: function (b, a, d, c, n, x) {\n        n = f(b) ? b.r : n;\n        var q = this.createElement(\"rect\");\n        b = f(b) ? b : \"undefined\" === typeof b ? {} : {\n          x: b,\n          y: a,\n          width: Math.max(d, 0),\n          height: Math.max(c, 0)\n        };\n        this.styledMode || (\"undefined\" !== typeof x && (b.strokeWidth = x, b = q.crisp(b)), b.fill = \"none\");\n        n && (b.r = n);\n\n        q.rSetter = function (b, a, d) {\n          q.r = b;\n          A(d, {\n            rx: b,\n            ry: b\n          });\n        };\n\n        q.rGetter = function () {\n          return q.r;\n        };\n\n        return q.attr(b);\n      },\n      setSize: function (b, a, c) {\n        var n = this.alignedObjects,\n            x = n.length;\n        this.width = b;\n        this.height = a;\n\n        for (this.boxWrapper.animate({\n          width: b,\n          height: a\n        }, {\n          step: function () {\n            this.attr({\n              viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n            });\n          },\n          duration: d(c, !0) ? void 0 : 0\n        }); x--;) n[x].align();\n      },\n      g: function (b) {\n        var a = this.createElement(\"g\");\n        return b ? a.attr({\n          \"class\": \"highcharts-\" + b\n        }) : a;\n      },\n      image: function (b, a, d, c, n, x) {\n        var f = {\n          preserveAspectRatio: \"none\"\n        },\n            q = function (b, a) {\n          b.setAttributeNS ? b.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", a) : b.setAttribute(\"hc-svg-href\", a);\n        },\n            k = function (a) {\n          q(B.element, b);\n          x.call(B, a);\n        };\n\n        1 < arguments.length && M(f, {\n          x: a,\n          y: d,\n          width: c,\n          height: n\n        });\n        var B = this.createElement(\"image\").attr(f);\n        x ? (q(B.element, \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"), f = new W.Image(), K(f, \"load\", k), f.src = b, f.complete && k({})) : q(B.element, b);\n        return B;\n      },\n      symbol: function (b, a, c, n, x, f) {\n        var q = this,\n            k = /^url\\((.*?)\\)$/,\n            B = k.test(b),\n            l = !B && (this.symbols[b] ? b : \"circle\"),\n            h = l && this.symbols[l],\n            t = z(a) && h && h.call(this.symbols, Math.round(a), Math.round(c), n, x, f);\n\n        if (h) {\n          var y = this.path(t);\n          q.styledMode || y.attr(\"fill\", \"none\");\n          M(y, {\n            symbolName: l,\n            x: a,\n            y: c,\n            width: n,\n            height: x\n          });\n          f && M(y, f);\n        } else if (B) {\n          var G = b.match(k)[1];\n          y = this.image(G);\n          y.imgwidth = d(P[G] && P[G].width, f && f.width);\n          y.imgheight = d(P[G] && P[G].height, f && f.height);\n\n          var w = function () {\n            y.attr({\n              width: y.width,\n              height: y.height\n            });\n          };\n\n          [\"width\", \"height\"].forEach(function (b) {\n            y[b + \"Setter\"] = function (b, a) {\n              var d = {},\n                  c = this[\"img\" + a],\n                  n = \"width\" === a ? \"translateX\" : \"translateY\";\n              this[a] = b;\n              z(c) && (f && \"within\" === f.backgroundSize && this.width && this.height && (c = Math.round(c * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(a, c), this.alignByTranslate || (d[n] = ((this[a] || 0) - c) / 2, this.attr(d)));\n            };\n          });\n          z(a) && y.attr({\n            x: a,\n            y: c\n          });\n          y.isImg = !0;\n          z(y.imgwidth) && z(y.imgheight) ? w() : (y.attr({\n            width: 0,\n            height: 0\n          }), C(\"img\", {\n            onload: function () {\n              var b = F[q.chartIndex];\n              0 === this.width && (J(this, {\n                position: \"absolute\",\n                top: \"-999em\"\n              }), S.body.appendChild(this));\n              P[G] = {\n                width: this.width,\n                height: this.height\n              };\n              y.imgwidth = this.width;\n              y.imgheight = this.height;\n              y.element && w();\n              this.parentNode && this.parentNode.removeChild(this);\n              q.imgCount--;\n              if (!q.imgCount && b && !b.hasLoaded) b.onload();\n            },\n            src: G\n          }), this.imgCount++);\n        }\n\n        return y;\n      },\n      symbols: {\n        circle: function (b, a, d, c) {\n          return this.arc(b + d / 2, a + c / 2, d / 2, c / 2, {\n            start: .5 * Math.PI,\n            end: 2.5 * Math.PI,\n            open: !1\n          });\n        },\n        square: function (b, a, d, c) {\n          return [\"M\", b, a, \"L\", b + d, a, b + d, a + c, b, a + c, \"Z\"];\n        },\n        triangle: function (b, a, d, c) {\n          return [\"M\", b + d / 2, a, \"L\", b + d, a + c, b, a + c, \"Z\"];\n        },\n        \"triangle-down\": function (b, a, d, c) {\n          return [\"M\", b, a, \"L\", b + d, a, b + d / 2, a + c, \"Z\"];\n        },\n        diamond: function (b, a, d, c) {\n          return [\"M\", b + d / 2, a, \"L\", b + d, a + c / 2, b + d / 2, a + c, b, a + c / 2, \"Z\"];\n        },\n        arc: function (b, a, c, n, x) {\n          var f = x.start,\n              q = x.r || c,\n              k = x.r || n || c,\n              B = x.end - .001;\n          c = x.innerR;\n          n = d(x.open, .001 > Math.abs(x.end - x.start - 2 * Math.PI));\n          var l = Math.cos(f),\n              h = Math.sin(f),\n              y = Math.cos(B);\n          B = Math.sin(B);\n          f = d(x.longArc, .001 > x.end - f - Math.PI ? 0 : 1);\n          q = [\"M\", b + q * l, a + k * h, \"A\", q, k, 0, f, d(x.clockwise, 1), b + q * y, a + k * B];\n          z(c) && q.push(n ? \"M\" : \"L\", b + c * y, a + c * B, \"A\", c, c, 0, f, z(x.clockwise) ? 1 - x.clockwise : 0, b + c * l, a + c * h);\n          q.push(n ? \"\" : \"Z\");\n          return q;\n        },\n        callout: function (b, a, d, c, n) {\n          var x = Math.min(n && n.r || 0, d, c),\n              f = x + 6,\n              k = n && n.anchorX;\n          n = n && n.anchorY;\n          var B = [\"M\", b + x, a, \"L\", b + d - x, a, \"C\", b + d, a, b + d, a, b + d, a + x, \"L\", b + d, a + c - x, \"C\", b + d, a + c, b + d, a + c, b + d - x, a + c, \"L\", b + x, a + c, \"C\", b, a + c, b, a + c, b, a + c - x, \"L\", b, a + x, \"C\", b, a, b, a, b + x, a];\n          k && k > d ? n > a + f && n < a + c - f ? B.splice(13, 3, \"L\", b + d, n - 6, b + d + 6, n, b + d, n + 6, b + d, a + c - x) : B.splice(13, 3, \"L\", b + d, c / 2, k, n, b + d, c / 2, b + d, a + c - x) : k && 0 > k ? n > a + f && n < a + c - f ? B.splice(33, 3, \"L\", b, n + 6, b - 6, n, b, n - 6, b, a + x) : B.splice(33, 3, \"L\", b, c / 2, k, n, b, c / 2, b, a + x) : n && n > c && k > b + f && k < b + d - f ? B.splice(23, 3, \"L\", k + 6, a + c, k, a + c + 6, k - 6, a + c, b + x, a + c) : n && 0 > n && k > b + f && k < b + d - f && B.splice(3, 3, \"L\", k - 6, a, k, a - 6, k + 6, a, d - x, a);\n          return B;\n        }\n      },\n      clipRect: function (b, a, d, c) {\n        var n = y() + \"-\",\n            x = this.createElement(\"clipPath\").attr({\n          id: n\n        }).add(this.defs);\n        b = this.rect(b, a, d, c, 0).add(x);\n        b.id = n;\n        b.clipPath = x;\n        b.count = 0;\n        return b;\n      },\n      text: function (b, a, d, c) {\n        var n = {};\n        if (c && (this.allowHTML || !this.forExport)) return this.html(b, a, d);\n        n.x = Math.round(a || 0);\n        d && (n.y = Math.round(d));\n        z(b) && (n.text = b);\n        b = this.createElement(\"text\").attr(n);\n        c || (b.xSetter = function (b, a, d) {\n          var c = d.getElementsByTagName(\"tspan\"),\n              n = d.getAttribute(a),\n              x;\n\n          for (x = 0; x < c.length; x++) {\n            var f = c[x];\n            f.getAttribute(a) === n && f.setAttribute(a, b);\n          }\n\n          d.setAttribute(a, b);\n        });\n        return b;\n      },\n      fontMetrics: function (b, d) {\n        b = !this.styledMode && /px/.test(b) || !W.getComputedStyle ? b || d && d.style && d.style.fontSize || this.style && this.style.fontSize : d && U.prototype.getStyle.call(d, \"font-size\");\n        b = /px/.test(b) ? a(b) : 12;\n        d = 24 > b ? b + 3 : Math.round(1.2 * b);\n        return {\n          h: d,\n          b: Math.round(.8 * d),\n          f: b\n        };\n      },\n      rotCorr: function (b, a, d) {\n        var c = b;\n        a && d && (c = Math.max(c * Math.cos(a * I), 4));\n        return {\n          x: -b / 3 * Math.sin(a * I),\n          y: c\n        };\n      },\n      label: function (b, a, d, c, n, x, f, B, h) {\n        var q = this,\n            y = q.styledMode,\n            t = q.g(\"button\" !== h && \"label\"),\n            w = t.text = q.text(\"\", 0, 0, f).attr({\n          zIndex: 1\n        }),\n            G,\n            P,\n            m = 0,\n            T = 3,\n            v = 0,\n            e,\n            F,\n            W,\n            V,\n            I,\n            Q = {},\n            r,\n            g,\n            N = /^url\\((.*?)\\)$/.test(c),\n            S = y || N,\n            D = function () {\n          return y ? G.strokeWidth() % 2 / 2 : (r ? parseInt(r, 10) : 0) % 2 / 2;\n        };\n\n        h && t.addClass(\"highcharts-\" + h);\n\n        var O = function () {\n          var b = w.element.style,\n              a = {};\n          P = (\"undefined\" === typeof e || \"undefined\" === typeof F || I) && z(w.textStr) && w.getBBox();\n          t.width = (e || P.width || 0) + 2 * T + v;\n          t.height = (F || P.height || 0) + 2 * T;\n          g = T + Math.min(q.fontMetrics(b && b.fontSize, w).b, P ? P.height : Infinity);\n          S && (G || (t.box = G = q.symbols[c] || N ? q.symbol(c) : q.rect(), G.addClass((\"button\" === h ? \"\" : \"highcharts-label-box\") + (h ? \" highcharts-\" + h + \"-box\" : \"\")), G.add(t), b = D(), a.x = b, a.y = (B ? -g : 0) + b), a.width = Math.round(t.width), a.height = Math.round(t.height), G.attr(M(a, Q)), Q = {});\n        };\n\n        var ba = function () {\n          var b = v + T;\n          var a = B ? 0 : g;\n          z(e) && P && (\"center\" === I || \"right\" === I) && (b += {\n            center: .5,\n            right: 1\n          }[I] * (e - P.width));\n          if (b !== w.x || a !== w.y) w.attr(\"x\", b), w.hasBoxWidthChanged && (P = w.getBBox(!0), O()), \"undefined\" !== typeof a && w.attr(\"y\", a);\n          w.x = b;\n          w.y = a;\n        };\n\n        var Y = function (b, a) {\n          G ? G.attr(b, a) : Q[b] = a;\n        };\n\n        t.onAdd = function () {\n          w.add(t);\n          t.attr({\n            text: b || 0 === b ? b : \"\",\n            x: a,\n            y: d\n          });\n          G && z(n) && t.attr({\n            anchorX: n,\n            anchorY: x\n          });\n        };\n\n        t.widthSetter = function (b) {\n          e = H(b) ? b : null;\n        };\n\n        t.heightSetter = function (b) {\n          F = b;\n        };\n\n        t[\"text-alignSetter\"] = function (b) {\n          I = b;\n        };\n\n        t.paddingSetter = function (b) {\n          z(b) && b !== T && (T = t.padding = b, ba());\n        };\n\n        t.paddingLeftSetter = function (b) {\n          z(b) && b !== v && (v = b, ba());\n        };\n\n        t.alignSetter = function (b) {\n          b = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[b];\n          b !== m && (m = b, P && t.attr({\n            x: W\n          }));\n        };\n\n        t.textSetter = function (b) {\n          \"undefined\" !== typeof b && w.attr({\n            text: b\n          });\n          O();\n          ba();\n        };\n\n        t[\"stroke-widthSetter\"] = function (b, a) {\n          b && (S = !0);\n          r = this[\"stroke-width\"] = b;\n          Y(a, b);\n        };\n\n        y ? t.rSetter = function (b, a) {\n          Y(a, b);\n        } : t.strokeSetter = t.fillSetter = t.rSetter = function (b, a) {\n          \"r\" !== a && (\"fill\" === a && b && (S = !0), t[a] = b);\n          Y(a, b);\n        };\n\n        t.anchorXSetter = function (b, a) {\n          n = t.anchorX = b;\n          Y(a, Math.round(b) - D() - W);\n        };\n\n        t.anchorYSetter = function (b, a) {\n          x = t.anchorY = b;\n          Y(a, b - V);\n        };\n\n        t.xSetter = function (b) {\n          t.x = b;\n          m && (b -= m * ((e || P.width) + 2 * T), t[\"forceAnimate:x\"] = !0);\n          W = Math.round(b);\n          t.attr(\"translateX\", W);\n        };\n\n        t.ySetter = function (b) {\n          V = t.y = Math.round(b);\n          t.attr(\"translateY\", V);\n        };\n\n        var u = t.css;\n        f = {\n          css: function (b) {\n            if (b) {\n              var a = {};\n              b = l(b);\n              t.textProps.forEach(function (d) {\n                \"undefined\" !== typeof b[d] && (a[d] = b[d], delete b[d]);\n              });\n              w.css(a);\n              \"width\" in a && O();\n              \"fontSize\" in a && (O(), ba());\n            }\n\n            return u.call(t, b);\n          },\n          getBBox: function () {\n            return {\n              width: P.width + 2 * T,\n              height: P.height + 2 * T,\n              x: P.x - T,\n              y: P.y - T\n            };\n          },\n          destroy: function () {\n            k(t.element, \"mouseenter\");\n            k(t.element, \"mouseleave\");\n            w && (w = w.destroy());\n            G && (G = G.destroy());\n            U.prototype.destroy.call(t);\n            t = q = O = ba = Y = null;\n          }\n        };\n        y || (f.shadow = function (b) {\n          b && (O(), G && G.shadow(b));\n          return t;\n        });\n        return M(t, f);\n      }\n    });\n    e.Renderer = g;\n  });\n  R(p, \"parts/Html.js\", [p[\"parts/Globals.js\"], p[\"parts/Utilities.js\"]], function (e, g) {\n    var p = g.attr,\n        u = g.createElement,\n        K = g.css,\n        L = g.defined,\n        E = g.extend,\n        A = g.pick,\n        C = g.pInt,\n        J = e.isFirefox,\n        z = e.isMS,\n        r = e.isWebKit,\n        D = e.SVGElement;\n    g = e.SVGRenderer;\n    var M = e.win;\n    E(D.prototype, {\n      htmlCss: function (v) {\n        var m = \"SPAN\" === this.element.tagName && v && \"width\" in v,\n            e = A(m && v.width, void 0);\n\n        if (m) {\n          delete v.width;\n          this.textWidth = e;\n          var f = !0;\n        }\n\n        v && \"ellipsis\" === v.textOverflow && (v.whiteSpace = \"nowrap\", v.overflow = \"hidden\");\n        this.styles = E(this.styles, v);\n        K(this.element, v);\n        f && this.htmlUpdateTransform();\n        return this;\n      },\n      htmlGetBBox: function () {\n        var e = this.element;\n        return {\n          x: e.offsetLeft,\n          y: e.offsetTop,\n          width: e.offsetWidth,\n          height: e.offsetHeight\n        };\n      },\n      htmlUpdateTransform: function () {\n        if (this.added) {\n          var e = this.renderer,\n              m = this.element,\n              H = this.translateX || 0,\n              f = this.translateY || 0,\n              c = this.x || 0,\n              l = this.y || 0,\n              h = this.textAlign || \"left\",\n              d = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[h],\n              a = this.styles,\n              k = a && a.whiteSpace;\n          K(m, {\n            marginLeft: H,\n            marginTop: f\n          });\n          !e.styledMode && this.shadows && this.shadows.forEach(function (a) {\n            K(a, {\n              marginLeft: H + 1,\n              marginTop: f + 1\n            });\n          });\n          this.inverted && [].forEach.call(m.childNodes, function (a) {\n            e.invertChild(a, m);\n          });\n\n          if (\"SPAN\" === m.tagName) {\n            a = this.rotation;\n            var t = this.textWidth && C(this.textWidth),\n                w = [a, h, m.innerHTML, this.textWidth, this.textAlign].join(),\n                y;\n            (y = t !== this.oldTextWidth) && !(y = t > this.oldTextWidth) && ((y = this.textPxLength) || (K(m, {\n              width: \"\",\n              whiteSpace: k || \"nowrap\"\n            }), y = m.offsetWidth), y = y > t);\n            y && (/[ \\-]/.test(m.textContent || m.innerText) || \"ellipsis\" === m.style.textOverflow) ? (K(m, {\n              width: t + \"px\",\n              display: \"block\",\n              whiteSpace: k || \"normal\"\n            }), this.oldTextWidth = t, this.hasBoxWidthChanged = !0) : this.hasBoxWidthChanged = !1;\n            w !== this.cTT && (k = e.fontMetrics(m.style.fontSize, m).b, !L(a) || a === (this.oldRotation || 0) && h === this.oldAlign || this.setSpanRotation(a, d, k), this.getSpanCorrection(!L(a) && this.textPxLength || m.offsetWidth, k, d, a, h));\n            K(m, {\n              left: c + (this.xCorr || 0) + \"px\",\n              top: l + (this.yCorr || 0) + \"px\"\n            });\n            this.cTT = w;\n            this.oldRotation = a;\n            this.oldAlign = h;\n          }\n        } else this.alignOnAdd = !0;\n      },\n      setSpanRotation: function (e, m, H) {\n        var f = {},\n            c = this.renderer.getTransformKey();\n        f[c] = f.transform = \"rotate(\" + e + \"deg)\";\n        f[c + (J ? \"Origin\" : \"-origin\")] = f.transformOrigin = 100 * m + \"% \" + H + \"px\";\n        K(this.element, f);\n      },\n      getSpanCorrection: function (e, m, H) {\n        this.xCorr = -e * H;\n        this.yCorr = -m;\n      }\n    });\n    E(g.prototype, {\n      getTransformKey: function () {\n        return z && !/Edge/.test(M.navigator.userAgent) ? \"-ms-transform\" : r ? \"-webkit-transform\" : J ? \"MozTransform\" : M.opera ? \"-o-transform\" : \"\";\n      },\n      html: function (e, m, H) {\n        var f = this.createElement(\"span\"),\n            c = f.element,\n            l = f.renderer,\n            h = l.isSVG,\n            d = function (a, d) {\n          [\"opacity\", \"visibility\"].forEach(function (c) {\n            a[c + \"Setter\"] = function (f, k, t) {\n              var l = a.div ? a.div.style : d;\n              D.prototype[c + \"Setter\"].call(this, f, k, t);\n              l && (l[k] = f);\n            };\n          });\n          a.addedSetters = !0;\n        };\n\n        f.textSetter = function (a) {\n          a !== c.innerHTML && (delete this.bBox, delete this.oldTextWidth);\n          this.textStr = a;\n          c.innerHTML = A(a, \"\");\n          f.doTransform = !0;\n        };\n\n        h && d(f, f.element.style);\n\n        f.xSetter = f.ySetter = f.alignSetter = f.rotationSetter = function (a, d) {\n          \"align\" === d && (d = \"textAlign\");\n          f[d] = a;\n          f.doTransform = !0;\n        };\n\n        f.afterSetters = function () {\n          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);\n        };\n\n        f.attr({\n          text: e,\n          x: Math.round(m),\n          y: Math.round(H)\n        }).css({\n          position: \"absolute\"\n        });\n        l.styledMode || f.css({\n          fontFamily: this.style.fontFamily,\n          fontSize: this.style.fontSize\n        });\n        c.style.whiteSpace = \"nowrap\";\n        f.css = f.htmlCss;\n        h && (f.add = function (a) {\n          var k = l.box.parentNode,\n              t = [];\n\n          if (this.parentGroup = a) {\n            var h = a.div;\n\n            if (!h) {\n              for (; a;) t.push(a), a = a.parentGroup;\n\n              t.reverse().forEach(function (a) {\n                function c(d, c) {\n                  a[c] = d;\n                  \"translateX\" === c ? y.left = d + \"px\" : y.top = d + \"px\";\n                  a.doTransform = !0;\n                }\n\n                var l = p(a.element, \"class\");\n                h = a.div = a.div || u(\"div\", l ? {\n                  className: l\n                } : void 0, {\n                  position: \"absolute\",\n                  left: (a.translateX || 0) + \"px\",\n                  top: (a.translateY || 0) + \"px\",\n                  display: a.display,\n                  opacity: a.opacity,\n                  pointerEvents: a.styles && a.styles.pointerEvents\n                }, h || k);\n                var y = h.style;\n                E(a, {\n                  classSetter: function (a) {\n                    return function (d) {\n                      this.element.setAttribute(\"class\", d);\n                      a.className = d;\n                    };\n                  }(h),\n                  on: function () {\n                    t[0].div && f.on.apply({\n                      element: t[0].div\n                    }, arguments);\n                    return a;\n                  },\n                  translateXSetter: c,\n                  translateYSetter: c\n                });\n                a.addedSetters || d(a);\n              });\n            }\n          } else h = k;\n\n          h.appendChild(c);\n          f.added = !0;\n          f.alignOnAdd && f.htmlUpdateTransform();\n          return f;\n        });\n        return f;\n      }\n    });\n  });\n  R(p, \"parts/Tick.js\", [p[\"parts/Globals.js\"], p[\"parts/Utilities.js\"]], function (e, g) {\n    var p = g.clamp,\n        u = g.correctFloat,\n        K = g.defined,\n        L = g.destroyObjectProperties,\n        E = g.extend,\n        A = g.isNumber,\n        C = g.merge,\n        J = g.objectEach,\n        z = g.pick,\n        r = e.fireEvent,\n        D = e.deg2rad;\n\n    g = function () {\n      function g(e, m, H, f, c) {\n        this.isNewLabel = this.isNew = !0;\n        this.axis = e;\n        this.pos = m;\n        this.type = H || \"\";\n        this.parameters = c || {};\n        this.tickmarkOffset = this.parameters.tickmarkOffset;\n        this.options = this.parameters.options;\n        H || f || this.addLabel();\n      }\n\n      g.prototype.addLabel = function () {\n        var e = this,\n            m = e.axis,\n            H = m.options,\n            f = m.chart,\n            c = m.categories,\n            l = m.names,\n            h = e.pos,\n            d = z(e.options && e.options.labels, H.labels),\n            a = m.tickPositions,\n            k = h === a[0],\n            t = h === a[a.length - 1];\n        l = this.parameters.category || (c ? z(c[h], l[h], h) : h);\n        var w = e.label;\n        c = (!d.step || 1 === d.step) && 1 === m.tickInterval;\n        a = a.info;\n        var y, F;\n\n        if (m.isDatetimeAxis && a) {\n          var I = f.time.resolveDTLFormat(H.dateTimeLabelFormats[!H.grid && a.higherRanks[h] || a.unitName]);\n          var g = I.main;\n        }\n\n        e.isFirst = k;\n        e.isLast = t;\n        e.formatCtx = {\n          axis: m,\n          chart: f,\n          isFirst: k,\n          isLast: t,\n          dateTimeLabelFormat: g,\n          tickPositionInfo: a,\n          value: m.isLog ? u(m.lin2log(l)) : l,\n          pos: h\n        };\n        H = m.labelFormatter.call(e.formatCtx, this.formatCtx);\n        if (F = I && I.list) e.shortenLabel = function () {\n          for (y = 0; y < F.length; y++) if (w.attr({\n            text: m.labelFormatter.call(E(e.formatCtx, {\n              dateTimeLabelFormat: F[y]\n            }))\n          }), w.getBBox().width < m.getSlotWidth(e) - 2 * z(d.padding, 5)) return;\n\n          w.attr({\n            text: \"\"\n          });\n        };\n        c && m._addedPlotLB && m.isXAxis && e.moveLabel(H, d);\n        K(w) || e.movedLabel ? w && w.textStr !== H && !c && (!w.textWidth || d.style && d.style.width || w.styles.width || w.css({\n          width: null\n        }), w.attr({\n          text: H\n        }), w.textPxLength = w.getBBox().width) : (e.label = w = e.createLabel({\n          x: 0,\n          y: 0\n        }, H, d), e.rotation = 0);\n      };\n\n      g.prototype.createLabel = function (e, m, g) {\n        var f = this.axis,\n            c = f.chart;\n        if (e = K(m) && g.enabled ? c.renderer.text(m, e.x, e.y, g.useHTML).add(f.labelGroup) : null) c.styledMode || e.css(C(g.style)), e.textPxLength = e.getBBox().width;\n        return e;\n      };\n\n      g.prototype.destroy = function () {\n        L(this, this.axis);\n      };\n\n      g.prototype.getPosition = function (e, m, g, f) {\n        var c = this.axis,\n            l = c.chart,\n            h = f && l.oldChartHeight || l.chartHeight;\n        e = {\n          x: e ? u(c.translate(m + g, null, null, f) + c.transB) : c.left + c.offset + (c.opposite ? (f && l.oldChartWidth || l.chartWidth) - c.right - c.left : 0),\n          y: e ? h - c.bottom + c.offset - (c.opposite ? c.height : 0) : u(h - c.translate(m + g, null, null, f) - c.transB)\n        };\n        e.y = p(e.y, -1E5, 1E5);\n        r(this, \"afterGetPosition\", {\n          pos: e\n        });\n        return e;\n      };\n\n      g.prototype.getLabelPosition = function (e, m, g, f, c, l, h, d) {\n        var a = this.axis,\n            k = a.transA,\n            t = a.isLinked && a.linkedParent ? a.linkedParent.reversed : a.reversed,\n            w = a.staggerLines,\n            y = a.tickRotCorr || {\n          x: 0,\n          y: 0\n        },\n            F = c.y,\n            v = f || a.reserveSpaceDefault ? 0 : -a.labelOffset * (\"center\" === a.labelAlign ? .5 : 1),\n            H = {};\n        K(F) || (F = 0 === a.side ? g.rotation ? -8 : -g.getBBox().height : 2 === a.side ? y.y + 8 : Math.cos(g.rotation * D) * (y.y - g.getBBox(!1, 0).height / 2));\n        e = e + c.x + v + y.x - (l && f ? l * k * (t ? -1 : 1) : 0);\n        m = m + F - (l && !f ? l * k * (t ? 1 : -1) : 0);\n        w && (g = h / (d || 1) % w, a.opposite && (g = w - g - 1), m += a.labelOffset / w * g);\n        H.x = e;\n        H.y = Math.round(m);\n        r(this, \"afterGetLabelPosition\", {\n          pos: H,\n          tickmarkOffset: l,\n          index: h\n        });\n        return H;\n      };\n\n      g.prototype.getLabelSize = function () {\n        return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n      };\n\n      g.prototype.getMarkPath = function (e, m, g, f, c, l) {\n        return l.crispLine([\"M\", e, m, \"L\", e + (c ? 0 : -g), m + (c ? g : 0)], f);\n      };\n\n      g.prototype.handleOverflow = function (e) {\n        var m = this.axis,\n            v = m.options.labels,\n            f = e.x,\n            c = m.chart.chartWidth,\n            l = m.chart.spacing,\n            h = z(m.labelLeft, Math.min(m.pos, l[3]));\n        l = z(m.labelRight, Math.max(m.isRadial ? 0 : m.pos + m.len, c - l[1]));\n        var d = this.label,\n            a = this.rotation,\n            k = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[m.labelAlign || d.attr(\"align\")],\n            t = d.getBBox().width,\n            w = m.getSlotWidth(this),\n            y = w,\n            F = 1,\n            g,\n            r = {};\n        if (a || \"justify\" !== z(v.overflow, \"justify\")) 0 > a && f - k * t < h ? g = Math.round(f / Math.cos(a * D) - h) : 0 < a && f + k * t > l && (g = Math.round((c - f) / Math.cos(a * D)));else if (c = f + (1 - k) * t, f - k * t < h ? y = e.x + y * (1 - k) - h : c > l && (y = l - e.x + y * k, F = -1), y = Math.min(w, y), y < w && \"center\" === m.labelAlign && (e.x += F * (w - y - k * (w - Math.min(t, y)))), t > y || m.autoRotation && (d.styles || {}).width) g = y;\n        g && (this.shortenLabel ? this.shortenLabel() : (r.width = Math.floor(g), (v.style || {}).textOverflow || (r.textOverflow = \"ellipsis\"), d.css(r)));\n      };\n\n      g.prototype.moveLabel = function (e, m) {\n        var v = this,\n            f = v.label,\n            c = !1,\n            l = v.axis,\n            h = l.reversed,\n            d = l.chart.inverted;\n        f && f.textStr === e ? (v.movedLabel = f, c = !0, delete v.label) : J(l.ticks, function (a) {\n          c || a.isNew || a === v || !a.label || a.label.textStr !== e || (v.movedLabel = a.label, c = !0, a.labelPos = v.movedLabel.xy, delete a.label);\n        });\n\n        if (!c && (v.labelPos || f)) {\n          var a = v.labelPos || f.xy;\n          f = d ? a.x : h ? 0 : l.width + l.left;\n          l = d ? h ? l.width + l.left : 0 : a.y;\n          v.movedLabel = v.createLabel({\n            x: f,\n            y: l\n          }, e, m);\n          v.movedLabel && v.movedLabel.attr({\n            opacity: 0\n          });\n        }\n      };\n\n      g.prototype.render = function (v, m, g) {\n        var f = this.axis,\n            c = f.horiz,\n            l = this.pos,\n            h = z(this.tickmarkOffset, f.tickmarkOffset);\n        l = this.getPosition(c, l, h, m);\n        h = l.x;\n        var d = l.y;\n        f = c && h === f.pos + f.len || !c && d === f.pos ? -1 : 1;\n        g = z(g, 1);\n        this.isActive = !0;\n        this.renderGridLine(m, g, f);\n        this.renderMark(l, g, f);\n        this.renderLabel(l, m, g, v);\n        this.isNew = !1;\n        e.fireEvent(this, \"afterRender\");\n      };\n\n      g.prototype.renderGridLine = function (e, m, g) {\n        var f = this.axis,\n            c = f.options,\n            l = this.gridLine,\n            h = {},\n            d = this.pos,\n            a = this.type,\n            k = z(this.tickmarkOffset, f.tickmarkOffset),\n            t = f.chart.renderer,\n            w = a ? a + \"Grid\" : \"grid\",\n            y = c[w + \"LineWidth\"],\n            F = c[w + \"LineColor\"];\n        c = c[w + \"LineDashStyle\"];\n        l || (f.chart.styledMode || (h.stroke = F, h[\"stroke-width\"] = y, c && (h.dashstyle = c)), a || (h.zIndex = 1), e && (m = 0), this.gridLine = l = t.path().attr(h).addClass(\"highcharts-\" + (a ? a + \"-\" : \"\") + \"grid-line\").add(f.gridGroup));\n        if (l && (g = f.getPlotLinePath({\n          value: d + k,\n          lineWidth: l.strokeWidth() * g,\n          force: \"pass\",\n          old: e\n        }))) l[e || this.isNew ? \"attr\" : \"animate\"]({\n          d: g,\n          opacity: m\n        });\n      };\n\n      g.prototype.renderMark = function (e, m, g) {\n        var f = this.axis,\n            c = f.options,\n            l = f.chart.renderer,\n            h = this.type,\n            d = h ? h + \"Tick\" : \"tick\",\n            a = f.tickSize(d),\n            k = this.mark,\n            t = !k,\n            w = e.x;\n        e = e.y;\n        var y = z(c[d + \"Width\"], !h && f.isXAxis ? 1 : 0);\n        c = c[d + \"Color\"];\n        a && (f.opposite && (a[0] = -a[0]), t && (this.mark = k = l.path().addClass(\"highcharts-\" + (h ? h + \"-\" : \"\") + \"tick\").add(f.axisGroup), f.chart.styledMode || k.attr({\n          stroke: c,\n          \"stroke-width\": y\n        })), k[t ? \"attr\" : \"animate\"]({\n          d: this.getMarkPath(w, e, a[0], k.strokeWidth() * g, f.horiz, l),\n          opacity: m\n        }));\n      };\n\n      g.prototype.renderLabel = function (e, m, g, f) {\n        var c = this.axis,\n            l = c.horiz,\n            h = c.options,\n            d = this.label,\n            a = h.labels,\n            k = a.step;\n        c = z(this.tickmarkOffset, c.tickmarkOffset);\n        var t = !0,\n            w = e.x;\n        e = e.y;\n        d && A(w) && (d.xy = e = this.getLabelPosition(w, e, d, l, a, c, f, k), this.isFirst && !this.isLast && !z(h.showFirstLabel, 1) || this.isLast && !this.isFirst && !z(h.showLastLabel, 1) ? t = !1 : !l || a.step || a.rotation || m || 0 === g || this.handleOverflow(e), k && f % k && (t = !1), t && A(e.y) ? (e.opacity = g, d[this.isNewLabel ? \"attr\" : \"animate\"](e), this.isNewLabel = !1) : (d.attr(\"y\", -9999), this.isNewLabel = !0));\n      };\n\n      g.prototype.replaceMovedLabel = function () {\n        var e = this.label,\n            m = this.axis,\n            g = m.reversed,\n            f = this.axis.chart.inverted;\n\n        if (e && !this.isNew) {\n          var c = f ? e.xy.x : g ? m.left : m.width + m.left;\n          g = f ? g ? m.width + m.top : m.top : e.xy.y;\n          e.animate({\n            x: c,\n            y: g,\n            opacity: 0\n          }, void 0, e.destroy);\n          delete this.label;\n        }\n\n        m.isDirty = !0;\n        this.label = this.movedLabel;\n        delete this.movedLabel;\n      };\n\n      return g;\n    }();\n\n    e.Tick = g;\n    return e.Tick;\n  });\n  R(p, \"parts/Time.js\", [p[\"parts/Globals.js\"], p[\"parts/Utilities.js\"]], function (e, g) {\n    var p = g.defined,\n        u = g.error,\n        K = g.extend,\n        L = g.isObject,\n        E = g.merge,\n        A = g.objectEach,\n        C = g.pad,\n        J = g.pick,\n        z = g.splat,\n        r = g.timeUnits,\n        D = e.win;\n\n    g = function () {\n      function g(e) {\n        this.options = {};\n        this.variableTimezone = this.useUTC = !1;\n        this.Date = D.Date;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        this.update(e);\n      }\n\n      g.prototype.get = function (e, m) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          var g = m.getTime(),\n              f = g - this.getTimezoneOffset(m);\n          m.setTime(f);\n          e = m[\"getUTC\" + e]();\n          m.setTime(g);\n          return e;\n        }\n\n        return this.useUTC ? m[\"getUTC\" + e]() : m[\"get\" + e]();\n      };\n\n      g.prototype.set = function (e, m, g) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          if (\"Milliseconds\" === e || \"Seconds\" === e || \"Minutes\" === e) return m[\"setUTC\" + e](g);\n          var f = this.getTimezoneOffset(m);\n          f = m.getTime() - f;\n          m.setTime(f);\n          m[\"setUTC\" + e](g);\n          e = this.getTimezoneOffset(m);\n          f = m.getTime() + e;\n          return m.setTime(f);\n        }\n\n        return this.useUTC ? m[\"setUTC\" + e](g) : m[\"set\" + e](g);\n      };\n\n      g.prototype.update = function (e) {\n        var m = J(e && e.useUTC, !0);\n        this.options = e = E(!0, this.options || {}, e);\n        this.Date = e.Date || D.Date || Date;\n        this.timezoneOffset = (this.useUTC = m) && e.timezoneOffset;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        this.variableTimezone = !(m && !e.getTimezoneOffset && !e.timezone);\n      };\n\n      g.prototype.makeTime = function (g, m, r, f, c, l) {\n        if (this.useUTC) {\n          var h = this.Date.UTC.apply(0, arguments);\n          var d = this.getTimezoneOffset(h);\n          h += d;\n          var a = this.getTimezoneOffset(h);\n          d !== a ? h += a - d : d - 36E5 !== this.getTimezoneOffset(h - 36E5) || e.isSafari || (h -= 36E5);\n        } else h = new this.Date(g, m, J(r, 1), J(f, 0), J(c, 0), J(l, 0)).getTime();\n\n        return h;\n      };\n\n      g.prototype.timezoneOffsetFunction = function () {\n        var e = this,\n            m = this.options,\n            g = D.moment;\n        if (!this.useUTC) return function (f) {\n          return 6E4 * new Date(f.toString()).getTimezoneOffset();\n        };\n\n        if (m.timezone) {\n          if (g) return function (f) {\n            return 6E4 * -g.tz(f, m.timezone).utcOffset();\n          };\n          u(25);\n        }\n\n        return this.useUTC && m.getTimezoneOffset ? function (f) {\n          return 6E4 * m.getTimezoneOffset(f);\n        } : function () {\n          return 6E4 * (e.timezoneOffset || 0);\n        };\n      };\n\n      g.prototype.dateFormat = function (g, m, r) {\n        var f;\n        if (!p(m) || isNaN(m)) return (null === (f = e.defaultOptions.lang) || void 0 === f ? void 0 : f.invalidDate) || \"\";\n        g = J(g, \"%Y-%m-%d %H:%M:%S\");\n        var c = this;\n        f = new this.Date(m);\n        var l = this.get(\"Hours\", f),\n            h = this.get(\"Day\", f),\n            d = this.get(\"Date\", f),\n            a = this.get(\"Month\", f),\n            k = this.get(\"FullYear\", f),\n            t = e.defaultOptions.lang,\n            w = null === t || void 0 === t ? void 0 : t.weekdays,\n            y = null === t || void 0 === t ? void 0 : t.shortWeekdays;\n        f = K({\n          a: y ? y[h] : w[h].substr(0, 3),\n          A: w[h],\n          d: C(d),\n          e: C(d, 2, \" \"),\n          w: h,\n          b: t.shortMonths[a],\n          B: t.months[a],\n          m: C(a + 1),\n          o: a + 1,\n          y: k.toString().substr(2, 2),\n          Y: k,\n          H: C(l),\n          k: l,\n          I: C(l % 12 || 12),\n          l: l % 12 || 12,\n          M: C(this.get(\"Minutes\", f)),\n          p: 12 > l ? \"AM\" : \"PM\",\n          P: 12 > l ? \"am\" : \"pm\",\n          S: C(f.getSeconds()),\n          L: C(Math.floor(m % 1E3), 3)\n        }, e.dateFormats);\n        A(f, function (a, d) {\n          for (; -1 !== g.indexOf(\"%\" + d);) g = g.replace(\"%\" + d, \"function\" === typeof a ? a.call(c, m) : a);\n        });\n        return r ? g.substr(0, 1).toUpperCase() + g.substr(1) : g;\n      };\n\n      g.prototype.resolveDTLFormat = function (e) {\n        return L(e, !0) ? e : (e = z(e), {\n          main: e[0],\n          from: e[1],\n          to: e[2]\n        });\n      };\n\n      g.prototype.getTimeTicks = function (e, m, g, f) {\n        var c = this,\n            l = [],\n            h = {};\n        var d = new c.Date(m);\n        var a = e.unitRange,\n            k = e.count || 1,\n            t;\n        f = J(f, 1);\n\n        if (p(m)) {\n          c.set(\"Milliseconds\", d, a >= r.second ? 0 : k * Math.floor(c.get(\"Milliseconds\", d) / k));\n          a >= r.second && c.set(\"Seconds\", d, a >= r.minute ? 0 : k * Math.floor(c.get(\"Seconds\", d) / k));\n          a >= r.minute && c.set(\"Minutes\", d, a >= r.hour ? 0 : k * Math.floor(c.get(\"Minutes\", d) / k));\n          a >= r.hour && c.set(\"Hours\", d, a >= r.day ? 0 : k * Math.floor(c.get(\"Hours\", d) / k));\n          a >= r.day && c.set(\"Date\", d, a >= r.month ? 1 : Math.max(1, k * Math.floor(c.get(\"Date\", d) / k)));\n\n          if (a >= r.month) {\n            c.set(\"Month\", d, a >= r.year ? 0 : k * Math.floor(c.get(\"Month\", d) / k));\n            var w = c.get(\"FullYear\", d);\n          }\n\n          a >= r.year && c.set(\"FullYear\", d, w - w % k);\n          a === r.week && (w = c.get(\"Day\", d), c.set(\"Date\", d, c.get(\"Date\", d) - w + f + (w < f ? -7 : 0)));\n          w = c.get(\"FullYear\", d);\n          f = c.get(\"Month\", d);\n          var y = c.get(\"Date\", d),\n              F = c.get(\"Hours\", d);\n          m = d.getTime();\n          c.variableTimezone && (t = g - m > 4 * r.month || c.getTimezoneOffset(m) !== c.getTimezoneOffset(g));\n          m = d.getTime();\n\n          for (d = 1; m < g;) l.push(m), m = a === r.year ? c.makeTime(w + d * k, 0) : a === r.month ? c.makeTime(w, f + d * k) : !t || a !== r.day && a !== r.week ? t && a === r.hour && 1 < k ? c.makeTime(w, f, y, F + d * k) : m + a * k : c.makeTime(w, f, y + d * k * (a === r.day ? 1 : 7)), d++;\n\n          l.push(m);\n          a <= r.hour && 1E4 > l.length && l.forEach(function (a) {\n            0 === a % 18E5 && \"000000000\" === c.dateFormat(\"%H%M%S%L\", a) && (h[a] = \"day\");\n          });\n        }\n\n        l.info = K(e, {\n          higherRanks: h,\n          totalRange: a * k\n        });\n        return l;\n      };\n\n      g.defaultOptions = {\n        Date: void 0,\n        getTimezoneOffset: void 0,\n        timezone: void 0,\n        timezoneOffset: 0,\n        useUTC: !0\n      };\n      return g;\n    }();\n\n    e.Time = g;\n    return e.Time;\n  });\n  R(p, \"parts/Options.js\", [p[\"parts/Globals.js\"], p[\"parts/Time.js\"], p[\"parts/Color.js\"], p[\"parts/Utilities.js\"]], function (e, g, p, u) {\n    p = p.parse;\n    var K = u.merge;\n    e.defaultOptions = {\n      colors: \"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1\".split(\" \"),\n      symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"],\n      lang: {\n        loading: \"Loading...\",\n        months: \"January February March April May June July August September October November December\".split(\" \"),\n        shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\n        weekdays: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n        decimalPoint: \".\",\n        numericSymbols: \"kMGTPE\".split(\"\"),\n        resetZoom: \"Reset zoom\",\n        resetZoomTitle: \"Reset zoom level 1:1\",\n        thousandsSep: \" \"\n      },\n      global: {},\n      time: g.defaultOptions,\n      chart: {\n        styledMode: !1,\n        borderRadius: 0,\n        colorCount: 10,\n        defaultSeriesType: \"line\",\n        ignoreHiddenSeries: !0,\n        spacing: [10, 10, 15, 10],\n        resetZoomButton: {\n          theme: {\n            zIndex: 6\n          },\n          position: {\n            align: \"right\",\n            x: -10,\n            y: 10\n          }\n        },\n        width: null,\n        height: null,\n        borderColor: \"#335cad\",\n        backgroundColor: \"#ffffff\",\n        plotBorderColor: \"#cccccc\"\n      },\n      title: {\n        text: \"Chart title\",\n        align: \"center\",\n        margin: 15,\n        widthAdjust: -44\n      },\n      subtitle: {\n        text: \"\",\n        align: \"center\",\n        widthAdjust: -44\n      },\n      caption: {\n        margin: 15,\n        text: \"\",\n        align: \"left\",\n        verticalAlign: \"bottom\"\n      },\n      plotOptions: {},\n      labels: {\n        style: {\n          position: \"absolute\",\n          color: \"#333333\"\n        }\n      },\n      legend: {\n        enabled: !0,\n        align: \"center\",\n        alignColumns: !0,\n        layout: \"horizontal\",\n        labelFormatter: function () {\n          return this.name;\n        },\n        borderColor: \"#999999\",\n        borderRadius: 0,\n        navigation: {\n          activeColor: \"#003399\",\n          inactiveColor: \"#cccccc\"\n        },\n        itemStyle: {\n          color: \"#333333\",\n          cursor: \"pointer\",\n          fontSize: \"12px\",\n          fontWeight: \"bold\",\n          textOverflow: \"ellipsis\"\n        },\n        itemHoverStyle: {\n          color: \"#000000\"\n        },\n        itemHiddenStyle: {\n          color: \"#cccccc\"\n        },\n        shadow: !1,\n        itemCheckboxStyle: {\n          position: \"absolute\",\n          width: \"13px\",\n          height: \"13px\"\n        },\n        squareSymbol: !0,\n        symbolPadding: 5,\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0,\n        title: {\n          style: {\n            fontWeight: \"bold\"\n          }\n        }\n      },\n      loading: {\n        labelStyle: {\n          fontWeight: \"bold\",\n          position: \"relative\",\n          top: \"45%\"\n        },\n        style: {\n          position: \"absolute\",\n          backgroundColor: \"#ffffff\",\n          opacity: .5,\n          textAlign: \"center\"\n        }\n      },\n      tooltip: {\n        enabled: !0,\n        animation: e.svg,\n        borderRadius: 3,\n        dateTimeLabelFormats: {\n          millisecond: \"%A, %b %e, %H:%M:%S.%L\",\n          second: \"%A, %b %e, %H:%M:%S\",\n          minute: \"%A, %b %e, %H:%M\",\n          hour: \"%A, %b %e, %H:%M\",\n          day: \"%A, %b %e, %Y\",\n          week: \"Week from %A, %b %e, %Y\",\n          month: \"%B %Y\",\n          year: \"%Y\"\n        },\n        footerFormat: \"\",\n        padding: 8,\n        snap: e.isTouchDevice ? 25 : 10,\n        headerFormat: '<span style=\"font-size: 10px\">{point.key}</span><br/>',\n        pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> {series.name}: <b>{point.y}</b><br/>',\n        backgroundColor: p(\"#f7f7f7\").setOpacity(.85).get(),\n        borderWidth: 1,\n        shadow: !0,\n        style: {\n          color: \"#333333\",\n          cursor: \"default\",\n          fontSize: \"12px\",\n          pointerEvents: \"none\",\n          whiteSpace: \"nowrap\"\n        }\n      },\n      credits: {\n        enabled: !0,\n        href: \"https://www.highcharts.com?credits\",\n        position: {\n          align: \"right\",\n          x: -10,\n          verticalAlign: \"bottom\",\n          y: -5\n        },\n        style: {\n          cursor: \"pointer\",\n          color: \"#999999\",\n          fontSize: \"9px\"\n        },\n        text: \"Highcharts.com\"\n      }\n    };\n\n    e.setOptions = function (g) {\n      e.defaultOptions = K(!0, e.defaultOptions, g);\n      (g.time || g.global) && e.time.update(K(e.defaultOptions.global, e.defaultOptions.time, g.global, g.time));\n      return e.defaultOptions;\n    };\n\n    e.getOptions = function () {\n      return e.defaultOptions;\n    };\n\n    e.defaultPlotOptions = e.defaultOptions.plotOptions;\n    e.time = new g(K(e.defaultOptions.global, e.defaultOptions.time));\n\n    e.dateFormat = function (g, u, A) {\n      return e.time.dateFormat(g, u, A);\n    };\n\n    \"\";\n  });\n  R(p, \"parts/Axis.js\", [p[\"parts/Globals.js\"], p[\"parts/Color.js\"], p[\"parts/Tick.js\"], p[\"parts/Utilities.js\"]], function (e, g, p, u) {\n    var K = g.parse,\n        L = u.addEvent,\n        E = u.animObject,\n        A = u.arrayMax,\n        C = u.arrayMin,\n        J = u.clamp,\n        z = u.correctFloat,\n        r = u.defined,\n        D = u.destroyObjectProperties,\n        M = u.error,\n        v = u.extend,\n        m = u.fireEvent,\n        H = u.format,\n        f = u.getMagnitude,\n        c = u.isArray,\n        l = u.isFunction,\n        h = u.isNumber,\n        d = u.isString,\n        a = u.merge,\n        k = u.normalizeTickInterval,\n        t = u.objectEach,\n        w = u.pick,\n        y = u.relativeLength,\n        F = u.removeEvent,\n        I = u.splat,\n        S = u.syncTimeout,\n        O = e.defaultOptions,\n        N = e.deg2rad;\n\n    g = function () {\n      this.init.apply(this, arguments);\n    };\n\n    v(g.prototype, {\n      defaultOptions: {\n        dateTimeLabelFormats: {\n          millisecond: {\n            main: \"%H:%M:%S.%L\",\n            range: !1\n          },\n          second: {\n            main: \"%H:%M:%S\",\n            range: !1\n          },\n          minute: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          hour: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          day: {\n            main: \"%e. %b\"\n          },\n          week: {\n            main: \"%e. %b\"\n          },\n          month: {\n            main: \"%b '%y\"\n          },\n          year: {\n            main: \"%Y\"\n          }\n        },\n        endOnTick: !1,\n        labels: {\n          enabled: !0,\n          indentation: 10,\n          x: 0,\n          style: {\n            color: \"#666666\",\n            cursor: \"default\",\n            fontSize: \"11px\"\n          }\n        },\n        maxPadding: .01,\n        minorTickLength: 2,\n        minorTickPosition: \"outside\",\n        minPadding: .01,\n        showEmpty: !0,\n        startOfWeek: 1,\n        startOnTick: !1,\n        tickLength: 10,\n        tickPixelInterval: 100,\n        tickmarkPlacement: \"between\",\n        tickPosition: \"outside\",\n        title: {\n          align: \"middle\",\n          style: {\n            color: \"#666666\"\n          }\n        },\n        type: \"linear\",\n        minorGridLineColor: \"#f2f2f2\",\n        minorGridLineWidth: 1,\n        minorTickColor: \"#999999\",\n        lineColor: \"#ccd6eb\",\n        lineWidth: 1,\n        gridLineColor: \"#e6e6e6\",\n        tickColor: \"#ccd6eb\"\n      },\n      defaultYAxisOptions: {\n        endOnTick: !0,\n        maxPadding: .05,\n        minPadding: .05,\n        tickPixelInterval: 72,\n        showLastLabel: !0,\n        labels: {\n          x: -8\n        },\n        startOnTick: !0,\n        title: {\n          rotation: 270,\n          text: \"Values\"\n        },\n        stackLabels: {\n          allowOverlap: !1,\n          enabled: !1,\n          crop: !0,\n          overflow: \"justify\",\n          formatter: function () {\n            var a = this.axis.chart.numberFormatter;\n            return a(this.total, -1);\n          },\n          style: {\n            color: \"#000000\",\n            fontSize: \"11px\",\n            fontWeight: \"bold\",\n            textOutline: \"1px contrast\"\n          }\n        },\n        gridLineWidth: 1,\n        lineWidth: 0\n      },\n      defaultLeftAxisOptions: {\n        labels: {\n          x: -15\n        },\n        title: {\n          rotation: 270\n        }\n      },\n      defaultRightAxisOptions: {\n        labels: {\n          x: 15\n        },\n        title: {\n          rotation: 90\n        }\n      },\n      defaultBottomAxisOptions: {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      },\n      defaultTopAxisOptions: {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      },\n      init: function (a, b) {\n        var d = b.isX,\n            c = this;\n        c.chart = a;\n        c.horiz = a.inverted && !c.isZAxis ? !d : d;\n        c.isXAxis = d;\n        c.coll = c.coll || (d ? \"xAxis\" : \"yAxis\");\n        m(this, \"init\", {\n          userOptions: b\n        });\n        c.opposite = b.opposite;\n        c.side = b.side || (c.horiz ? c.opposite ? 0 : 2 : c.opposite ? 1 : 3);\n        c.setOptions(b);\n        var n = this.options,\n            f = n.type;\n        c.labelFormatter = n.labels.formatter || c.defaultLabelFormatter;\n        c.userOptions = b;\n        c.minPixelPadding = 0;\n        c.reversed = n.reversed;\n        c.visible = !1 !== n.visible;\n        c.zoomEnabled = !1 !== n.zoomEnabled;\n        c.hasNames = \"category\" === f || !0 === n.categories;\n        c.categories = n.categories || c.hasNames;\n        c.names || (c.names = [], c.names.keys = {});\n        c.plotLinesAndBandsGroups = {};\n        c.isLog = \"logarithmic\" === f;\n        c.isDatetimeAxis = \"datetime\" === f;\n        c.positiveValuesOnly = c.isLog && !c.allowNegativeLog;\n        c.isLinked = r(n.linkedTo);\n        c.ticks = {};\n        c.labelEdge = [];\n        c.minorTicks = {};\n        c.plotLinesAndBands = [];\n        c.alternateBands = {};\n        c.len = 0;\n        c.minRange = c.userMinRange = n.minRange || n.maxZoom;\n        c.range = n.range;\n        c.offset = n.offset || 0;\n        c.stacks = {};\n        c.oldStacks = {};\n        c.stacksTouched = 0;\n        c.max = null;\n        c.min = null;\n        c.crosshair = w(n.crosshair, I(a.options.tooltip.crosshairs)[d ? 0 : 1], !1);\n        b = c.options.events;\n        -1 === a.axes.indexOf(c) && (d ? a.axes.splice(a.xAxis.length, 0, c) : a.axes.push(c), a[c.coll].push(c));\n        c.series = c.series || [];\n        a.inverted && !c.isZAxis && d && \"undefined\" === typeof c.reversed && (c.reversed = !0);\n        t(b, function (b, a) {\n          l(b) && L(c, a, b);\n        });\n        c.lin2log = n.linearToLogConverter || c.lin2log;\n        c.isLog && (c.val2lin = c.log2lin, c.lin2val = c.lin2log);\n        m(this, \"afterInit\");\n      },\n      setOptions: function (d) {\n        this.options = a(this.defaultOptions, \"yAxis\" === this.coll && this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], a(O[this.coll], d));\n        m(this, \"afterSetOptions\", {\n          userOptions: d\n        });\n      },\n      defaultLabelFormatter: function () {\n        var a = this.axis,\n            b = this.value,\n            d = a.chart.time,\n            c = a.categories,\n            f = this.dateTimeLabelFormat,\n            k = O.lang,\n            t = k.numericSymbols;\n        k = k.numericSymbolMagnitude || 1E3;\n        var l = t && t.length,\n            q = a.options.labels.format;\n        a = a.isLog ? Math.abs(b) : a.tickInterval;\n        var h = this.chart,\n            e = h.numberFormatter;\n        if (q) var y = H(q, this, h);else if (c) y = b;else if (f) y = d.dateFormat(f, b);else if (l && 1E3 <= a) for (; l-- && \"undefined\" === typeof y;) d = Math.pow(k, l + 1), a >= d && 0 === 10 * b % d && null !== t[l] && 0 !== b && (y = e(b / d, -1) + t[l]);\n        \"undefined\" === typeof y && (y = 1E4 <= Math.abs(b) ? e(b, -1) : e(b, -1, void 0, \"\"));\n        return y;\n      },\n      getSeriesExtremes: function () {\n        var a = this,\n            b = a.chart,\n            d;\n        m(this, \"getSeriesExtremes\", null, function () {\n          a.hasVisibleSeries = !1;\n          a.dataMin = a.dataMax = a.threshold = null;\n          a.softThreshold = !a.isXAxis;\n          a.buildStacks && a.buildStacks();\n          a.series.forEach(function (c) {\n            if (c.visible || !b.options.chart.ignoreHiddenSeries) {\n              var n = c.options,\n                  f = n.threshold;\n              a.hasVisibleSeries = !0;\n              a.positiveValuesOnly && 0 >= f && (f = null);\n\n              if (a.isXAxis) {\n                if (n = c.xData, n.length) {\n                  d = c.getXExtremes(n);\n                  var x = d.min;\n                  var k = d.max;\n                  h(x) || x instanceof Date || (n = n.filter(h), d = c.getXExtremes(n), x = d.min, k = d.max);\n                  n.length && (a.dataMin = Math.min(w(a.dataMin, x), x), a.dataMax = Math.max(w(a.dataMax, k), k));\n                }\n              } else if (c.getExtremes(), k = c.dataMax, x = c.dataMin, r(x) && r(k) && (a.dataMin = Math.min(w(a.dataMin, x), x), a.dataMax = Math.max(w(a.dataMax, k), k)), r(f) && (a.threshold = f), !n.softThreshold || a.positiveValuesOnly) a.softThreshold = !1;\n            }\n          });\n        });\n        m(this, \"afterGetSeriesExtremes\");\n      },\n      translate: function (a, b, d, c, f, k) {\n        var n = this.linkedParent || this,\n            x = 1,\n            B = 0,\n            t = c ? n.oldTransA : n.transA;\n        c = c ? n.oldMin : n.min;\n        var l = n.minPixelPadding;\n        f = (n.isOrdinal || n.isBroken || n.isLog && f) && n.lin2val;\n        t || (t = n.transA);\n        d && (x *= -1, B = n.len);\n        n.reversed && (x *= -1, B -= x * (n.sector || n.len));\n        b ? (a = (a * x + B - l) / t + c, f && (a = n.lin2val(a))) : (f && (a = n.val2lin(a)), a = h(c) ? x * (a - c) * t + B + x * l + (h(k) ? t * k : 0) : void 0);\n        return a;\n      },\n      toPixels: function (a, b) {\n        return this.translate(a, !1, !this.horiz, null, !0) + (b ? 0 : this.pos);\n      },\n      toValue: function (a, b) {\n        return this.translate(a - (b ? 0 : this.pos), !0, !this.horiz, null, !0);\n      },\n      getPlotLinePath: function (a) {\n        var b = this,\n            d = b.chart,\n            c = b.left,\n            n = b.top,\n            f = a.old,\n            k = a.value,\n            t = a.translatedValue,\n            q = a.lineWidth,\n            l = a.force,\n            e,\n            y,\n            G,\n            g,\n            F = f && d.oldChartHeight || d.chartHeight,\n            r = f && d.oldChartWidth || d.chartWidth,\n            I,\n            N = b.transB,\n            D = function (b, a, d) {\n          if (\"pass\" !== l && b < a || b > d) l ? b = J(b, a, d) : I = !0;\n          return b;\n        };\n\n        a = {\n          value: k,\n          lineWidth: q,\n          old: f,\n          force: l,\n          acrossPanes: a.acrossPanes,\n          translatedValue: t\n        };\n        m(this, \"getPlotLinePath\", a, function (a) {\n          t = w(t, b.translate(k, null, null, f));\n          t = J(t, -1E5, 1E5);\n          e = G = Math.round(t + N);\n          y = g = Math.round(F - t - N);\n          h(t) ? b.horiz ? (y = n, g = F - b.bottom, e = G = D(e, c, c + b.width)) : (e = c, G = r - b.right, y = g = D(y, n, n + b.height)) : (I = !0, l = !1);\n          a.path = I && !l ? null : d.renderer.crispLine([\"M\", e, y, \"L\", G, g], q || 1);\n        });\n        return a.path;\n      },\n      getLinearTickPositions: function (a, b, d) {\n        var c = z(Math.floor(b / a) * a);\n        d = z(Math.ceil(d / a) * a);\n        var n = [],\n            f;\n        z(c + a) === c && (f = 20);\n        if (this.single) return [b];\n\n        for (b = c; b <= d;) {\n          n.push(b);\n          b = z(b + a, f);\n          if (b === k) break;\n          var k = b;\n        }\n\n        return n;\n      },\n      getMinorTickInterval: function () {\n        var a = this.options;\n        return !0 === a.minorTicks ? w(a.minorTickInterval, \"auto\") : !1 === a.minorTicks ? null : a.minorTickInterval;\n      },\n      getMinorTickPositions: function () {\n        var a = this,\n            b = a.options,\n            d = a.tickPositions,\n            c = a.minorTickInterval,\n            f = [],\n            k = a.pointRangePadding || 0,\n            t = a.min - k;\n        k = a.max + k;\n        var l = k - t;\n        if (l && l / c < a.len / 3) if (a.isLog) this.paddedTicks.forEach(function (b, d, n) {\n          d && f.push.apply(f, a.getLogTickPositions(c, n[d - 1], n[d], !0));\n        });else if (a.isDatetimeAxis && \"auto\" === this.getMinorTickInterval()) f = f.concat(a.getTimeTicks(a.normalizeTimeTickInterval(c), t, k, b.startOfWeek));else for (b = t + (d[0] - t) % c; b <= k && b !== f[0]; b += c) f.push(b);\n        0 !== f.length && a.trimTicks(f);\n        return f;\n      },\n      adjustForMinRange: function () {\n        var a = this.options,\n            b = this.min,\n            d = this.max,\n            c,\n            f,\n            k,\n            t,\n            l;\n        this.isXAxis && \"undefined\" === typeof this.minRange && !this.isLog && (r(a.min) || r(a.max) ? this.minRange = null : (this.series.forEach(function (b) {\n          t = b.xData;\n\n          for (f = l = b.xIncrement ? 1 : t.length - 1; 0 < f; f--) if (k = t[f] - t[f - 1], \"undefined\" === typeof c || k < c) c = k;\n        }), this.minRange = Math.min(5 * c, this.dataMax - this.dataMin)));\n\n        if (d - b < this.minRange) {\n          var q = this.dataMax - this.dataMin >= this.minRange;\n          var h = this.minRange;\n          var e = (h - d + b) / 2;\n          e = [b - e, w(a.min, b - e)];\n          q && (e[2] = this.isLog ? this.log2lin(this.dataMin) : this.dataMin);\n          b = A(e);\n          d = [b + h, w(a.max, b + h)];\n          q && (d[2] = this.isLog ? this.log2lin(this.dataMax) : this.dataMax);\n          d = C(d);\n          d - b < h && (e[0] = d - h, e[1] = w(a.min, d - h), b = A(e));\n        }\n\n        this.min = b;\n        this.max = d;\n      },\n      getClosest: function () {\n        var a;\n        this.categories ? a = 1 : this.series.forEach(function (b) {\n          var d = b.closestPointRange,\n              c = b.visible || !b.chart.options.chart.ignoreHiddenSeries;\n          !b.noSharedTooltip && r(d) && c && (a = r(a) ? Math.min(a, d) : d);\n        });\n        return a;\n      },\n      nameToX: function (a) {\n        var b = c(this.categories),\n            d = b ? this.categories : this.names,\n            f = a.options.x;\n        a.series.requireSorting = !1;\n        r(f) || (f = !1 === this.options.uniqueNames ? a.series.autoIncrement() : b ? d.indexOf(a.name) : w(d.keys[a.name], -1));\n\n        if (-1 === f) {\n          if (!b) var n = d.length;\n        } else n = f;\n\n        \"undefined\" !== typeof n && (this.names[n] = a.name, this.names.keys[a.name] = n);\n        return n;\n      },\n      updateNames: function () {\n        var a = this,\n            b = this.names;\n        0 < b.length && (Object.keys(b.keys).forEach(function (a) {\n          delete b.keys[a];\n        }), b.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (b) {\n          b.xIncrement = null;\n          if (!b.points || b.isDirtyData) a.max = Math.max(a.max, b.xData.length - 1), b.processData(), b.generatePoints();\n          b.data.forEach(function (d, c) {\n            if (d && d.options && \"undefined\" !== typeof d.name) {\n              var f = a.nameToX(d);\n              \"undefined\" !== typeof f && f !== d.x && (d.x = f, b.xData[c] = f);\n            }\n          });\n        }));\n      },\n      setAxisTranslation: function (a) {\n        var b = this,\n            c = b.max - b.min,\n            f = b.axisPointRange || 0,\n            n = 0,\n            k = 0,\n            t = b.linkedParent,\n            l = !!b.categories,\n            q = b.transA,\n            h = b.isXAxis;\n\n        if (h || l || f) {\n          var e = b.getClosest();\n          t ? (n = t.minPointOffset, k = t.pointRangePadding) : b.series.forEach(function (a) {\n            var c = l ? 1 : h ? w(a.options.pointRange, e, 0) : b.axisPointRange || 0,\n                x = a.options.pointPlacement;\n            f = Math.max(f, c);\n            if (!b.single || l) a = a.is(\"xrange\") ? !h : h, n = Math.max(n, a && d(x) ? 0 : c / 2), k = Math.max(k, a && \"on\" === x ? 0 : c);\n          });\n          t = b.ordinalSlope && e ? b.ordinalSlope / e : 1;\n          b.minPointOffset = n *= t;\n          b.pointRangePadding = k *= t;\n          b.pointRange = Math.min(f, b.single && l ? 1 : c);\n          h && (b.closestPointRange = e);\n        }\n\n        a && (b.oldTransA = q);\n        b.translationSlope = b.transA = q = b.staticScale || b.len / (c + k || 1);\n        b.transB = b.horiz ? b.left : b.bottom;\n        b.minPixelPadding = q * n;\n        m(this, \"afterSetAxisTranslation\");\n      },\n      minFromRange: function () {\n        return this.max - this.range;\n      },\n      setTickInterval: function (a) {\n        var b = this,\n            d = b.chart,\n            c = b.options,\n            n = b.isLog,\n            t = b.isDatetimeAxis,\n            l = b.isXAxis,\n            e = b.isLinked,\n            q = c.maxPadding,\n            y = c.minPadding,\n            g = c.tickInterval,\n            F = c.tickPixelInterval,\n            G = b.categories,\n            V = h(b.threshold) ? b.threshold : null,\n            I = b.softThreshold;\n        t || G || e || this.getTickAmount();\n        var N = w(b.userMin, c.min);\n        var D = w(b.userMax, c.max);\n\n        if (e) {\n          b.linkedParent = d[b.coll][c.linkedTo];\n          var v = b.linkedParent.getExtremes();\n          b.min = w(v.min, v.dataMin);\n          b.max = w(v.max, v.dataMax);\n          c.type !== b.linkedParent.options.type && M(11, 1, d);\n        } else {\n          if (!I && r(V)) if (b.dataMin >= V) v = V, y = 0;else if (b.dataMax <= V) {\n            var O = V;\n            q = 0;\n          }\n          b.min = w(N, v, b.dataMin);\n          b.max = w(D, O, b.dataMax);\n        }\n\n        n && (b.positiveValuesOnly && !a && 0 >= Math.min(b.min, w(b.dataMin, b.min)) && M(10, 1, d), b.min = z(b.log2lin(b.min), 16), b.max = z(b.log2lin(b.max), 16));\n        b.range && r(b.max) && (b.userMin = b.min = N = Math.max(b.dataMin, b.minFromRange()), b.userMax = D = b.max, b.range = null);\n        m(b, \"foundExtremes\");\n        b.beforePadding && b.beforePadding();\n        b.adjustForMinRange();\n        !(G || b.axisPointRange || b.usePercentage || e) && r(b.min) && r(b.max) && (d = b.max - b.min) && (!r(N) && y && (b.min -= d * y), !r(D) && q && (b.max += d * q));\n        h(b.userMin) || (h(c.softMin) && c.softMin < b.min && (b.min = N = c.softMin), h(c.floor) && (b.min = Math.max(b.min, c.floor)));\n        h(b.userMax) || (h(c.softMax) && c.softMax > b.max && (b.max = D = c.softMax), h(c.ceiling) && (b.max = Math.min(b.max, c.ceiling)));\n        I && r(b.dataMin) && (V = V || 0, !r(N) && b.min < V && b.dataMin >= V ? b.min = b.options.minRange ? Math.min(V, b.max - b.minRange) : V : !r(D) && b.max > V && b.dataMax <= V && (b.max = b.options.minRange ? Math.max(V, b.min + b.minRange) : V));\n        b.tickInterval = b.min === b.max || \"undefined\" === typeof b.min || \"undefined\" === typeof b.max ? 1 : e && !g && F === b.linkedParent.options.tickPixelInterval ? g = b.linkedParent.tickInterval : w(g, this.tickAmount ? (b.max - b.min) / Math.max(this.tickAmount - 1, 1) : void 0, G ? 1 : (b.max - b.min) * F / Math.max(b.len, F));\n        l && !a && b.series.forEach(function (a) {\n          a.processData(b.min !== b.oldMin || b.max !== b.oldMax);\n        });\n        b.setAxisTranslation(!0);\n        b.beforeSetTickPositions && b.beforeSetTickPositions();\n        b.postProcessTickInterval && (b.tickInterval = b.postProcessTickInterval(b.tickInterval));\n        b.pointRange && !g && (b.tickInterval = Math.max(b.pointRange, b.tickInterval));\n        a = w(c.minTickInterval, b.isDatetimeAxis && b.closestPointRange);\n        !g && b.tickInterval < a && (b.tickInterval = a);\n        t || n || g || (b.tickInterval = k(b.tickInterval, null, f(b.tickInterval), w(c.allowDecimals, !(.5 < b.tickInterval && 5 > b.tickInterval && 1E3 < b.max && 9999 > b.max)), !!this.tickAmount));\n        this.tickAmount || (b.tickInterval = b.unsquish());\n        this.setTickPositions();\n      },\n      setTickPositions: function () {\n        var a = this.options,\n            b = a.tickPositions;\n        var d = this.getMinorTickInterval();\n        var c = a.tickPositioner,\n            f = a.startOnTick,\n            k = a.endOnTick;\n        this.tickmarkOffset = this.categories && \"between\" === a.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;\n        this.minorTickInterval = \"auto\" === d && this.tickInterval ? this.tickInterval / 5 : d;\n        this.single = this.min === this.max && r(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== a.allowDecimals);\n        this.tickPositions = d = b && b.slice();\n        !d && (!this.ordinalPositions && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200) ? (d = [this.min, this.max], M(19, !1, this.chart)) : d = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, a.units), this.min, this.max, a.startOfWeek, this.ordinalPositions, this.closestPointRange, !0) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), d.length > this.len && (d = [d[0], d.pop()], d[0] === d[1] && (d.length = 1)), this.tickPositions = d, c && (c = c.apply(this, [this.min, this.max]))) && (this.tickPositions = d = c);\n        this.paddedTicks = d.slice(0);\n        this.trimTicks(d, f, k);\n        this.isLinked || (this.single && 2 > d.length && !this.categories && !this.series.some(function (b) {\n          return b.is(\"heatmap\") && \"between\" === b.options.pointPlacement;\n        }) && (this.min -= .5, this.max += .5), b || c || this.adjustTickAmount());\n        m(this, \"afterSetTickPositions\");\n      },\n      trimTicks: function (a, b, d) {\n        var c = a[0],\n            f = a[a.length - 1],\n            n = !this.isOrdinal && this.minPointOffset || 0;\n        m(this, \"trimTicks\");\n\n        if (!this.isLinked) {\n          if (b && -Infinity !== c) this.min = c;else for (; this.min - n > a[0];) a.shift();\n          if (d) this.max = f;else for (; this.max + n < a[a.length - 1];) a.pop();\n          0 === a.length && r(c) && !this.options.tickPositions && a.push((f + c) / 2);\n        }\n      },\n      alignToOthers: function () {\n        var a = {},\n            b,\n            d = this.options;\n        !1 === this.chart.options.chart.alignTicks || !1 === d.alignTicks || !1 === d.startOnTick || !1 === d.endOnTick || this.isLog || this.chart[this.coll].forEach(function (d) {\n          var c = d.options;\n          c = [d.horiz ? c.left : c.top, c.width, c.height, c.pane].join();\n          d.series.length && (a[c] ? b = !0 : a[c] = 1);\n        });\n        return b;\n      },\n      getTickAmount: function () {\n        var a = this.options,\n            b = a.tickAmount,\n            d = a.tickPixelInterval;\n        !r(a.tickInterval) && this.len < d && !this.isRadial && !this.isLog && a.startOnTick && a.endOnTick && (b = 2);\n        !b && this.alignToOthers() && (b = Math.ceil(this.len / d) + 1);\n        4 > b && (this.finalTickAmt = b, b = 5);\n        this.tickAmount = b;\n      },\n      adjustTickAmount: function () {\n        var a = this.options,\n            b = this.tickInterval,\n            d = this.tickPositions,\n            c = this.tickAmount,\n            f = this.finalTickAmt,\n            k = d && d.length,\n            t = w(this.threshold, this.softThreshold ? 0 : null),\n            l;\n\n        if (this.hasData()) {\n          if (k < c) {\n            for (l = this.min; d.length < c;) d.length % 2 || l === t ? d.push(z(d[d.length - 1] + b)) : d.unshift(z(d[0] - b));\n\n            this.transA *= (k - 1) / (c - 1);\n            this.min = a.startOnTick ? d[0] : Math.min(this.min, d[0]);\n            this.max = a.endOnTick ? d[d.length - 1] : Math.max(this.max, d[d.length - 1]);\n          } else k > c && (this.tickInterval *= 2, this.setTickPositions());\n\n          if (r(f)) {\n            for (b = a = d.length; b--;) (3 === f && 1 === b % 2 || 2 >= f && 0 < b && b < a - 1) && d.splice(b, 1);\n\n            this.finalTickAmt = void 0;\n          }\n        }\n      },\n      setScale: function () {\n        var a = this.series.some(function (b) {\n          return b.isDirtyData || b.isDirty || b.xAxis && b.xAxis.isDirty;\n        }),\n            b;\n        this.oldMin = this.min;\n        this.oldMax = this.max;\n        this.oldAxisLength = this.len;\n        this.setAxisSize();\n        (b = this.len !== this.oldAxisLength) || a || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.resetStacks && this.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = b || this.min !== this.oldMin || this.max !== this.oldMax)) : this.cleanStacks && this.cleanStacks();\n        m(this, \"afterSetScale\");\n      },\n      setExtremes: function (a, b, d, c, f) {\n        var n = this,\n            k = n.chart;\n        d = w(d, !0);\n        n.series.forEach(function (b) {\n          delete b.kdTree;\n        });\n        f = v(f, {\n          min: a,\n          max: b\n        });\n        m(n, \"setExtremes\", f, function () {\n          n.userMin = a;\n          n.userMax = b;\n          n.eventArgs = f;\n          d && k.redraw(c);\n        });\n      },\n      zoom: function (a, b) {\n        var d = this.dataMin,\n            c = this.dataMax,\n            f = this.options,\n            n = Math.min(d, w(f.min, d)),\n            k = Math.max(c, w(f.max, c));\n        a = {\n          newMin: a,\n          newMax: b\n        };\n        m(this, \"zoom\", a, function (b) {\n          var a = b.newMin,\n              f = b.newMax;\n          if (a !== this.min || f !== this.max) this.allowZoomOutside || (r(d) && (a < n && (a = n), a > k && (a = k)), r(c) && (f < n && (f = n), f > k && (f = k))), this.displayBtn = \"undefined\" !== typeof a || \"undefined\" !== typeof f, this.setExtremes(a, f, !1, void 0, {\n            trigger: \"zoom\"\n          });\n          b.zoomed = !0;\n        });\n        return a.zoomed;\n      },\n      setAxisSize: function () {\n        var a = this.chart,\n            b = this.options,\n            d = b.offsets || [0, 0, 0, 0],\n            c = this.horiz,\n            f = this.width = Math.round(y(w(b.width, a.plotWidth - d[3] + d[1]), a.plotWidth)),\n            k = this.height = Math.round(y(w(b.height, a.plotHeight - d[0] + d[2]), a.plotHeight)),\n            t = this.top = Math.round(y(w(b.top, a.plotTop + d[0]), a.plotHeight, a.plotTop));\n        b = this.left = Math.round(y(w(b.left, a.plotLeft + d[3]), a.plotWidth, a.plotLeft));\n        this.bottom = a.chartHeight - k - t;\n        this.right = a.chartWidth - f - b;\n        this.len = Math.max(c ? f : k, 0);\n        this.pos = c ? b : t;\n      },\n      getExtremes: function () {\n        var a = this.isLog;\n        return {\n          min: a ? z(this.lin2log(this.min)) : this.min,\n          max: a ? z(this.lin2log(this.max)) : this.max,\n          dataMin: this.dataMin,\n          dataMax: this.dataMax,\n          userMin: this.userMin,\n          userMax: this.userMax\n        };\n      },\n      getThreshold: function (a) {\n        var b = this.isLog,\n            d = b ? this.lin2log(this.min) : this.min;\n        b = b ? this.lin2log(this.max) : this.max;\n        null === a || -Infinity === a ? a = d : Infinity === a ? a = b : d > a ? a = d : b < a && (a = b);\n        return this.translate(a, 0, 1, 0, 1);\n      },\n      autoLabelAlign: function (a) {\n        var b = (w(a, 0) - 90 * this.side + 720) % 360;\n        a = {\n          align: \"center\"\n        };\n        m(this, \"autoLabelAlign\", a, function (a) {\n          15 < b && 165 > b ? a.align = \"right\" : 195 < b && 345 > b && (a.align = \"left\");\n        });\n        return a.align;\n      },\n      tickSize: function (a) {\n        var b = this.options,\n            d = b[a + \"Length\"],\n            c = w(b[a + \"Width\"], \"tick\" === a && this.isXAxis && !this.categories ? 1 : 0);\n\n        if (c && d) {\n          \"inside\" === b[a + \"Position\"] && (d = -d);\n          var f = [d, c];\n        }\n\n        a = {\n          tickSize: f\n        };\n        m(this, \"afterTickSize\", a);\n        return a.tickSize;\n      },\n      labelMetrics: function () {\n        var a = this.tickPositions && this.tickPositions[0] || 0;\n        return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[a] && this.ticks[a].label);\n      },\n      unsquish: function () {\n        var a = this.options.labels,\n            b = this.horiz,\n            d = this.tickInterval,\n            c = d,\n            f = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / d),\n            k,\n            t = a.rotation,\n            l = this.labelMetrics(),\n            q,\n            h = Number.MAX_VALUE,\n            e,\n            y = this.max - this.min,\n            G = function (b) {\n          var a = b / (f || 1);\n          a = 1 < a ? Math.ceil(a) : 1;\n          a * d > y && Infinity !== b && Infinity !== f && y && (a = Math.ceil(y / d));\n          return z(a * d);\n        };\n\n        b ? (e = !a.staggerLines && !a.step && (r(t) ? [t] : f < w(a.autoRotationLimit, 80) && a.autoRotation)) && e.forEach(function (b) {\n          if (b === t || b && -90 <= b && 90 >= b) {\n            q = G(Math.abs(l.h / Math.sin(N * b)));\n            var a = q + Math.abs(b / 360);\n            a < h && (h = a, k = b, c = q);\n          }\n        }) : a.step || (c = G(l.h));\n        this.autoRotation = e;\n        this.labelRotation = w(k, t);\n        return c;\n      },\n      getSlotWidth: function (a) {\n        var b = this.chart,\n            d = this.horiz,\n            c = this.options.labels,\n            f = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n            k = b.margin[3];\n        return a && a.slotWidth || d && 2 > (c.step || 0) && !c.rotation && (this.staggerLines || 1) * this.len / f || !d && (c.style && parseInt(c.style.width, 10) || k && k - b.spacing[3] || .33 * b.chartWidth);\n      },\n      renderUnsquish: function () {\n        var a = this.chart,\n            b = a.renderer,\n            c = this.tickPositions,\n            f = this.ticks,\n            k = this.options.labels,\n            t = k && k.style || {},\n            l = this.horiz,\n            h = this.getSlotWidth(),\n            q = Math.max(1, Math.round(h - 2 * (k.padding || 5))),\n            e = {},\n            y = this.labelMetrics(),\n            w = k.style && k.style.textOverflow,\n            G = 0;\n        d(k.rotation) || (e.rotation = k.rotation || 0);\n        c.forEach(function (b) {\n          b = f[b];\n          b.movedLabel && b.replaceMovedLabel();\n          b && b.label && b.label.textPxLength > G && (G = b.label.textPxLength);\n        });\n        this.maxLabelLength = G;\n        if (this.autoRotation) G > q && G > y.h ? e.rotation = this.labelRotation : this.labelRotation = 0;else if (h) {\n          var m = q;\n\n          if (!w) {\n            var g = \"clip\";\n\n            for (q = c.length; !l && q--;) {\n              var F = c[q];\n              if (F = f[F].label) F.styles && \"ellipsis\" === F.styles.textOverflow ? F.css({\n                textOverflow: \"clip\"\n              }) : F.textPxLength > h && F.css({\n                width: h + \"px\"\n              }), F.getBBox().height > this.len / c.length - (y.h - y.f) && (F.specificTextOverflow = \"ellipsis\");\n            }\n          }\n        }\n        e.rotation && (m = G > .5 * a.chartHeight ? .33 * a.chartHeight : G, w || (g = \"ellipsis\"));\n        if (this.labelAlign = k.align || this.autoLabelAlign(this.labelRotation)) e.align = this.labelAlign;\n        c.forEach(function (b) {\n          var a = (b = f[b]) && b.label,\n              d = t.width,\n              c = {};\n          a && (a.attr(e), b.shortenLabel ? b.shortenLabel() : m && !d && \"nowrap\" !== t.whiteSpace && (m < a.textPxLength || \"SPAN\" === a.element.tagName) ? (c.width = m, w || (c.textOverflow = a.specificTextOverflow || g), a.css(c)) : a.styles && a.styles.width && !c.width && !d && a.css({\n            width: null\n          }), delete a.specificTextOverflow, b.rotation = e.rotation);\n        }, this);\n        this.tickRotCorr = b.rotCorr(y.b, this.labelRotation || 0, 0 !== this.side);\n      },\n      hasData: function () {\n        return this.series.some(function (a) {\n          return a.hasData();\n        }) || this.options.showEmpty && r(this.min) && r(this.max);\n      },\n      addTitle: function (d) {\n        var b = this.chart.renderer,\n            c = this.horiz,\n            f = this.opposite,\n            k = this.options.title,\n            n,\n            t = this.chart.styledMode;\n        this.axisTitle || ((n = k.textAlign) || (n = (c ? {\n          low: \"left\",\n          middle: \"center\",\n          high: \"right\"\n        } : {\n          low: f ? \"right\" : \"left\",\n          middle: \"center\",\n          high: f ? \"left\" : \"right\"\n        })[k.align]), this.axisTitle = b.text(k.text, 0, 0, k.useHTML).attr({\n          zIndex: 7,\n          rotation: k.rotation || 0,\n          align: n\n        }).addClass(\"highcharts-axis-title\"), t || this.axisTitle.css(a(k.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);\n        t || k.style.width || this.isRadial || this.axisTitle.css({\n          width: this.len\n        });\n        this.axisTitle[d ? \"show\" : \"hide\"](d);\n      },\n      generateTick: function (a) {\n        var b = this.ticks;\n        b[a] ? b[a].addLabel() : b[a] = new p(this, a);\n      },\n      getOffset: function () {\n        var a = this,\n            b = a.chart,\n            d = b.renderer,\n            c = a.options,\n            f = a.tickPositions,\n            k = a.ticks,\n            l = a.horiz,\n            h = a.side,\n            q = b.inverted && !a.isZAxis ? [1, 0, 3, 2][h] : h,\n            e,\n            y = 0,\n            g = 0,\n            G = c.title,\n            F = c.labels,\n            I = 0,\n            N = b.axisOffset;\n        b = b.clipOffset;\n        var D = [-1, 1, 1, -1][h],\n            v = c.className,\n            O = a.axisParent;\n        var S = a.hasData();\n        a.showAxis = e = S || w(c.showEmpty, !0);\n        a.staggerLines = a.horiz && F.staggerLines;\n        a.axisGroup || (a.gridGroup = d.g(\"grid\").attr({\n          zIndex: c.gridZIndex || 1\n        }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \"-grid \" + (v || \"\")).add(O), a.axisGroup = d.g(\"axis\").attr({\n          zIndex: c.zIndex || 2\n        }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \" \" + (v || \"\")).add(O), a.labelGroup = d.g(\"axis-labels\").attr({\n          zIndex: F.zIndex || 7\n        }).addClass(\"highcharts-\" + a.coll.toLowerCase() + \"-labels \" + (v || \"\")).add(O));\n        S || a.isLinked ? (f.forEach(function (b, d) {\n          a.generateTick(b, d);\n        }), a.renderUnsquish(), a.reserveSpaceDefault = 0 === h || 2 === h || {\n          1: \"left\",\n          3: \"right\"\n        }[h] === a.labelAlign, w(F.reserveSpace, \"center\" === a.labelAlign ? !0 : null, a.reserveSpaceDefault) && f.forEach(function (b) {\n          I = Math.max(k[b].getLabelSize(), I);\n        }), a.staggerLines && (I *= a.staggerLines), a.labelOffset = I * (a.opposite ? -1 : 1)) : t(k, function (b, a) {\n          b.destroy();\n          delete k[a];\n        });\n\n        if (G && G.text && !1 !== G.enabled && (a.addTitle(e), e && !1 !== G.reserveSpace)) {\n          a.titleOffset = y = a.axisTitle.getBBox()[l ? \"height\" : \"width\"];\n          var z = G.offset;\n          g = r(z) ? 0 : w(G.margin, l ? 5 : 10);\n        }\n\n        a.renderLine();\n        a.offset = D * w(c.offset, N[h] ? N[h] + (c.margin || 0) : 0);\n        a.tickRotCorr = a.tickRotCorr || {\n          x: 0,\n          y: 0\n        };\n        d = 0 === h ? -a.labelMetrics().h : 2 === h ? a.tickRotCorr.y : 0;\n        g = Math.abs(I) + g;\n        I && (g = g - d + D * (l ? w(F.y, a.tickRotCorr.y + 8 * D) : F.x));\n        a.axisTitleMargin = w(z, g);\n        a.getMaxLabelDimensions && (a.maxLabelDimensions = a.getMaxLabelDimensions(k, f));\n        l = this.tickSize(\"tick\");\n        N[h] = Math.max(N[h], a.axisTitleMargin + y + D * a.offset, g, f && f.length && l ? l[0] + D * a.offset : 0);\n        c = c.offset ? 0 : 2 * Math.floor(a.axisLine.strokeWidth() / 2);\n        b[q] = Math.max(b[q], c);\n        m(this, \"afterGetOffset\");\n      },\n      getLinePath: function (a) {\n        var b = this.chart,\n            d = this.opposite,\n            c = this.offset,\n            f = this.horiz,\n            k = this.left + (d ? this.width : 0) + c;\n        c = b.chartHeight - this.bottom - (d ? this.height : 0) + c;\n        d && (a *= -1);\n        return b.renderer.crispLine([\"M\", f ? this.left : k, f ? c : this.top, \"L\", f ? b.chartWidth - this.right : k, f ? c : b.chartHeight - this.bottom], a);\n      },\n      renderLine: function () {\n        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({\n          stroke: this.options.lineColor,\n          \"stroke-width\": this.options.lineWidth,\n          zIndex: 7\n        }));\n      },\n      getTitlePosition: function () {\n        var a = this.horiz,\n            b = this.left,\n            d = this.top,\n            c = this.len,\n            f = this.options.title,\n            k = a ? b : d,\n            t = this.opposite,\n            l = this.offset,\n            h = f.x || 0,\n            e = f.y || 0,\n            y = this.axisTitle,\n            w = this.chart.renderer.fontMetrics(f.style && f.style.fontSize, y);\n        y = Math.max(y.getBBox(null, 0).height - w.h - 1, 0);\n        c = {\n          low: k + (a ? 0 : c),\n          middle: k + c / 2,\n          high: k + (a ? c : 0)\n        }[f.align];\n        b = (a ? d + this.height : b) + (a ? 1 : -1) * (t ? -1 : 1) * this.axisTitleMargin + [-y, y, w.f, -y][this.side];\n        a = {\n          x: a ? c + h : b + (t ? this.width : 0) + l + h,\n          y: a ? b + e - (t ? this.height : 0) + l : c + e\n        };\n        m(this, \"afterGetTitlePosition\", {\n          titlePosition: a\n        });\n        return a;\n      },\n      renderMinorTick: function (a) {\n        var b = this.chart.hasRendered && h(this.oldMin),\n            d = this.minorTicks;\n        d[a] || (d[a] = new p(this, a, \"minor\"));\n        b && d[a].isNew && d[a].render(null, !0);\n        d[a].render(null, !1, 1);\n      },\n      renderTick: function (a, b) {\n        var d = this.isLinked,\n            c = this.ticks,\n            f = this.chart.hasRendered && h(this.oldMin);\n        if (!d || a >= this.min && a <= this.max) c[a] || (c[a] = new p(this, a)), f && c[a].isNew && c[a].render(b, !0, -1), c[a].render(b);\n      },\n      render: function () {\n        var a = this,\n            b = a.chart,\n            d = a.options,\n            c = a.isLog,\n            f = a.isLinked,\n            k = a.tickPositions,\n            l = a.axisTitle,\n            y = a.ticks,\n            q = a.minorTicks,\n            w = a.alternateBands,\n            g = d.stackLabels,\n            F = d.alternateGridColor,\n            G = a.tickmarkOffset,\n            r = a.axisLine,\n            I = a.showAxis,\n            N = E(b.renderer.globalAnimation),\n            D,\n            v;\n        a.labelEdge.length = 0;\n        a.overlap = !1;\n        [y, q, w].forEach(function (b) {\n          t(b, function (b) {\n            b.isActive = !1;\n          });\n        });\n        if (a.hasData() || f) a.minorTickInterval && !a.categories && a.getMinorTickPositions().forEach(function (b) {\n          a.renderMinorTick(b);\n        }), k.length && (k.forEach(function (b, d) {\n          a.renderTick(b, d);\n        }), G && (0 === a.min || a.single) && (y[-1] || (y[-1] = new p(a, -1, null, !0)), y[-1].render(-1))), F && k.forEach(function (d, f) {\n          v = \"undefined\" !== typeof k[f + 1] ? k[f + 1] + G : a.max - G;\n          0 === f % 2 && d < a.max && v <= a.max + (b.polar ? -G : G) && (w[d] || (w[d] = new e.PlotLineOrBand(a)), D = d + G, w[d].options = {\n            from: c ? a.lin2log(D) : D,\n            to: c ? a.lin2log(v) : v,\n            color: F\n          }, w[d].render(), w[d].isActive = !0);\n        }), a._addedPlotLB || ((d.plotLines || []).concat(d.plotBands || []).forEach(function (b) {\n          a.addPlotBandOrLine(b);\n        }), a._addedPlotLB = !0);\n        [y, q, w].forEach(function (a) {\n          var d,\n              c = [],\n              f = N.duration;\n          t(a, function (b, a) {\n            b.isActive || (b.render(a, !1, 0), b.isActive = !1, c.push(a));\n          });\n          S(function () {\n            for (d = c.length; d--;) a[c[d]] && !a[c[d]].isActive && (a[c[d]].destroy(), delete a[c[d]]);\n          }, a !== w && b.hasRendered && f ? f : 0);\n        });\n        r && (r[r.isPlaced ? \"animate\" : \"attr\"]({\n          d: this.getLinePath(r.strokeWidth())\n        }), r.isPlaced = !0, r[I ? \"show\" : \"hide\"](I));\n        l && I && (d = a.getTitlePosition(), h(d.y) ? (l[l.isNew ? \"attr\" : \"animate\"](d), l.isNew = !1) : (l.attr(\"y\", -9999), l.isNew = !0));\n        g && g.enabled && a.renderStackTotals();\n        a.isDirty = !1;\n        m(this, \"afterRender\");\n      },\n      redraw: function () {\n        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (a) {\n          a.render();\n        }));\n        this.series.forEach(function (a) {\n          a.isDirty = !0;\n        });\n      },\n      keepProps: \"extKey hcEvents names series userMax userMin\".split(\" \"),\n      destroy: function (a) {\n        var b = this,\n            d = b.stacks,\n            c = b.plotLinesAndBands,\n            f;\n        m(this, \"destroy\", {\n          keepEvents: a\n        });\n        a || F(b);\n        t(d, function (b, a) {\n          D(b);\n          d[a] = null;\n        });\n        [b.ticks, b.minorTicks, b.alternateBands].forEach(function (b) {\n          D(b);\n        });\n        if (c) for (a = c.length; a--;) c[a].destroy();\n        \"stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar\".split(\" \").forEach(function (a) {\n          b[a] && (b[a] = b[a].destroy());\n        });\n\n        for (f in b.plotLinesAndBandsGroups) b.plotLinesAndBandsGroups[f] = b.plotLinesAndBandsGroups[f].destroy();\n\n        t(b, function (a, d) {\n          -1 === b.keepProps.indexOf(d) && delete b[d];\n        });\n      },\n      drawCrosshair: function (a, b) {\n        var d = this.crosshair,\n            c = w(d.snap, !0),\n            f,\n            k = this.cross,\n            t = this.chart;\n        m(this, \"drawCrosshair\", {\n          e: a,\n          point: b\n        });\n        a || (a = this.cross && this.cross.e);\n\n        if (this.crosshair && !1 !== (r(b) || !c)) {\n          c ? r(b) && (f = w(\"colorAxis\" !== this.coll ? b.crosshairPos : null, this.isXAxis ? b.plotX : this.len - b.plotY)) : f = a && (this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos);\n\n          if (r(f)) {\n            var l = {\n              value: b && (this.isXAxis ? b.x : w(b.stackY, b.y)),\n              translatedValue: f\n            };\n            t.polar && v(l, {\n              isCrosshair: !0,\n              chartX: a && a.chartX,\n              chartY: a && a.chartY,\n              point: b\n            });\n            l = this.getPlotLinePath(l) || null;\n          }\n\n          if (!r(l)) {\n            this.hideCrosshair();\n            return;\n          }\n\n          c = this.categories && !this.isRadial;\n          k || (this.cross = k = t.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (c ? \"category \" : \"thin \") + d.className).attr({\n            zIndex: w(d.zIndex, 2)\n          }).add(), t.styledMode || (k.attr({\n            stroke: d.color || (c ? K(\"#ccd6eb\").setOpacity(.25).get() : \"#cccccc\"),\n            \"stroke-width\": w(d.width, 1)\n          }).css({\n            \"pointer-events\": \"none\"\n          }), d.dashStyle && k.attr({\n            dashstyle: d.dashStyle\n          })));\n          k.show().attr({\n            d: l\n          });\n          c && !d.width && k.attr({\n            \"stroke-width\": this.transA\n          });\n          this.cross.e = a;\n        } else this.hideCrosshair();\n\n        m(this, \"afterDrawCrosshair\", {\n          e: a,\n          point: b\n        });\n      },\n      hideCrosshair: function () {\n        this.cross && this.cross.hide();\n        m(this, \"afterHideCrosshair\");\n      }\n    });\n    return e.Axis = g;\n  });\n  R(p, \"parts/DateTimeAxis.js\", [p[\"parts/Globals.js\"], p[\"parts/Utilities.js\"]], function (e, g) {\n    var p = g.getMagnitude,\n        u = g.normalizeTickInterval,\n        K = g.timeUnits;\n    e = e.Axis;\n\n    e.prototype.getTimeTicks = function () {\n      return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n    };\n\n    e.prototype.normalizeTimeTickInterval = function (e, g) {\n      var A = g || [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2]], [\"week\", [1, 2]], [\"month\", [1, 2, 3, 4, 6]], [\"year\", null]];\n      g = A[A.length - 1];\n      var C = K[g[0]],\n          E = g[1],\n          z;\n\n      for (z = 0; z < A.length && !(g = A[z], C = K[g[0]], E = g[1], A[z + 1] && e <= (C * E[E.length - 1] + K[A[z + 1][0]]) / 2); z++);\n\n      C === K.year && e < 5 * C && (E = [1, 2, 5]);\n      e = u(e / C, E, \"year\" === g[0] ? Math.max(p(e / C), 1) : 1);\n      return {\n        unitRange: C,\n        count: e,\n        unitName: g[0]\n      };\n    };\n  });\n  R(p, \"parts/LogarithmicAxis.js\", [p[\"parts/Globals.js\"], p[\"parts/Utilities.js\"]], function (e, g) {\n    var p = g.getMagnitude,\n        u = g.normalizeTickInterval,\n        K = g.pick;\n    e = e.Axis;\n\n    e.prototype.getLogTickPositions = function (e, g, A, C) {\n      var E = this.options,\n          z = this.len,\n          r = [];\n      C || (this._minorAutoInterval = null);\n      if (.5 <= e) e = Math.round(e), r = this.getLinearTickPositions(e, g, A);else if (.08 <= e) {\n        z = Math.floor(g);\n        var D, M;\n\n        for (E = .3 < e ? [1, 2, 4] : .15 < e ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; z < A + 1 && !M; z++) {\n          var v = E.length;\n\n          for (D = 0; D < v && !M; D++) {\n            var m = this.log2lin(this.lin2log(z) * E[D]);\n            m > g && (!C || H <= A) && \"undefined\" !== typeof H && r.push(H);\n            H > A && (M = !0);\n            var H = m;\n          }\n        }\n      } else g = this.lin2log(g), A = this.lin2log(A), e = C ? this.getMinorTickInterval() : E.tickInterval, e = K(\"auto\" === e ? null : e, this._minorAutoInterval, E.tickPixelInterval / (C ? 5 : 1) * (A - g) / ((C ? z / this.tickPositions.length : z) || 1)), e = u(e, null, p(e)), r = this.getLinearTickPositions(e, g, A).map(this.log2lin), C || (this._minorAutoInterval = e / 5);\n      C || (this.tickInterval = e);\n      return r;\n    };\n\n    e.prototype.log2lin = function (e) {\n      return Math.log(e) / Math.LN10;\n    };\n\n    e.prototype.lin2log = function (e) {\n      return Math.pow(10, e);\n    };\n  });\n  R(p, \"parts/PlotLineOrBand.js\", [p[\"parts/Globals.js\"], p[\"parts/Axis.js\"], p[\"parts/Utilities.js\"]], function (e, g, p) {\n    var u = p.arrayMax,\n        K = p.arrayMin,\n        L = p.defined,\n        E = p.destroyObjectProperties,\n        A = p.erase,\n        C = p.extend,\n        J = p.merge,\n        z = p.objectEach,\n        r = p.pick;\n\n    e.PlotLineOrBand = function (e, g) {\n      this.axis = e;\n      g && (this.options = g, this.id = g.id);\n    };\n\n    e.PlotLineOrBand.prototype = {\n      render: function () {\n        e.fireEvent(this, \"render\");\n        var g = this,\n            u = g.axis,\n            v = u.horiz,\n            m = g.options,\n            H = m.label,\n            f = g.label,\n            c = m.to,\n            l = m.from,\n            h = m.value,\n            d = L(l) && L(c),\n            a = L(h),\n            k = g.svgElem,\n            t = !k,\n            w = [],\n            y = m.color,\n            F = r(m.zIndex, 0),\n            I = m.events;\n        w = {\n          \"class\": \"highcharts-plot-\" + (d ? \"band \" : \"line \") + (m.className || \"\")\n        };\n        var S = {},\n            O = u.chart.renderer,\n            N = d ? \"bands\" : \"lines\";\n        u.isLog && (l = u.log2lin(l), c = u.log2lin(c), h = u.log2lin(h));\n        u.chart.styledMode || (a ? (w.stroke = y || \"#999999\", w[\"stroke-width\"] = r(m.width, 1), m.dashStyle && (w.dashstyle = m.dashStyle)) : d && (w.fill = y || \"#e6ebf5\", m.borderWidth && (w.stroke = m.borderColor, w[\"stroke-width\"] = m.borderWidth)));\n        S.zIndex = F;\n        N += \"-\" + F;\n        (y = u.plotLinesAndBandsGroups[N]) || (u.plotLinesAndBandsGroups[N] = y = O.g(\"plot-\" + N).attr(S).add());\n        t && (g.svgElem = k = O.path().attr(w).add(y));\n        if (a) w = u.getPlotLinePath({\n          value: h,\n          lineWidth: k.strokeWidth(),\n          acrossPanes: m.acrossPanes\n        });else if (d) w = u.getPlotBandPath(l, c, m);else return;\n        (t || !k.d) && w && w.length ? (k.attr({\n          d: w\n        }), I && z(I, function (a, b) {\n          k.on(b, function (a) {\n            I[b].apply(g, [a]);\n          });\n        })) : k && (w ? (k.show(!0), k.animate({\n          d: w\n        })) : k.d && (k.hide(), f && (g.label = f = f.destroy())));\n        H && (L(H.text) || L(H.formatter)) && w && w.length && 0 < u.width && 0 < u.height && !w.isFlat ? (H = J({\n          align: v && d && \"center\",\n          x: v ? !d && 4 : 10,\n          verticalAlign: !v && d && \"middle\",\n          y: v ? d ? 16 : 10 : d ? 6 : -4,\n          rotation: v && !d && 90\n        }, H), this.renderLabel(H, w, d, F)) : f && f.hide();\n        return g;\n      },\n      renderLabel: function (e, g, r, m) {\n        var v = this.label,\n            f = this.axis.chart.renderer;\n        v || (v = {\n          align: e.textAlign || e.align,\n          rotation: e.rotation,\n          \"class\": \"highcharts-plot-\" + (r ? \"band\" : \"line\") + \"-label \" + (e.className || \"\")\n        }, v.zIndex = m, m = this.getLabelText(e), this.label = v = f.text(m, 0, 0, e.useHTML).attr(v).add(), this.axis.chart.styledMode || v.css(e.style));\n        f = g.xBounds || [g[1], g[4], r ? g[6] : g[1]];\n        g = g.yBounds || [g[2], g[5], r ? g[7] : g[2]];\n        r = K(f);\n        m = K(g);\n        v.align(e, !1, {\n          x: r,\n          y: m,\n          width: u(f) - r,\n          height: u(g) - m\n        });\n        v.show(!0);\n      },\n      getLabelText: function (e) {\n        return L(e.formatter) ? e.formatter.call(this) : e.text;\n      },\n      destroy: function () {\n        A(this.axis.plotLinesAndBands, this);\n        delete this.axis;\n        E(this);\n      }\n    };\n    C(g.prototype, {\n      getPlotBandPath: function (e, g) {\n        var r = this.getPlotLinePath({\n          value: g,\n          force: !0,\n          acrossPanes: this.options.acrossPanes\n        }),\n            m = this.getPlotLinePath({\n          value: e,\n          force: !0,\n          acrossPanes: this.options.acrossPanes\n        }),\n            z = [],\n            f = this.horiz,\n            c = 1;\n        e = e < this.min && g < this.min || e > this.max && g > this.max;\n\n        if (m && r) {\n          if (e) {\n            var l = m.toString() === r.toString();\n            c = 0;\n          }\n\n          for (e = 0; e < m.length; e += 6) f && r[e + 1] === m[e + 1] ? (r[e + 1] += c, r[e + 4] += c) : f || r[e + 2] !== m[e + 2] || (r[e + 2] += c, r[e + 5] += c), z.push(\"M\", m[e + 1], m[e + 2], \"L\", m[e + 4], m[e + 5], r[e + 4], r[e + 5], r[e + 1], r[e + 2], \"z\"), z.isFlat = l;\n        }\n\n        return z;\n      },\n      addPlotBand: function (e) {\n        return this.addPlotBandOrLine(e, \"plotBands\");\n      },\n      addPlotLine: function (e) {\n        return this.addPlotBandOrLine(e, \"plotLines\");\n      },\n      addPlotBandOrLine: function (g, r) {\n        var v = new e.PlotLineOrBand(this, g).render(),\n            m = this.userOptions;\n\n        if (v) {\n          if (r) {\n            var z = m[r] || [];\n            z.push(g);\n            m[r] = z;\n          }\n\n          this.plotLinesAndBands.push(v);\n        }\n\n        return v;\n      },\n      removePlotBandOrLine: function (e) {\n        for (var g = this.plotLinesAndBands, r = this.options, m = this.userOptions, z = g.length; z--;) g[z].id === e && g[z].destroy();\n\n        [r.plotLines || [], m.plotLines || [], r.plotBands || [], m.plotBands || []].forEach(function (f) {\n          for (z = f.length; z--;) f[z].id === e && A(f, f[z]);\n        });\n      },\n      removePlotBand: function (e) {\n        this.removePlotBandOrLine(e);\n      },\n      removePlotLine: function (e) {\n        this.removePlotBandOrLine(e);\n      }\n    });\n  });\n  R(p, \"parts/Tooltip.js\", [p[\"parts/Globals.js\"], p[\"parts/Utilities.js\"]], function (e, g) {\n    var p = g.clamp,\n        u = g.css,\n        K = g.defined,\n        L = g.discardElement,\n        E = g.extend,\n        A = g.format,\n        C = g.isNumber,\n        J = g.isString,\n        z = g.merge,\n        r = g.pick,\n        D = g.splat,\n        M = g.syncTimeout,\n        v = g.timeUnits;\n    \"\";\n\n    var m = e.doc,\n        H = function () {\n      function f(c, f) {\n        this.chart = void 0;\n        this.crosshairs = [];\n        this.distance = 0;\n        this.isHidden = !0;\n        this.isSticky = !1;\n        this.now = {};\n        this.options = {};\n        this.outside = !1;\n        this.init(c, f);\n      }\n\n      f.prototype.applyFilter = function () {\n        var c = this.chart;\n        c.renderer.definition({\n          tagName: \"filter\",\n          id: \"drop-shadow-\" + c.index,\n          opacity: .5,\n          children: [{\n            tagName: \"feGaussianBlur\",\n            \"in\": \"SourceAlpha\",\n            stdDeviation: 1\n          }, {\n            tagName: \"feOffset\",\n            dx: 1,\n            dy: 1\n          }, {\n            tagName: \"feComponentTransfer\",\n            children: [{\n              tagName: \"feFuncA\",\n              type: \"linear\",\n              slope: .3\n            }]\n          }, {\n            tagName: \"feMerge\",\n            children: [{\n              tagName: \"feMergeNode\"\n            }, {\n              tagName: \"feMergeNode\",\n              \"in\": \"SourceGraphic\"\n            }]\n          }]\n        });\n        c.renderer.definition({\n          tagName: \"style\",\n          textContent: \".highcharts-tooltip-\" + c.index + \"{filter:url(#drop-shadow-\" + c.index + \")}\"\n        });\n      };\n\n      f.prototype.bodyFormatter = function (c) {\n        return c.map(function (c) {\n          var f = c.series.tooltipOptions;\n          return (f[(c.point.formatPrefix || \"point\") + \"Formatter\"] || c.point.tooltipFormatter).call(c.point, f[(c.point.formatPrefix || \"point\") + \"Format\"] || \"\");\n        });\n      };\n\n      f.prototype.cleanSplit = function (c) {\n        this.chart.series.forEach(function (f) {\n          var e = f && f.tt;\n          e && (!e.isActive || c ? f.tt = e.destroy() : e.isActive = !1);\n        });\n      };\n\n      f.prototype.defaultFormatter = function (c) {\n        var f = this.points || D(this);\n        var e = [c.tooltipFooterHeaderFormatter(f[0])];\n        e = e.concat(c.bodyFormatter(f));\n        e.push(c.tooltipFooterHeaderFormatter(f[0], !0));\n        return e;\n      };\n\n      f.prototype.destroy = function () {\n        this.label && (this.label = this.label.destroy());\n        this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());\n        this.renderer && (this.renderer = this.renderer.destroy(), L(this.container));\n        g.clearTimeout(this.hideTimer);\n        g.clearTimeout(this.tooltipTimeout);\n      };\n\n      f.prototype.getAnchor = function (c, f) {\n        var e = this.chart,\n            d = e.pointer,\n            a = e.inverted,\n            k = e.plotTop,\n            t = e.plotLeft,\n            l = 0,\n            y = 0,\n            g,\n            m;\n        c = D(c);\n        this.followPointer && f ? (\"undefined\" === typeof f.chartX && (f = d.normalize(f)), c = [f.chartX - e.plotLeft, f.chartY - k]) : c[0].tooltipPos ? c = c[0].tooltipPos : (c.forEach(function (d) {\n          g = d.series.yAxis;\n          m = d.series.xAxis;\n          l += d.plotX + (!a && m ? m.left - t : 0);\n          y += (d.plotLow ? (d.plotLow + d.plotHigh) / 2 : d.plotY) + (!a && g ? g.top - k : 0);\n        }), l /= c.length, y /= c.length, c = [a ? e.plotWidth - y : l, this.shared && !a && 1 < c.length && f ? f.chartY - k : a ? e.plotHeight - l : y]);\n        return c.map(Math.round);\n      };\n\n      f.prototype.getDateFormat = function (c, f, e, d) {\n        var a = this.chart.time,\n            k = a.dateFormat(\"%m-%d %H:%M:%S.%L\", f),\n            t = {\n          millisecond: 15,\n          second: 12,\n          minute: 9,\n          hour: 6,\n          day: 3\n        },\n            l = \"millisecond\";\n\n        for (h in v) {\n          if (c === v.week && +a.dateFormat(\"%w\", f) === e && \"00:00:00.000\" === k.substr(6)) {\n            var h = \"week\";\n            break;\n          }\n\n          if (v[h] > c) {\n            h = l;\n            break;\n          }\n\n          if (t[h] && k.substr(t[h]) !== \"01-01 00:00:00.000\".substr(t[h])) break;\n          \"week\" !== h && (l = h);\n        }\n\n        if (h) var g = a.resolveDTLFormat(d[h]).main;\n        return g;\n      };\n\n      f.prototype.getLabel = function () {\n        var c,\n            f = this,\n            h = this.chart.renderer,\n            d = this.chart.styledMode,\n            a = this.options,\n            k = \"tooltip\" + (K(a.className) ? \" \" + a.className : \"\"),\n            t;\n\n        if (!this.label) {\n          this.outside && (this.container = t = e.doc.createElement(\"div\"), t.className = \"highcharts-tooltip-container\", u(t, {\n            position: \"absolute\",\n            top: \"1px\",\n            pointerEvents: a.style && a.style.pointerEvents,\n            zIndex: 3\n          }), e.doc.body.appendChild(t), this.renderer = h = new e.Renderer(t, 0, 0, {}, void 0, void 0, h.styledMode));\n          this.split ? this.label = h.g(k) : (this.label = h.label(\"\", 0, 0, a.shape || \"callout\", null, null, a.useHTML, null, k).attr({\n            padding: a.padding,\n            r: a.borderRadius\n          }), d || this.label.attr({\n            fill: a.backgroundColor,\n            \"stroke-width\": a.borderWidth\n          }).css(a.style).shadow(a.shadow));\n          d && (this.applyFilter(), this.label.addClass(\"highcharts-tooltip-\" + this.chart.index));\n\n          if (f.outside && !f.split) {\n            var w = {\n              x: this.label.xSetter,\n              y: this.label.ySetter\n            };\n\n            this.label.xSetter = function (a, d) {\n              w[d].call(this.label, f.distance);\n              t.style.left = a + \"px\";\n            };\n\n            this.label.ySetter = function (a, d) {\n              w[d].call(this.label, f.distance);\n              t.style.top = a + \"px\";\n            };\n          }\n\n          this.label.attr({\n            zIndex: 8,\n            pointerEvents: (null === (c = a.style) || void 0 === c ? 0 : c.pointerEvents) || a.stickOnHover ? \"auto\" : \"none\"\n          }).add();\n        }\n\n        return this.label;\n      };\n\n      f.prototype.getPosition = function (c, f, e) {\n        var d = this.chart,\n            a = this.distance,\n            k = {},\n            t = d.inverted && e.h || 0,\n            l,\n            h = this.outside,\n            g = h ? m.documentElement.clientWidth - 2 * a : d.chartWidth,\n            I = h ? Math.max(m.body.scrollHeight, m.documentElement.scrollHeight, m.body.offsetHeight, m.documentElement.offsetHeight, m.documentElement.clientHeight) : d.chartHeight,\n            v = d.pointer.getChartPosition(),\n            O = d.containerScaling,\n            N = function (b) {\n          return O ? b * O.scaleX : b;\n        },\n            n = function (b) {\n          return O ? b * O.scaleY : b;\n        },\n            b = function (b) {\n          var k = \"x\" === b;\n          return [b, k ? g : I, k ? c : f].concat(h ? [k ? N(c) : n(f), k ? v.left - a + N(e.plotX + d.plotLeft) : v.top - a + n(e.plotY + d.plotTop), 0, k ? g : I] : [k ? c : f, k ? e.plotX + d.plotLeft : e.plotY + d.plotTop, k ? d.plotLeft : d.plotTop, k ? d.plotLeft + d.plotWidth : d.plotTop + d.plotHeight]);\n        },\n            B = b(\"y\"),\n            x = b(\"x\"),\n            z = !this.followPointer && r(e.ttBelow, !d.inverted === !!e.negative),\n            P = function (b, d, c, f, e, l, x) {\n          var q = \"y\" === b ? n(a) : N(a),\n              h = (c - f) / 2,\n              y = f < e - a,\n              g = e + a + f < d,\n              w = e - q - c + h;\n          e = e + q - h;\n          if (z && g) k[b] = e;else if (!z && y) k[b] = w;else if (y) k[b] = Math.min(x - f, 0 > w - t ? w : w - t);else if (g) k[b] = Math.max(l, e + t + c > d ? e : e + t);else return !1;\n        },\n            W = function (b, d, c, f, e) {\n          var t;\n          e < a || e > d - a ? t = !1 : k[b] = e < c / 2 ? 1 : e > d - f / 2 ? d - f - 2 : e - c / 2;\n          return t;\n        },\n            u = function (b) {\n          var a = B;\n          B = x;\n          x = a;\n          l = b;\n        },\n            q = function () {\n          !1 !== P.apply(0, B) ? !1 !== W.apply(0, x) || l || (u(!0), q()) : l ? k.x = k.y = 0 : (u(!0), q());\n        };\n\n        (d.inverted || 1 < this.len) && u();\n        q();\n        return k;\n      };\n\n      f.prototype.getXDateFormat = function (c, f, e) {\n        f = f.dateTimeLabelFormats;\n        var d = e && e.closestPointRange;\n        return (d ? this.getDateFormat(d, c.x, e.options.startOfWeek, f) : f.day) || f.year;\n      };\n\n      f.prototype.hide = function (c) {\n        var f = this;\n        g.clearTimeout(this.hideTimer);\n        c = r(c, this.options.hideDelay, 500);\n        this.isHidden || (this.hideTimer = M(function () {\n          f.getLabel()[c ? \"fadeOut\" : \"hide\"]();\n          f.isHidden = !0;\n        }, c));\n      };\n\n      f.prototype.init = function (c, f) {\n        this.chart = c;\n        this.options = f;\n        this.crosshairs = [];\n        this.now = {\n          x: 0,\n          y: 0\n        };\n        this.isHidden = !0;\n        this.split = f.split && !c.inverted && !c.polar;\n        this.shared = f.shared || this.split;\n        this.outside = r(f.outside, !(!c.scrollablePixelsX && !c.scrollablePixelsY));\n      };\n\n      f.prototype.move = function (c, f, e, d) {\n        var a = this,\n            k = a.now,\n            t = !1 !== a.options.animation && !a.isHidden && (1 < Math.abs(c - k.x) || 1 < Math.abs(f - k.y)),\n            h = a.followPointer || 1 < a.len;\n        E(k, {\n          x: t ? (2 * k.x + c) / 3 : c,\n          y: t ? (k.y + f) / 2 : f,\n          anchorX: h ? void 0 : t ? (2 * k.anchorX + e) / 3 : e,\n          anchorY: h ? void 0 : t ? (k.anchorY + d) / 2 : d\n        });\n        a.getLabel().attr(k);\n        t && (g.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {\n          a && a.move(c, f, e, d);\n        }, 32));\n      };\n\n      f.prototype.refresh = function (c, f) {\n        var h = this.chart,\n            d = this.options,\n            a = c,\n            k = {},\n            t = [],\n            l = d.formatter || this.defaultFormatter;\n        k = this.shared;\n        var y = h.styledMode;\n\n        if (d.enabled) {\n          g.clearTimeout(this.hideTimer);\n          this.followPointer = D(a)[0].series.tooltipOptions.followPointer;\n          var m = this.getAnchor(a, f);\n          f = m[0];\n          var I = m[1];\n          !k || a.series && a.series.noSharedTooltip ? k = a.getLabelConfig() : (h.pointer.applyInactiveState(a), a.forEach(function (a) {\n            a.setState(\"hover\");\n            t.push(a.getLabelConfig());\n          }), k = {\n            x: a[0].category,\n            y: a[0].y\n          }, k.points = t, a = a[0]);\n          this.len = t.length;\n          h = l.call(k, this);\n          l = a.series;\n          this.distance = r(l.tooltipOptions.distance, 16);\n          !1 === h ? this.hide() : (this.split ? this.renderSplit(h, D(c)) : (c = this.getLabel(), d.style.width && !y || c.css({\n            width: this.chart.spacingBox.width\n          }), c.attr({\n            text: h && h.join ? h.join(\"\") : h\n          }), c.removeClass(/highcharts-color-[\\d]+/g).addClass(\"highcharts-color-\" + r(a.colorIndex, l.colorIndex)), y || c.attr({\n            stroke: d.borderColor || a.color || l.color || \"#666666\"\n          }), this.updatePosition({\n            plotX: f,\n            plotY: I,\n            negative: a.negative,\n            ttBelow: a.ttBelow,\n            h: m[2] || 0\n          })), this.isHidden && this.label && this.label.attr({\n            opacity: 1\n          }).show(), this.isHidden = !1);\n          e.fireEvent(this, \"refresh\");\n        }\n      };\n\n      f.prototype.renderSplit = function (c, f) {\n        function h(b, a, d, c, f) {\n          void 0 === f && (f = !0);\n          d ? (a = u ? 0 : H, b = p(b - c / 2, P.left, P.right - c)) : (a -= q, b = f ? b - c - B : b + B, b = p(b, f ? b : P.left, P.right));\n          return {\n            x: b,\n            y: a\n          };\n        }\n\n        var d = this,\n            a = d.chart,\n            k = d.chart,\n            t = k.plotHeight,\n            l = k.plotLeft,\n            y = k.plotTop,\n            g = k.pointer,\n            m = k.renderer,\n            v = k.scrollablePixelsY,\n            z = void 0 === v ? 0 : v;\n        v = k.scrollingContainer;\n        v = void 0 === v ? {\n          scrollLeft: 0,\n          scrollTop: 0\n        } : v;\n        var N = v.scrollLeft,\n            n = v.scrollTop,\n            b = k.styledMode,\n            B = d.distance,\n            x = d.options,\n            T = d.options.positioner,\n            P = {\n          left: N,\n          right: N + k.chartWidth,\n          top: n,\n          bottom: n + k.chartHeight\n        },\n            W = d.getLabel(),\n            u = !(!a.xAxis[0] || !a.xAxis[0].opposite),\n            q = y + n,\n            D = 0,\n            H = t - z;\n        J(c) && (c = [!1, c]);\n        c = c.slice(0, f.length + 1).reduce(function (a, c, k) {\n          if (!1 !== c && \"\" !== c) {\n            k = f[k - 1] || {\n              isHeader: !0,\n              plotX: f[0].plotX,\n              plotY: t,\n              series: {}\n            };\n            var e = k.isHeader,\n                g = e ? d : k.series,\n                w = g.tt,\n                G = k.isHeader;\n            var F = k.series;\n            var I = \"highcharts-color-\" + r(k.colorIndex, F.colorIndex, \"none\");\n            w || (w = {\n              padding: x.padding,\n              r: x.borderRadius\n            }, b || (w.fill = x.backgroundColor, w[\"stroke-width\"] = x.borderWidth), w = m.label(\"\", 0, 0, x[G ? \"headerShape\" : \"shape\"] || \"callout\", void 0, void 0, x.useHTML).addClass((G ? \"highcharts-tooltip-header \" : \"\") + \"highcharts-tooltip-box \" + I).attr(w).add(W));\n            w.isActive = !0;\n            w.attr({\n              text: c\n            });\n            b || w.css(x.style).shadow(x.shadow).attr({\n              stroke: x.borderColor || k.color || F.color || \"#333333\"\n            });\n            c = g.tt = w;\n            G = c.getBBox();\n            g = G.width + c.strokeWidth();\n            e && (D = G.height, H += D, u && (q -= D));\n            F = k.plotX;\n            F = void 0 === F ? 0 : F;\n            I = k.plotY;\n            I = void 0 === I ? 0 : I;\n            var N = k.series;\n\n            if (k.isHeader) {\n              F = l + F;\n              var v = y + t / 2;\n            } else w = N.xAxis, N = N.yAxis, F = w.pos + p(F, -B, w.len + B), N.pos + I >= n + y && N.pos + I <= n + y + t - z && (v = N.pos + I);\n\n            F = p(F, P.left - B, P.right + B);\n            \"number\" === typeof v ? (G = G.height + 1, I = T ? T.call(d, g, G, k) : h(F, v, e, g), a.push({\n              align: T ? 0 : void 0,\n              anchorX: F,\n              anchorY: v,\n              boxWidth: g,\n              point: k,\n              rank: r(I.rank, e ? 1 : 0),\n              size: G,\n              target: I.y,\n              tt: c,\n              x: I.x\n            })) : c.isActive = !1;\n          }\n\n          return a;\n        }, []);\n        !T && c.some(function (b) {\n          return b.x < P.left;\n        }) && (c = c.map(function (b) {\n          var a = h(b.anchorX, b.anchorY, b.point.isHeader, b.boxWidth, !1);\n          return E(b, {\n            target: a.y,\n            x: a.x\n          });\n        }));\n        d.cleanSplit();\n        e.distribute(c, H);\n        c.forEach(function (b) {\n          var a = b.pos;\n          b.tt.attr({\n            visibility: \"undefined\" === typeof a ? \"hidden\" : \"inherit\",\n            x: b.x,\n            y: a + q,\n            anchorX: b.anchorX,\n            anchorY: b.anchorY\n          });\n        });\n        c = d.container;\n        a = d.renderer;\n        d.outside && c && a && (k = W.getBBox(), a.setSize(k.width + k.x, k.height + k.y, !1), g = g.getChartPosition(), c.style.left = g.left + \"px\", c.style.top = g.top + \"px\");\n      };\n\n      f.prototype.styledModeFormat = function (c) {\n        return c.replace('style=\"font-size: 10px\"', 'class=\"highcharts-header\"').replace(/style=\"color:{(point|series)\\.color}\"/g, 'class=\"highcharts-color-{$1.colorIndex}\"');\n      };\n\n      f.prototype.tooltipFooterHeaderFormatter = function (c, f) {\n        var h = f ? \"footer\" : \"header\",\n            d = c.series,\n            a = d.tooltipOptions,\n            k = a.xDateFormat,\n            t = d.xAxis,\n            l = t && \"datetime\" === t.options.type && C(c.key),\n            y = a[h + \"Format\"];\n        f = {\n          isFooter: f,\n          labelConfig: c\n        };\n        e.fireEvent(this, \"headerFormatter\", f, function (f) {\n          l && !k && (k = this.getXDateFormat(c, a, t));\n          l && k && (c.point && c.point.tooltipDateKeys || [\"key\"]).forEach(function (a) {\n            y = y.replace(\"{point.\" + a + \"}\", \"{point.\" + a + \":\" + k + \"}\");\n          });\n          d.chart.styledMode && (y = this.styledModeFormat(y));\n          f.text = A(y, {\n            point: c,\n            series: d\n          }, this.chart);\n        });\n        return f.text;\n      };\n\n      f.prototype.update = function (c) {\n        this.destroy();\n        z(!0, this.chart.options.tooltip.userOptions, c);\n        this.init(this.chart, z(!0, this.options, c));\n      };\n\n      f.prototype.updatePosition = function (c) {\n        var f = this.chart,\n            e = f.pointer,\n            d = this.getLabel(),\n            a = c.plotX + f.plotLeft,\n            k = c.plotY + f.plotTop;\n        e = e.getChartPosition();\n        c = (this.options.positioner || this.getPosition).call(this, d.width, d.height, c);\n\n        if (this.outside) {\n          var t = (this.options.borderWidth || 0) + 2 * this.distance;\n          this.renderer.setSize(d.width + t, d.height + t, !1);\n          if (f = f.containerScaling) u(this.container, {\n            transform: \"scale(\" + f.scaleX + \", \" + f.scaleY + \")\"\n          }), a *= f.scaleX, k *= f.scaleY;\n          a += e.left - c.x;\n          k += e.top - c.y;\n        }\n\n        this.move(Math.round(c.x), Math.round(c.y || 0), a, k);\n      };\n\n      return f;\n    }();\n\n    e.Tooltip = H;\n    return e.Tooltip;\n  });\n  R(p, \"parts/Pointer.js\", [p[\"parts/Globals.js\"], p[\"parts/Utilities.js\"], p[\"parts/Tooltip.js\"], p[\"parts/Color.js\"]], function (e, g, p, u) {\n    var K = g.addEvent,\n        L = g.attr,\n        E = g.css,\n        A = g.defined,\n        C = g.extend,\n        J = g.find,\n        z = g.fireEvent,\n        r = g.isNumber,\n        D = g.isObject,\n        M = g.objectEach,\n        v = g.offset,\n        m = g.pick,\n        H = g.splat,\n        f = u.parse,\n        c = e.charts,\n        l = e.noop;\n\n    g = function () {\n      function h(d, a) {\n        this.lastValidTouch = {};\n        this.pinchDown = [];\n        this.runChartClick = !1;\n        this.chart = d;\n        this.hasDragged = !1;\n        this.options = a;\n\n        this.unbindContainerMouseLeave = function () {};\n\n        this.init(d, a);\n      }\n\n      h.prototype.applyInactiveState = function (d) {\n        var a = [],\n            c;\n        (d || []).forEach(function (d) {\n          c = d.series;\n          a.push(c);\n          c.linkedParent && a.push(c.linkedParent);\n          c.linkedSeries && (a = a.concat(c.linkedSeries));\n          c.navigatorSeries && a.push(c.navigatorSeries);\n        });\n        this.chart.series.forEach(function (d) {\n          -1 === a.indexOf(d) ? d.setState(\"inactive\", !0) : d.options.inactiveOtherPoints && d.setAllPointsToState(\"inactive\");\n        });\n      };\n\n      h.prototype.destroy = function () {\n        var d = this;\n        \"undefined\" !== typeof d.unDocMouseMove && d.unDocMouseMove();\n        this.unbindContainerMouseLeave();\n        e.chartCount || (e.unbindDocumentMouseUp && (e.unbindDocumentMouseUp = e.unbindDocumentMouseUp()), e.unbindDocumentTouchEnd && (e.unbindDocumentTouchEnd = e.unbindDocumentTouchEnd()));\n        clearInterval(d.tooltipTimeout);\n        M(d, function (a, c) {\n          d[c] = null;\n        });\n      };\n\n      h.prototype.drag = function (d) {\n        var a = this.chart,\n            c = a.options.chart,\n            e = d.chartX,\n            h = d.chartY,\n            l = this.zoomHor,\n            g = this.zoomVert,\n            m = a.plotLeft,\n            r = a.plotTop,\n            v = a.plotWidth,\n            N = a.plotHeight,\n            n = this.selectionMarker,\n            b = this.mouseDownX || 0,\n            B = this.mouseDownY || 0,\n            x = D(c.panning) ? c.panning && c.panning.enabled : c.panning,\n            z = c.panKey && d[c.panKey + \"Key\"];\n        if (!n || !n.touch) if (e < m ? e = m : e > m + v && (e = m + v), h < r ? h = r : h > r + N && (h = r + N), this.hasDragged = Math.sqrt(Math.pow(b - e, 2) + Math.pow(B - h, 2)), 10 < this.hasDragged) {\n          var P = a.isInsidePlot(b - m, B - r);\n          a.hasCartesianSeries && (this.zoomX || this.zoomY) && P && !z && !n && (this.selectionMarker = n = a.renderer.rect(m, r, l ? 1 : v, g ? 1 : N, 0).attr({\n            \"class\": \"highcharts-selection-marker\",\n            zIndex: 7\n          }).add(), a.styledMode || n.attr({\n            fill: c.selectionMarkerFill || f(\"#335cad\").setOpacity(.25).get()\n          }));\n          n && l && (e -= b, n.attr({\n            width: Math.abs(e),\n            x: (0 < e ? 0 : e) + b\n          }));\n          n && g && (e = h - B, n.attr({\n            height: Math.abs(e),\n            y: (0 < e ? 0 : e) + B\n          }));\n          P && !n && x && a.pan(d, c.panning);\n        }\n      };\n\n      h.prototype.dragStart = function (d) {\n        var a = this.chart;\n        a.mouseIsDown = d.type;\n        a.cancelClick = !1;\n        a.mouseDownX = this.mouseDownX = d.chartX;\n        a.mouseDownY = this.mouseDownY = d.chartY;\n      };\n\n      h.prototype.drop = function (d) {\n        var a = this,\n            c = this.chart,\n            f = this.hasPinched;\n\n        if (this.selectionMarker) {\n          var e = {\n            originalEvent: d,\n            xAxis: [],\n            yAxis: []\n          },\n              h = this.selectionMarker,\n              l = h.attr ? h.attr(\"x\") : h.x,\n              g = h.attr ? h.attr(\"y\") : h.y,\n              m = h.attr ? h.attr(\"width\") : h.width,\n              v = h.attr ? h.attr(\"height\") : h.height,\n              N;\n          if (this.hasDragged || f) c.axes.forEach(function (c) {\n            if (c.zoomEnabled && A(c.min) && (f || a[{\n              xAxis: \"zoomX\",\n              yAxis: \"zoomY\"\n            }[c.coll]])) {\n              var b = c.horiz,\n                  k = \"touchend\" === d.type ? c.minPixelPadding : 0,\n                  t = c.toValue((b ? l : g) + k);\n              b = c.toValue((b ? l + m : g + v) - k);\n              e[c.coll].push({\n                axis: c,\n                min: Math.min(t, b),\n                max: Math.max(t, b)\n              });\n              N = !0;\n            }\n          }), N && z(c, \"selection\", e, function (a) {\n            c.zoom(C(a, f ? {\n              animation: !1\n            } : null));\n          });\n          r(c.index) && (this.selectionMarker = this.selectionMarker.destroy());\n          f && this.scaleGroups();\n        }\n\n        c && r(c.index) && (E(c.container, {\n          cursor: c._cursor\n        }), c.cancelClick = 10 < this.hasDragged, c.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);\n      };\n\n      h.prototype.findNearestKDPoint = function (d, a, c) {\n        var f;\n        if (this.isStickyTooltip(c)) return this.chart.hoverPoint;\n        d.forEach(function (d) {\n          var k = !(d.noSharedTooltip && a) && 0 > d.options.findNearestPointBy.indexOf(\"y\");\n          d = d.searchPoint(c, k);\n\n          if ((k = D(d, !0)) && !(k = !D(f, !0))) {\n            k = f.distX - d.distX;\n            var e = f.dist - d.dist,\n                t = (d.series.group && d.series.group.zIndex) - (f.series.group && f.series.group.zIndex);\n            k = 0 < (0 !== k && a ? k : 0 !== e ? e : 0 !== t ? t : f.series.index > d.series.index ? -1 : 1);\n          }\n\n          k && (f = d);\n        });\n        return f;\n      };\n\n      h.prototype.getChartCoordinatesFromPoint = function (d, a) {\n        var c = d.series,\n            f = c.xAxis;\n        c = c.yAxis;\n        var e = m(d.clientX, d.plotX),\n            h = d.shapeArgs;\n        if (f && c) return a ? {\n          chartX: f.len + f.pos - e,\n          chartY: c.len + c.pos - d.plotY\n        } : {\n          chartX: e + f.pos,\n          chartY: d.plotY + c.pos\n        };\n        if (h && h.x && h.y) return {\n          chartX: h.x,\n          chartY: h.y\n        };\n      };\n\n      h.prototype.getChartPosition = function () {\n        return this.chartPosition || (this.chartPosition = v(this.chart.container));\n      };\n\n      h.prototype.getCoordinates = function (d) {\n        var a = {\n          xAxis: [],\n          yAxis: []\n        };\n        this.chart.axes.forEach(function (c) {\n          a[c.isXAxis ? \"xAxis\" : \"yAxis\"].push({\n            axis: c,\n            value: c.toValue(d[c.horiz ? \"chartX\" : \"chartY\"])\n          });\n        });\n        return a;\n      };\n\n      h.prototype.getHoverData = function (d, a, c, f, e, h) {\n        var k,\n            t = [];\n        f = !(!f || !d);\n        var l = a && !a.stickyTracking,\n            y = {\n          chartX: h ? h.chartX : void 0,\n          chartY: h ? h.chartY : void 0,\n          shared: e\n        };\n        z(this, \"beforeGetHoverData\", y);\n        l = l ? [a] : c.filter(function (a) {\n          return y.filter ? y.filter(a) : a.visible && !(!e && a.directTouch) && m(a.options.enableMouseTracking, !0) && a.stickyTracking;\n        });\n        a = (k = f || !h ? d : this.findNearestKDPoint(l, e, h)) && k.series;\n        k && (e && !a.noSharedTooltip ? (l = c.filter(function (a) {\n          return y.filter ? y.filter(a) : a.visible && !(!e && a.directTouch) && m(a.options.enableMouseTracking, !0) && !a.noSharedTooltip;\n        }), l.forEach(function (a) {\n          var d = J(a.points, function (b) {\n            return b.x === k.x && !b.isNull;\n          });\n          D(d) && (a.chart.isBoosting && (d = a.getPoint(d)), t.push(d));\n        })) : t.push(k));\n        y = {\n          hoverPoint: k\n        };\n        z(this, \"afterGetHoverData\", y);\n        return {\n          hoverPoint: y.hoverPoint,\n          hoverSeries: a,\n          hoverPoints: t\n        };\n      };\n\n      h.prototype.getPointFromEvent = function (d) {\n        d = d.target;\n\n        for (var a; d && !a;) a = d.point, d = d.parentNode;\n\n        return a;\n      };\n\n      h.prototype.onTrackerMouseOut = function (d) {\n        var a = this.chart.hoverSeries,\n            c = d.relatedTarget || d.toElement;\n        this.isDirectTouch = !1;\n        if (!(!a || !c || a.stickyTracking || this.isStickyTooltip(d) || this.inClass(c, \"highcharts-tooltip\") || this.inClass(c, \"highcharts-series-\" + a.index) && this.inClass(c, \"highcharts-tracker\"))) a.onMouseOut();\n      };\n\n      h.prototype.inClass = function (d, a) {\n        for (var c; d;) {\n          if (c = L(d, \"class\")) {\n            if (-1 !== c.indexOf(a)) return !0;\n            if (-1 !== c.indexOf(\"highcharts-container\")) return !1;\n          }\n\n          d = d.parentNode;\n        }\n      };\n\n      h.prototype.init = function (d, a) {\n        this.options = a;\n        this.chart = d;\n        this.runChartClick = a.chart.events && !!a.chart.events.click;\n        this.pinchDown = [];\n        this.lastValidTouch = {};\n        p && (d.tooltip = new p(d, a.tooltip), this.followTouchMove = m(a.tooltip.followTouchMove, !0));\n        this.setDOMEvents();\n      };\n\n      h.prototype.isStickyTooltip = function (d) {\n        var a = this.chart,\n            c = this.chartPosition,\n            f = a.hoverPoint,\n            h = a.tooltip;\n        a = d.chartX;\n        d = d.chartY;\n        var l = !1;\n\n        if (c && f && f.graphic && h && !h.isHidden && h.options.stickOnHover && h.label) {\n          l = h.label.getBBox();\n          var g = e.offset(h.label.element);\n          h = f.graphic.getBBox();\n          f = e.offset(f.graphic.element);\n          l.x = g.left - c.left;\n          l.y = g.top - c.top;\n          h.x = f.left - c.left;\n          h.y = f.top - c.top;\n          c = Math.min(h.y, l.y);\n          f = Math.max(h.x + h.width, l.x + l.width);\n          g = Math.max(h.y + h.height, l.y + l.height);\n          l = a >= Math.min(h.x, l.x) && a <= f && d >= c && d <= g;\n        }\n\n        return l;\n      };\n\n      h.prototype.normalize = function (d, a) {\n        var c = d.touches,\n            f = c ? c.length ? c.item(0) : c.changedTouches[0] : d;\n        a || (a = this.getChartPosition());\n        c = f.pageX - a.left;\n        a = f.pageY - a.top;\n        if (f = this.chart.containerScaling) c /= f.scaleX, a /= f.scaleY;\n        return C(d, {\n          chartX: Math.round(c),\n          chartY: Math.round(a)\n        });\n      };\n\n      h.prototype.onContainerClick = function (d) {\n        var a = this.chart,\n            c = a.hoverPoint,\n            f = a.plotLeft,\n            e = a.plotTop;\n        d = this.normalize(d);\n        a.cancelClick || (c && this.inClass(d.target, \"highcharts-tracker\") ? (z(c.series, \"click\", C(d, {\n          point: c\n        })), a.hoverPoint && c.firePointEvent(\"click\", d)) : (C(d, this.getCoordinates(d)), a.isInsidePlot(d.chartX - f, d.chartY - e) && z(a, \"click\", d)));\n      };\n\n      h.prototype.onContainerMouseDown = function (d) {\n        d = this.normalize(d);\n        2 !== d.button && (this.zoomOption(d), d.preventDefault && d.preventDefault(), this.dragStart(d));\n      };\n\n      h.prototype.onContainerMouseLeave = function (d) {\n        var a = c[e.hoverChartIndex];\n        a && (d.relatedTarget || d.toElement) && (a.pointer.reset(), a.pointer.chartPosition = void 0);\n      };\n\n      h.prototype.onContainerMouseMove = function (d) {\n        var a = this.chart;\n        A(e.hoverChartIndex) && c[e.hoverChartIndex] && c[e.hoverChartIndex].mouseIsDown || (e.hoverChartIndex = a.index);\n        d = this.normalize(d);\n        d.preventDefault || (d.returnValue = !1);\n        \"mousedown\" === a.mouseIsDown && this.drag(d);\n        a.openMenu || this.isStickyTooltip(d) || !this.inClass(d.target, \"highcharts-tracker\") && !a.isInsidePlot(d.chartX - a.plotLeft, d.chartY - a.plotTop) || this.runPointActions(d);\n      };\n\n      h.prototype.onDocumentTouchEnd = function (d) {\n        c[e.hoverChartIndex] && c[e.hoverChartIndex].pointer.drop(d);\n      };\n\n      h.prototype.onContainerTouchMove = function (d) {\n        this.touch(d);\n      };\n\n      h.prototype.onContainerTouchStart = function (d) {\n        this.zoomOption(d);\n        this.touch(d, !0);\n      };\n\n      h.prototype.onDocumentMouseMove = function (d) {\n        var a = this.chart,\n            c = this.chartPosition;\n        d = this.normalize(d, c);\n        !c || this.isStickyTooltip(d) || this.inClass(d.target, \"highcharts-tracker\") || a.isInsidePlot(d.chartX - a.plotLeft, d.chartY - a.plotTop) || this.reset();\n      };\n\n      h.prototype.onDocumentMouseUp = function (d) {\n        c[e.hoverChartIndex] && c[e.hoverChartIndex].pointer.drop(d);\n      };\n\n      h.prototype.pinch = function (d) {\n        var a = this,\n            c = a.chart,\n            f = a.pinchDown,\n            e = d.touches || [],\n            h = e.length,\n            g = a.lastValidTouch,\n            r = a.hasZoom,\n            v = a.selectionMarker,\n            z = {},\n            N = 1 === h && (a.inClass(d.target, \"highcharts-tracker\") && c.runTrackerClick || a.runChartClick),\n            n = {};\n        1 < h && (a.initiated = !0);\n        r && a.initiated && !N && d.preventDefault();\n        [].map.call(e, function (b) {\n          return a.normalize(b);\n        });\n        \"touchstart\" === d.type ? ([].forEach.call(e, function (b, a) {\n          f[a] = {\n            chartX: b.chartX,\n            chartY: b.chartY\n          };\n        }), g.x = [f[0].chartX, f[1] && f[1].chartX], g.y = [f[0].chartY, f[1] && f[1].chartY], c.axes.forEach(function (b) {\n          if (b.zoomEnabled) {\n            var a = c.bounds[b.horiz ? \"h\" : \"v\"],\n                d = b.minPixelPadding,\n                f = b.toPixels(Math.min(m(b.options.min, b.dataMin), b.dataMin)),\n                e = b.toPixels(Math.max(m(b.options.max, b.dataMax), b.dataMax)),\n                k = Math.max(f, e);\n            a.min = Math.min(b.pos, Math.min(f, e) - d);\n            a.max = Math.max(b.pos + b.len, k + d);\n          }\n        }), a.res = !0) : a.followTouchMove && 1 === h ? this.runPointActions(a.normalize(d)) : f.length && (v || (a.selectionMarker = v = C({\n          destroy: l,\n          touch: !0\n        }, c.plotBox)), a.pinchTranslate(f, e, z, v, n, g), a.hasPinched = r, a.scaleGroups(z, n), a.res && (a.res = !1, this.reset(!1, 0)));\n      };\n\n      h.prototype.pinchTranslate = function (d, a, c, f, e, h) {\n        this.zoomHor && this.pinchTranslateDirection(!0, d, a, c, f, e, h);\n        this.zoomVert && this.pinchTranslateDirection(!1, d, a, c, f, e, h);\n      };\n\n      h.prototype.pinchTranslateDirection = function (d, a, c, f, e, h, l, g) {\n        var k = this.chart,\n            t = d ? \"x\" : \"y\",\n            y = d ? \"X\" : \"Y\",\n            n = \"chart\" + y,\n            b = d ? \"width\" : \"height\",\n            B = k[\"plot\" + (d ? \"Left\" : \"Top\")],\n            x,\n            m,\n            w = g || 1,\n            r = k.inverted,\n            F = k.bounds[d ? \"h\" : \"v\"],\n            q = 1 === a.length,\n            v = a[0][n],\n            I = c[0][n],\n            z = !q && a[1][n],\n            G = !q && c[1][n];\n\n        c = function () {\n          \"number\" === typeof G && 20 < Math.abs(v - z) && (w = g || Math.abs(I - G) / Math.abs(v - z));\n          m = (B - I) / w + v;\n          x = k[\"plot\" + (d ? \"Width\" : \"Height\")] / w;\n        };\n\n        c();\n        a = m;\n\n        if (a < F.min) {\n          a = F.min;\n          var V = !0;\n        } else a + x > F.max && (a = F.max - x, V = !0);\n\n        V ? (I -= .8 * (I - l[t][0]), \"number\" === typeof G && (G -= .8 * (G - l[t][1])), c()) : l[t] = [I, G];\n        r || (h[t] = m - B, h[b] = x);\n        h = r ? 1 / w : w;\n        e[b] = x;\n        e[t] = a;\n        f[r ? d ? \"scaleY\" : \"scaleX\" : \"scale\" + y] = w;\n        f[\"translate\" + y] = h * B + (I - h * v);\n      };\n\n      h.prototype.reset = function (d, a) {\n        var c = this.chart,\n            f = c.hoverSeries,\n            e = c.hoverPoint,\n            h = c.hoverPoints,\n            l = c.tooltip,\n            g = l && l.shared ? h : e;\n        d && g && H(g).forEach(function (a) {\n          a.series.isCartesian && \"undefined\" === typeof a.plotX && (d = !1);\n        });\n        if (d) l && g && H(g).length && (l.refresh(g), l.shared && h ? h.forEach(function (a) {\n          a.setState(a.state, !0);\n          a.series.isCartesian && (a.series.xAxis.crosshair && a.series.xAxis.drawCrosshair(null, a), a.series.yAxis.crosshair && a.series.yAxis.drawCrosshair(null, a));\n        }) : e && (e.setState(e.state, !0), c.axes.forEach(function (a) {\n          a.crosshair && e.series[a.coll] === a && a.drawCrosshair(null, e);\n        })));else {\n          if (e) e.onMouseOut();\n          h && h.forEach(function (a) {\n            a.setState();\n          });\n          if (f) f.onMouseOut();\n          l && l.hide(a);\n          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());\n          c.axes.forEach(function (a) {\n            a.hideCrosshair();\n          });\n          this.hoverX = c.hoverPoints = c.hoverPoint = null;\n        }\n      };\n\n      h.prototype.runPointActions = function (d, a) {\n        var f = this.chart,\n            h = f.tooltip && f.tooltip.options.enabled ? f.tooltip : void 0,\n            l = h ? h.shared : !1,\n            g = a || f.hoverPoint,\n            r = g && g.series || f.hoverSeries;\n        r = this.getHoverData(g, r, f.series, (!d || \"touchmove\" !== d.type) && (!!a || r && r.directTouch && this.isDirectTouch), l, d);\n        g = r.hoverPoint;\n        var v = r.hoverPoints;\n        a = (r = r.hoverSeries) && r.tooltipOptions.followPointer;\n        l = l && r && !r.noSharedTooltip;\n\n        if (g && (g !== f.hoverPoint || h && h.isHidden)) {\n          (f.hoverPoints || []).forEach(function (a) {\n            -1 === v.indexOf(a) && a.setState();\n          });\n          if (f.hoverSeries !== r) r.onMouseOver();\n          this.applyInactiveState(v);\n          (v || []).forEach(function (a) {\n            a.setState(\"hover\");\n          });\n          f.hoverPoint && f.hoverPoint.firePointEvent(\"mouseOut\");\n          if (!g.series) return;\n          g.firePointEvent(\"mouseOver\");\n          f.hoverPoints = v;\n          f.hoverPoint = g;\n          h && h.refresh(l ? v : g, d);\n        } else a && h && !h.isHidden && (g = h.getAnchor([{}], d), h.updatePosition({\n          plotX: g[0],\n          plotY: g[1]\n        }));\n\n        this.unDocMouseMove || (this.unDocMouseMove = K(f.container.ownerDocument, \"mousemove\", function (a) {\n          var d = c[e.hoverChartIndex];\n          if (d) d.pointer.onDocumentMouseMove(a);\n        }));\n        f.axes.forEach(function (a) {\n          var c = m(a.crosshair.snap, !0),\n              f = c ? J(v, function (d) {\n            return d.series[a.coll] === a;\n          }) : void 0;\n          f || !c ? a.drawCrosshair(d, f) : a.hideCrosshair();\n        });\n      };\n\n      h.prototype.scaleGroups = function (d, a) {\n        var c = this.chart,\n            f;\n        c.series.forEach(function (e) {\n          f = d || e.getPlotBox();\n          e.xAxis && e.xAxis.zoomEnabled && e.group && (e.group.attr(f), e.markerGroup && (e.markerGroup.attr(f), e.markerGroup.clip(a ? c.clipRect : null)), e.dataLabelsGroup && e.dataLabelsGroup.attr(f));\n        });\n        c.clipRect.attr(a || c.clipBox);\n      };\n\n      h.prototype.setDOMEvents = function () {\n        var d = this,\n            a = d.chart.container,\n            c = a.ownerDocument;\n\n        a.onmousedown = function (a) {\n          d.onContainerMouseDown(a);\n        };\n\n        a.onmousemove = function (a) {\n          d.onContainerMouseMove(a);\n        };\n\n        a.onclick = function (a) {\n          d.onContainerClick(a);\n        };\n\n        this.unbindContainerMouseLeave = K(a, \"mouseleave\", d.onContainerMouseLeave);\n        e.unbindDocumentMouseUp || (e.unbindDocumentMouseUp = K(c, \"mouseup\", d.onDocumentMouseUp));\n        e.hasTouch && (K(a, \"touchstart\", function (a) {\n          d.onContainerTouchStart(a);\n        }), K(a, \"touchmove\", function (a) {\n          d.onContainerTouchMove(a);\n        }), e.unbindDocumentTouchEnd || (e.unbindDocumentTouchEnd = K(c, \"touchend\", d.onDocumentTouchEnd)));\n      };\n\n      h.prototype.touch = function (d, a) {\n        var c = this.chart,\n            f;\n        if (c.index !== e.hoverChartIndex) this.onContainerMouseLeave({\n          relatedTarget: !0\n        });\n        e.hoverChartIndex = c.index;\n        if (1 === d.touches.length) {\n          if (d = this.normalize(d), (f = c.isInsidePlot(d.chartX - c.plotLeft, d.chartY - c.plotTop)) && !c.openMenu) {\n            a && this.runPointActions(d);\n\n            if (\"touchmove\" === d.type) {\n              a = this.pinchDown;\n              var h = a[0] ? 4 <= Math.sqrt(Math.pow(a[0].chartX - d.chartX, 2) + Math.pow(a[0].chartY - d.chartY, 2)) : !1;\n            }\n\n            m(h, !0) && this.pinch(d);\n          } else a && this.reset();\n        } else 2 === d.touches.length && this.pinch(d);\n      };\n\n      h.prototype.zoomOption = function (c) {\n        var a = this.chart,\n            d = a.options.chart,\n            f = d.zoomType || \"\";\n        a = a.inverted;\n        /touch/.test(c.type) && (f = m(d.pinchType, f));\n        this.zoomX = c = /x/.test(f);\n        this.zoomY = f = /y/.test(f);\n        this.zoomHor = c && !a || f && a;\n        this.zoomVert = f && !a || c && a;\n        this.hasZoom = c || f;\n      };\n\n      return h;\n    }();\n\n    e.Pointer = g;\n    return e.Pointer;\n  });\n  R(p, \"parts/MSPointer.js\", [p[\"parts/Globals.js\"], p[\"parts/Pointer.js\"], p[\"parts/Utilities.js\"]], function (e, g, p) {\n    function u() {\n      var e = [];\n\n      e.item = function (e) {\n        return this[e];\n      };\n\n      C(M, function (g) {\n        e.push({\n          pageX: g.pageX,\n          pageY: g.pageY,\n          target: g.target\n        });\n      });\n      return e;\n    }\n\n    function K(g, r, f, c) {\n      \"touch\" !== g.pointerType && g.pointerType !== g.MSPOINTER_TYPE_TOUCH || !z[e.hoverChartIndex] || (c(g), c = z[e.hoverChartIndex].pointer, c[r]({\n        type: f,\n        target: g.currentTarget,\n        preventDefault: D,\n        touches: u()\n      }));\n    }\n\n    var L = this && this.__extends || function () {\n      var e = function (g, f) {\n        e = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (c, f) {\n          c.__proto__ = f;\n        } || function (c, f) {\n          for (var e in f) f.hasOwnProperty(e) && (c[e] = f[e]);\n        };\n\n        return e(g, f);\n      };\n\n      return function (g, f) {\n        function c() {\n          this.constructor = g;\n        }\n\n        e(g, f);\n        g.prototype = null === f ? Object.create(f) : (c.prototype = f.prototype, new c());\n      };\n    }(),\n        E = p.addEvent,\n        A = p.css,\n        C = p.objectEach,\n        J = p.removeEvent,\n        z = e.charts,\n        r = e.doc,\n        D = e.noop,\n        M = {},\n        v = !!e.win.PointerEvent;\n\n    return function (e) {\n      function g() {\n        return null !== e && e.apply(this, arguments) || this;\n      }\n\n      L(g, e);\n\n      g.prototype.batchMSEvents = function (f) {\n        f(this.chart.container, v ? \"pointerdown\" : \"MSPointerDown\", this.onContainerPointerDown);\n        f(this.chart.container, v ? \"pointermove\" : \"MSPointerMove\", this.onContainerPointerMove);\n        f(r, v ? \"pointerup\" : \"MSPointerUp\", this.onDocumentPointerUp);\n      };\n\n      g.prototype.destroy = function () {\n        this.batchMSEvents(J);\n        e.prototype.destroy.call(this);\n      };\n\n      g.prototype.init = function (f, c) {\n        e.prototype.init.call(this, f, c);\n        this.hasZoom && A(f.container, {\n          \"-ms-touch-action\": \"none\",\n          \"touch-action\": \"none\"\n        });\n      };\n\n      g.prototype.onContainerPointerDown = function (f) {\n        K(f, \"onContainerTouchStart\", \"touchstart\", function (c) {\n          M[c.pointerId] = {\n            pageX: c.pageX,\n            pageY: c.pageY,\n            target: c.currentTarget\n          };\n        });\n      };\n\n      g.prototype.onContainerPointerMove = function (f) {\n        K(f, \"onContainerTouchMove\", \"touchmove\", function (c) {\n          M[c.pointerId] = {\n            pageX: c.pageX,\n            pageY: c.pageY\n          };\n          M[c.pointerId].target || (M[c.pointerId].target = c.currentTarget);\n        });\n      };\n\n      g.prototype.onDocumentPointerUp = function (f) {\n        K(f, \"onDocumentTouchEnd\", \"touchend\", function (c) {\n          delete M[c.pointerId];\n        });\n      };\n\n      g.prototype.setDOMEvents = function () {\n        e.prototype.setDOMEvents.call(this);\n        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(E);\n      };\n\n      return g;\n    }(g);\n  });\n  R(p, \"parts/Legend.js\", [p[\"parts/Globals.js\"], p[\"parts/Utilities.js\"]], function (e, g) {\n    var p = g.addEvent,\n        u = g.css,\n        K = g.defined,\n        L = g.discardElement,\n        E = g.find,\n        A = g.fireEvent,\n        C = g.format,\n        J = g.isNumber,\n        z = g.merge,\n        r = g.pick,\n        D = g.relativeLength,\n        M = g.setAnimation,\n        v = g.stableSort,\n        m = g.syncTimeout;\n    g = g.wrap;\n\n    var H = e.isFirefox,\n        f = e.marginNames,\n        c = e.win,\n        l = function () {\n      function c(c, a) {\n        this.allItems = [];\n        this.contentGroup = this.box = void 0;\n        this.display = !1;\n        this.group = void 0;\n        this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;\n        this.options = {};\n        this.padding = 0;\n        this.pages = [];\n        this.proximate = !1;\n        this.scrollGroup = void 0;\n        this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;\n        this.chart = c;\n        this.init(c, a);\n      }\n\n      c.prototype.init = function (c, a) {\n        this.chart = c;\n        this.setOptions(a);\n        a.enabled && (this.render(), p(this.chart, \"endResize\", function () {\n          this.legend.positionCheckboxes();\n        }), this.proximate ? this.unchartrender = p(this.chart, \"render\", function () {\n          this.legend.proximatePositions();\n          this.legend.positionItems();\n        }) : this.unchartrender && this.unchartrender());\n      };\n\n      c.prototype.setOptions = function (c) {\n        var a = r(c.padding, 8);\n        this.options = c;\n        this.chart.styledMode || (this.itemStyle = c.itemStyle, this.itemHiddenStyle = z(this.itemStyle, c.itemHiddenStyle));\n        this.itemMarginTop = c.itemMarginTop || 0;\n        this.itemMarginBottom = c.itemMarginBottom || 0;\n        this.padding = a;\n        this.initialItemY = a - 5;\n        this.symbolWidth = r(c.symbolWidth, 16);\n        this.pages = [];\n        this.proximate = \"proximate\" === c.layout && !this.chart.inverted;\n        this.baseline = void 0;\n      };\n\n      c.prototype.update = function (c, a) {\n        var d = this.chart;\n        this.setOptions(z(!0, this.options, c));\n        this.destroy();\n        d.isDirtyLegend = d.isDirtyBox = !0;\n        r(a, !0) && d.redraw();\n        A(this, \"afterUpdate\");\n      };\n\n      c.prototype.colorizeItem = function (c, a) {\n        c.legendGroup[a ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\");\n\n        if (!this.chart.styledMode) {\n          var d = this.options,\n              f = c.legendItem,\n              e = c.legendLine,\n              h = c.legendSymbol,\n              l = this.itemHiddenStyle.color;\n          d = a ? d.itemStyle.color : l;\n          var g = a ? c.color || l : l,\n              m = c.options && c.options.marker,\n              r = {\n            fill: g\n          };\n          f && f.css({\n            fill: d,\n            color: d\n          });\n          e && e.attr({\n            stroke: g\n          });\n          h && (m && h.isMarker && (r = c.pointAttribs(), a || (r.stroke = r.fill = l)), h.attr(r));\n        }\n\n        A(this, \"afterColorizeItem\", {\n          item: c,\n          visible: a\n        });\n      };\n\n      c.prototype.positionItems = function () {\n        this.allItems.forEach(this.positionItem, this);\n        this.chart.isResizing || this.positionCheckboxes();\n      };\n\n      c.prototype.positionItem = function (c) {\n        var a = this.options,\n            d = a.symbolPadding;\n        a = !a.rtl;\n        var f = c._legendItemPos,\n            e = f[0];\n        f = f[1];\n        var h = c.checkbox;\n        if ((c = c.legendGroup) && c.element) c[K(c.translateY) ? \"animate\" : \"attr\"]({\n          translateX: a ? e : this.legendWidth - e - 2 * d - 4,\n          translateY: f\n        });\n        h && (h.x = e, h.y = f);\n      };\n\n      c.prototype.destroyItem = function (c) {\n        var a = c.checkbox;\n        [\"legendItem\", \"legendLine\", \"legendSymbol\", \"legendGroup\"].forEach(function (a) {\n          c[a] && (c[a] = c[a].destroy());\n        });\n        a && L(c.checkbox);\n      };\n\n      c.prototype.destroy = function () {\n        function c(a) {\n          this[a] && (this[a] = this[a].destroy());\n        }\n\n        this.getAllItems().forEach(function (a) {\n          [\"legendItem\", \"legendGroup\"].forEach(c, a);\n        });\n        \"clipRect up down pager nav box title group\".split(\" \").forEach(c, this);\n        this.display = null;\n      };\n\n      c.prototype.positionCheckboxes = function () {\n        var c = this.group && this.group.alignAttr,\n            a = this.clipHeight || this.legendHeight,\n            f = this.titleHeight;\n\n        if (c) {\n          var e = c.translateY;\n          this.allItems.forEach(function (d) {\n            var k = d.checkbox;\n\n            if (k) {\n              var h = e + f + k.y + (this.scrollOffset || 0) + 3;\n              u(k, {\n                left: c.translateX + d.checkboxOffset + k.x - 20 + \"px\",\n                top: h + \"px\",\n                display: this.proximate || h > e - 6 && h < e + a - 6 ? \"\" : \"none\"\n              });\n            }\n          }, this);\n        }\n      };\n\n      c.prototype.renderTitle = function () {\n        var c = this.options,\n            a = this.padding,\n            f = c.title,\n            e = 0;\n        f.text && (this.title || (this.title = this.chart.renderer.label(f.text, a - 3, a - 4, null, null, null, c.useHTML, null, \"legend-title\").attr({\n          zIndex: 1\n        }), this.chart.styledMode || this.title.css(f.style), this.title.add(this.group)), f.width || this.title.css({\n          width: this.maxLegendWidth + \"px\"\n        }), c = this.title.getBBox(), e = c.height, this.offsetWidth = c.width, this.contentGroup.attr({\n          translateY: e\n        }));\n        this.titleHeight = e;\n      };\n\n      c.prototype.setText = function (c) {\n        var a = this.options;\n        c.legendItem.attr({\n          text: a.labelFormat ? C(a.labelFormat, c, this.chart) : a.labelFormatter.call(c)\n        });\n      };\n\n      c.prototype.renderItem = function (c) {\n        var a = this.chart,\n            d = a.renderer,\n            f = this.options,\n            e = this.symbolWidth,\n            h = f.symbolPadding,\n            l = this.itemStyle,\n            g = this.itemHiddenStyle,\n            m = \"horizontal\" === f.layout ? r(f.itemDistance, 20) : 0,\n            v = !f.rtl,\n            N = c.legendItem,\n            n = !c.series,\n            b = !n && c.series.drawLegendSymbol ? c.series : c,\n            B = b.options;\n        B = this.createCheckboxForItem && B && B.showCheckbox;\n        m = e + h + m + (B ? 20 : 0);\n        var x = f.useHTML,\n            T = c.options.className;\n        N || (c.legendGroup = d.g(\"legend-item\").addClass(\"highcharts-\" + b.type + \"-series highcharts-color-\" + c.colorIndex + (T ? \" \" + T : \"\") + (n ? \" highcharts-series-\" + c.index : \"\")).attr({\n          zIndex: 1\n        }).add(this.scrollGroup), c.legendItem = N = d.text(\"\", v ? e + h : -h, this.baseline || 0, x), a.styledMode || N.css(z(c.visible ? l : g)), N.attr({\n          align: v ? \"left\" : \"right\",\n          zIndex: 2\n        }).add(c.legendGroup), this.baseline || (this.fontMetrics = d.fontMetrics(a.styledMode ? 12 : l.fontSize, N), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, N.attr(\"y\", this.baseline)), this.symbolHeight = f.symbolHeight || this.fontMetrics.f, b.drawLegendSymbol(this, c), this.setItemEvents && this.setItemEvents(c, N, x));\n        B && !c.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(c);\n        this.colorizeItem(c, c.visible);\n        !a.styledMode && l.width || N.css({\n          width: (f.itemWidth || this.widthOption || a.spacingBox.width) - m\n        });\n        this.setText(c);\n        a = N.getBBox();\n        c.itemWidth = c.checkboxOffset = f.itemWidth || c.legendItemWidth || a.width + m;\n        this.maxItemWidth = Math.max(this.maxItemWidth, c.itemWidth);\n        this.totalItemWidth += c.itemWidth;\n        this.itemHeight = c.itemHeight = Math.round(c.legendItemHeight || a.height || this.symbolHeight);\n      };\n\n      c.prototype.layoutItem = function (c) {\n        var a = this.options,\n            d = this.padding,\n            f = \"horizontal\" === a.layout,\n            e = c.itemHeight,\n            h = this.itemMarginBottom,\n            l = this.itemMarginTop,\n            g = f ? r(a.itemDistance, 20) : 0,\n            m = this.maxLegendWidth;\n        a = a.alignColumns && this.totalItemWidth > m ? this.maxItemWidth : c.itemWidth;\n        f && this.itemX - d + a > m && (this.itemX = d, this.lastLineHeight && (this.itemY += l + this.lastLineHeight + h), this.lastLineHeight = 0);\n        this.lastItemY = l + this.itemY + h;\n        this.lastLineHeight = Math.max(e, this.lastLineHeight);\n        c._legendItemPos = [this.itemX, this.itemY];\n        f ? this.itemX += a : (this.itemY += l + e + h, this.lastLineHeight = e);\n        this.offsetWidth = this.widthOption || Math.max((f ? this.itemX - d - (c.checkbox ? 0 : g) : a) + d, this.offsetWidth);\n      };\n\n      c.prototype.getAllItems = function () {\n        var c = [];\n        this.chart.series.forEach(function (a) {\n          var d = a && a.options;\n          a && r(d.showInLegend, K(d.linkedTo) ? !1 : void 0, !0) && (c = c.concat(a.legendItems || (\"point\" === d.legendType ? a.data : a)));\n        });\n        A(this, \"afterGetAllItems\", {\n          allItems: c\n        });\n        return c;\n      };\n\n      c.prototype.getAlignment = function () {\n        var c = this.options;\n        return this.proximate ? c.align.charAt(0) + \"tv\" : c.floating ? \"\" : c.align.charAt(0) + c.verticalAlign.charAt(0) + c.layout.charAt(0);\n      };\n\n      c.prototype.adjustMargins = function (c, a) {\n        var d = this.chart,\n            e = this.options,\n            h = this.getAlignment();\n        h && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (k, l) {\n          k.test(h) && !K(c[l]) && (d[f[l]] = Math.max(d[f[l]], d.legend[(l + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [1, -1, -1, 1][l] * e[l % 2 ? \"x\" : \"y\"] + r(e.margin, 12) + a[l] + (d.titleOffset[l] || 0)));\n        });\n      };\n\n      c.prototype.proximatePositions = function () {\n        var c = this.chart,\n            a = [],\n            f = \"left\" === this.options.align;\n        this.allItems.forEach(function (d) {\n          var e = f;\n\n          if (d.yAxis && d.points) {\n            d.xAxis.options.reversed && (e = !e);\n            var h = E(e ? d.points : d.points.slice(0).reverse(), function (a) {\n              return J(a.plotY);\n            });\n            e = this.itemMarginTop + d.legendItem.getBBox().height + this.itemMarginBottom;\n            var k = d.yAxis.top - c.plotTop;\n            d.visible ? (h = h ? h.plotY : d.yAxis.height, h += k - .3 * e) : h = k + d.yAxis.height;\n            a.push({\n              target: h,\n              size: e,\n              item: d\n            });\n          }\n        }, this);\n        e.distribute(a, c.plotHeight);\n        a.forEach(function (a) {\n          a.item._legendItemPos[1] = c.plotTop - c.spacing[0] + a.pos;\n        });\n      };\n\n      c.prototype.render = function () {\n        var c = this.chart,\n            a = c.renderer,\n            f = this.group,\n            e,\n            h = this.box,\n            l = this.options,\n            g = this.padding;\n        this.itemX = g;\n        this.itemY = this.initialItemY;\n        this.lastItemY = this.offsetWidth = 0;\n        this.widthOption = D(l.width, c.spacingBox.width - g);\n        var m = c.spacingBox.width - 2 * g - l.x;\n        -1 < [\"rm\", \"lm\"].indexOf(this.getAlignment().substring(0, 2)) && (m /= 2);\n        this.maxLegendWidth = this.widthOption || m;\n        f || (this.group = f = a.g(\"legend\").attr({\n          zIndex: 7\n        }).add(), this.contentGroup = a.g().attr({\n          zIndex: 1\n        }).add(f), this.scrollGroup = a.g().add(this.contentGroup));\n        this.renderTitle();\n        m = this.getAllItems();\n        v(m, function (a, c) {\n          return (a.options && a.options.legendIndex || 0) - (c.options && c.options.legendIndex || 0);\n        });\n        l.reversed && m.reverse();\n        this.allItems = m;\n        this.display = e = !!m.length;\n        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;\n        m.forEach(this.renderItem, this);\n        m.forEach(this.layoutItem, this);\n        m = (this.widthOption || this.offsetWidth) + g;\n        var r = this.lastItemY + this.lastLineHeight + this.titleHeight;\n        r = this.handleOverflow(r);\n        r += g;\n        h || (this.box = h = a.rect().addClass(\"highcharts-legend-box\").attr({\n          r: l.borderRadius\n        }).add(f), h.isNew = !0);\n        c.styledMode || h.attr({\n          stroke: l.borderColor,\n          \"stroke-width\": l.borderWidth || 0,\n          fill: l.backgroundColor || \"none\"\n        }).shadow(l.shadow);\n        0 < m && 0 < r && (h[h.isNew ? \"attr\" : \"animate\"](h.crisp.call({}, {\n          x: 0,\n          y: 0,\n          width: m,\n          height: r\n        }, h.strokeWidth())), h.isNew = !1);\n        h[e ? \"show\" : \"hide\"]();\n        c.styledMode && \"none\" === f.getStyle(\"display\") && (m = r = 0);\n        this.legendWidth = m;\n        this.legendHeight = r;\n        e && (a = c.spacingBox, h = a.y, /(lth|ct|rth)/.test(this.getAlignment()) && 0 < c.titleOffset[0] ? h += c.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < c.titleOffset[2] && (h -= c.titleOffset[2]), h !== a.y && (a = z(a, {\n          y: h\n        })), f.align(z(l, {\n          width: m,\n          height: r,\n          verticalAlign: this.proximate ? \"top\" : l.verticalAlign\n        }), !0, a));\n        this.proximate || this.positionItems();\n        A(this, \"afterRender\");\n      };\n\n      c.prototype.handleOverflow = function (c) {\n        var a = this,\n            d = this.chart,\n            f = d.renderer,\n            e = this.options,\n            h = e.y,\n            l = this.padding;\n        h = d.spacingBox.height + (\"top\" === e.verticalAlign ? -h : h) - l;\n\n        var g = e.maxHeight,\n            m,\n            v = this.clipRect,\n            z = e.navigation,\n            n = r(z.animation, !0),\n            b = z.arrowSize || 12,\n            B = this.nav,\n            x = this.pages,\n            T,\n            P = this.allItems,\n            u = function (b) {\n          \"number\" === typeof b ? v.attr({\n            height: b\n          }) : v && (a.clipRect = v.destroy(), a.contentGroup.clip());\n          a.contentGroup.div && (a.contentGroup.div.style.clip = b ? \"rect(\" + l + \"px,9999px,\" + (l + b) + \"px,0)\" : \"auto\");\n        },\n            D = function (c) {\n          a[c] = f.circle(0, 0, 1.3 * b).translate(b / 2, b / 2).add(B);\n          d.styledMode || a[c].attr(\"fill\", \"rgba(0,0,0,0.0001)\");\n          return a[c];\n        };\n\n        \"horizontal\" !== e.layout || \"middle\" === e.verticalAlign || e.floating || (h /= 2);\n        g && (h = Math.min(h, g));\n        x.length = 0;\n        c > h && !1 !== z.enabled ? (this.clipHeight = m = Math.max(h - 20 - this.titleHeight - l, 0), this.currentPage = r(this.currentPage, 1), this.fullHeight = c, P.forEach(function (a, b) {\n          var c = a._legendItemPos[1],\n              d = Math.round(a.legendItem.getBBox().height),\n              f = x.length;\n          if (!f || c - x[f - 1] > m && (T || c) !== x[f - 1]) x.push(T || c), f++;\n          a.pageIx = f - 1;\n          T && (P[b - 1].pageIx = f - 1);\n          b === P.length - 1 && c + d - x[f - 1] > m && c !== T && (x.push(c), a.pageIx = f);\n          c !== T && (T = c);\n        }), v || (v = a.clipRect = f.clipRect(0, l, 9999, 0), a.contentGroup.clip(v)), u(m), B || (this.nav = B = f.g().attr({\n          zIndex: 1\n        }).add(this.group), this.up = f.symbol(\"triangle\", 0, 0, b, b).add(B), D(\"upTracker\").on(\"click\", function () {\n          a.scroll(-1, n);\n        }), this.pager = f.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\"), d.styledMode || this.pager.css(z.style), this.pager.add(B), this.down = f.symbol(\"triangle-down\", 0, 0, b, b).add(B), D(\"downTracker\").on(\"click\", function () {\n          a.scroll(1, n);\n        })), a.scroll(0), c = h) : B && (u(), this.nav = B.destroy(), this.scrollGroup.attr({\n          translateY: 1\n        }), this.clipHeight = 0);\n        return c;\n      };\n\n      c.prototype.scroll = function (c, a) {\n        var d = this,\n            f = this.chart,\n            h = this.pages,\n            l = h.length,\n            g = this.currentPage + c;\n        c = this.clipHeight;\n        var v = this.options.navigation,\n            z = this.pager,\n            u = this.padding;\n        g > l && (g = l);\n        0 < g && (\"undefined\" !== typeof a && M(a, f), this.nav.attr({\n          translateX: u,\n          translateY: c + this.padding + 7 + this.titleHeight,\n          visibility: \"visible\"\n        }), [this.up, this.upTracker].forEach(function (a) {\n          a.attr({\n            \"class\": 1 === g ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }), z.attr({\n          text: g + \"/\" + l\n        }), [this.down, this.downTracker].forEach(function (a) {\n          a.attr({\n            x: 18 + this.pager.getBBox().width,\n            \"class\": g === l ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }, this), f.styledMode || (this.up.attr({\n          fill: 1 === g ? v.inactiveColor : v.activeColor\n        }), this.upTracker.css({\n          cursor: 1 === g ? \"default\" : \"pointer\"\n        }), this.down.attr({\n          fill: g === l ? v.inactiveColor : v.activeColor\n        }), this.downTracker.css({\n          cursor: g === l ? \"default\" : \"pointer\"\n        })), this.scrollOffset = -h[g - 1] + this.initialItemY, this.scrollGroup.animate({\n          translateY: this.scrollOffset\n        }), this.currentPage = g, this.positionCheckboxes(), a = e.animObject(r(a, f.renderer.globalAnimation, !0)), m(function () {\n          A(d, \"afterScroll\", {\n            currentPage: g\n          });\n        }, a.duration || 0));\n      };\n\n      return c;\n    }();\n\n    (/Trident\\/7\\.0/.test(c.navigator && c.navigator.userAgent) || H) && g(l.prototype, \"positionItem\", function (c, d) {\n      var a = this,\n          f = function () {\n        d._legendItemPos && c.call(a, d);\n      };\n\n      f();\n      a.bubbleLegend || setTimeout(f);\n    });\n    e.Legend = l;\n    return e.Legend;\n  });\n  R(p, \"parts/Chart.js\", [p[\"parts/Globals.js\"], p[\"parts/Legend.js\"], p[\"parts/MSPointer.js\"], p[\"parts/Pointer.js\"], p[\"parts/Time.js\"], p[\"parts/Utilities.js\"]], function (e, g, p, u, K, L) {\n    var E = L.addEvent,\n        A = L.animate,\n        C = L.animObject,\n        J = L.attr,\n        z = L.createElement,\n        r = L.css,\n        D = L.defined,\n        M = L.discardElement,\n        v = L.erase,\n        m = L.error,\n        H = L.extend,\n        f = L.find,\n        c = L.fireEvent,\n        l = L.getStyle,\n        h = L.isArray,\n        d = L.isFunction,\n        a = L.isNumber,\n        k = L.isObject,\n        t = L.isString,\n        w = L.merge,\n        y = L.numberFormat,\n        F = L.objectEach,\n        I = L.pick,\n        S = L.pInt,\n        O = L.relativeLength,\n        N = L.removeEvent,\n        n = L.setAnimation,\n        b = L.splat,\n        B = L.syncTimeout,\n        x = L.uniqueKey,\n        T = e.doc,\n        P = e.Axis,\n        W = e.defaultOptions,\n        U = e.charts,\n        q = e.marginNames,\n        Q = e.seriesTypes,\n        Z = e.win,\n        ca = e.Chart = function () {\n      this.getArgs.apply(this, arguments);\n    };\n\n    e.chart = function (a, b, c) {\n      return new ca(a, b, c);\n    };\n\n    H(ca.prototype, {\n      callbacks: [],\n      getArgs: function () {\n        var a = [].slice.call(arguments);\n        if (t(a[0]) || a[0].nodeName) this.renderTo = a.shift();\n        this.init(a[0], a[1]);\n      },\n      init: function (a, b) {\n        var f,\n            h = a.series,\n            l = a.plotOptions || {};\n        c(this, \"init\", {\n          args: arguments\n        }, function () {\n          a.series = null;\n          f = w(W, a);\n          F(f.plotOptions, function (a, b) {\n            k(a) && (a.tooltip = l[b] && w(l[b].tooltip) || void 0);\n          });\n          f.tooltip.userOptions = a.chart && a.chart.forExport && a.tooltip.userOptions || a.tooltip;\n          f.series = a.series = h;\n          this.userOptions = a;\n          var g = f.chart,\n              x = g.events;\n          this.margin = [];\n          this.spacing = [];\n          this.bounds = {\n            h: {},\n            v: {}\n          };\n          this.labelCollectors = [];\n          this.callback = b;\n          this.isResizing = 0;\n          this.options = f;\n          this.axes = [];\n          this.series = [];\n          this.time = a.time && Object.keys(a.time).length ? new K(a.time) : e.time;\n          this.numberFormatter = g.numberFormatter || y;\n          this.styledMode = g.styledMode;\n          this.hasCartesianSeries = g.showAxes;\n          var q = this;\n          q.index = U.length;\n          U.push(q);\n          e.chartCount++;\n          x && F(x, function (a, b) {\n            d(a) && E(q, b, a);\n          });\n          q.xAxis = [];\n          q.yAxis = [];\n          q.pointCount = q.colorCounter = q.symbolCounter = 0;\n          c(q, \"afterInit\");\n          q.firstRender();\n        });\n      },\n      initSeries: function (a) {\n        var b = this.options.chart;\n        b = a.type || b.type || b.defaultSeriesType;\n        var c = Q[b];\n        c || m(17, !0, this, {\n          missingModuleFor: b\n        });\n        b = new c();\n        b.init(this, a);\n        return b;\n      },\n      setSeriesData: function () {\n        this.getSeriesOrderByLinks().forEach(function (a) {\n          a.points || a.data || !a.enabledDataSorting || a.setData(a.options.data, !1);\n        });\n      },\n      getSeriesOrderByLinks: function () {\n        return this.series.concat().sort(function (a, b) {\n          return a.linkedSeries.length || b.linkedSeries.length ? b.linkedSeries.length - a.linkedSeries.length : 0;\n        });\n      },\n      orderSeries: function (a) {\n        var b = this.series;\n\n        for (a = a || 0; a < b.length; a++) b[a] && (b[a].index = a, b[a].name = b[a].getName());\n      },\n      isInsidePlot: function (a, b, d) {\n        var f = d ? b : a;\n        a = d ? a : b;\n        f = {\n          x: f,\n          y: a,\n          isInsidePlot: 0 <= f && f <= this.plotWidth && 0 <= a && a <= this.plotHeight\n        };\n        c(this, \"afterIsInsidePlot\", f);\n        return f.isInsidePlot;\n      },\n      redraw: function (a) {\n        c(this, \"beforeRedraw\");\n        var b = this.axes,\n            d = this.series,\n            f = this.pointer,\n            e = this.legend,\n            h = this.userOptions.legend,\n            l = this.isDirtyLegend,\n            k = this.hasCartesianSeries,\n            g = this.isDirtyBox,\n            x = this.renderer,\n            q = x.isHidden(),\n            t = [];\n        this.setResponsive && this.setResponsive(!1);\n        n(this.hasRendered ? a : !1, this);\n        q && this.temporaryDisplay();\n        this.layOutTitles();\n\n        for (a = d.length; a--;) {\n          var m = d[a];\n\n          if (m.options.stacking) {\n            var B = !0;\n\n            if (m.isDirty) {\n              var y = !0;\n              break;\n            }\n          }\n        }\n\n        if (y) for (a = d.length; a--;) m = d[a], m.options.stacking && (m.isDirty = !0);\n        d.forEach(function (a) {\n          a.isDirty && (\"point\" === a.options.legendType ? (a.updateTotals && a.updateTotals(), l = !0) : h && (h.labelFormatter || h.labelFormat) && (l = !0));\n          a.isDirtyData && c(a, \"updatedData\");\n        });\n        l && e && e.options.enabled && (e.render(), this.isDirtyLegend = !1);\n        B && this.getStacks();\n        k && b.forEach(function (a) {\n          a.updateNames();\n          a.setScale();\n        });\n        this.getMargins();\n        k && (b.forEach(function (a) {\n          a.isDirty && (g = !0);\n        }), b.forEach(function (a) {\n          var b = a.min + \",\" + a.max;\n          a.extKey !== b && (a.extKey = b, t.push(function () {\n            c(a, \"afterSetExtremes\", H(a.eventArgs, a.getExtremes()));\n            delete a.eventArgs;\n          }));\n          (g || B) && a.redraw();\n        }));\n        g && this.drawChartBox();\n        c(this, \"predraw\");\n        d.forEach(function (a) {\n          (g || a.isDirty) && a.visible && a.redraw();\n          a.isDirtyData = !1;\n        });\n        f && f.reset(!0);\n        x.draw();\n        c(this, \"redraw\");\n        c(this, \"render\");\n        q && this.temporaryDisplay(!0);\n        t.forEach(function (a) {\n          a.call();\n        });\n      },\n      get: function (a) {\n        function b(b) {\n          return b.id === a || b.options && b.options.id === a;\n        }\n\n        var c = this.series,\n            d;\n        var e = f(this.axes, b) || f(this.series, b);\n\n        for (d = 0; !e && d < c.length; d++) e = f(c[d].points || [], b);\n\n        return e;\n      },\n      getAxes: function () {\n        var a = this,\n            d = this.options,\n            f = d.xAxis = b(d.xAxis || {});\n        d = d.yAxis = b(d.yAxis || {});\n        c(this, \"getAxes\");\n        f.forEach(function (a, b) {\n          a.index = b;\n          a.isX = !0;\n        });\n        d.forEach(function (a, b) {\n          a.index = b;\n        });\n        f.concat(d).forEach(function (b) {\n          new P(a, b);\n        });\n        c(this, \"afterGetAxes\");\n      },\n      getSelectedPoints: function () {\n        var a = [];\n        this.series.forEach(function (b) {\n          a = a.concat(b.getPointsCollection().filter(function (a) {\n            return I(a.selectedStaging, a.selected);\n          }));\n        });\n        return a;\n      },\n      getSelectedSeries: function () {\n        return this.series.filter(function (a) {\n          return a.selected;\n        });\n      },\n      setTitle: function (a, b, c) {\n        this.applyDescription(\"title\", a);\n        this.applyDescription(\"subtitle\", b);\n        this.applyDescription(\"caption\", void 0);\n        this.layOutTitles(c);\n      },\n      applyDescription: function (a, b) {\n        var c = this,\n            d = \"title\" === a ? {\n          color: \"#333333\",\n          fontSize: this.options.isStock ? \"16px\" : \"18px\"\n        } : {\n          color: \"#666666\"\n        };\n        d = this.options[a] = w(!this.styledMode && {\n          style: d\n        }, this.options[a], b);\n        var f = this[a];\n        f && b && (this[a] = f = f.destroy());\n        d && !f && (f = this.renderer.text(d.text, 0, 0, d.useHTML).attr({\n          align: d.align,\n          \"class\": \"highcharts-\" + a,\n          zIndex: d.zIndex || 4\n        }).add(), f.update = function (b) {\n          c[{\n            title: \"setTitle\",\n            subtitle: \"setSubtitle\",\n            caption: \"setCaption\"\n          }[a]](b);\n        }, this.styledMode || f.css(d.style), this[a] = f);\n      },\n      layOutTitles: function (a) {\n        var b = [0, 0, 0],\n            d = this.renderer,\n            f = this.spacingBox;\n        [\"title\", \"subtitle\", \"caption\"].forEach(function (a) {\n          var c = this[a],\n              e = this.options[a],\n              h = e.verticalAlign || \"top\";\n          a = \"title\" === a ? -3 : \"top\" === h ? b[0] + 2 : 0;\n\n          if (c) {\n            if (!this.styledMode) var l = e.style.fontSize;\n            l = d.fontMetrics(l, c).b;\n            c.css({\n              width: (e.width || f.width + (e.widthAdjust || 0)) + \"px\"\n            });\n            var k = Math.round(c.getBBox(e.useHTML).height);\n            c.align(H({\n              y: \"bottom\" === h ? l : a + l,\n              height: k\n            }, e), !1, \"spacingBox\");\n            e.floating || (\"top\" === h ? b[0] = Math.ceil(b[0] + k) : \"bottom\" === h && (b[2] = Math.ceil(b[2] + k)));\n          }\n        }, this);\n        b[0] && \"top\" === (this.options.title.verticalAlign || \"top\") && (b[0] += this.options.title.margin);\n        b[2] && \"bottom\" === this.options.caption.verticalAlign && (b[2] += this.options.caption.margin);\n        var e = !this.titleOffset || this.titleOffset.join(\",\") !== b.join(\",\");\n        this.titleOffset = b;\n        c(this, \"afterLayOutTitles\");\n        !this.isDirtyBox && e && (this.isDirtyBox = this.isDirtyLegend = e, this.hasRendered && I(a, !0) && this.isDirtyBox && this.redraw());\n      },\n      getChartSize: function () {\n        var a = this.options.chart,\n            b = a.width;\n        a = a.height;\n        var c = this.renderTo;\n        D(b) || (this.containerWidth = l(c, \"width\"));\n        D(a) || (this.containerHeight = l(c, \"height\"));\n        this.chartWidth = Math.max(0, b || this.containerWidth || 600);\n        this.chartHeight = Math.max(0, O(a, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));\n      },\n      temporaryDisplay: function (a) {\n        var b = this.renderTo;\n        if (a) for (; b && b.style;) b.hcOrigStyle && (r(b, b.hcOrigStyle), delete b.hcOrigStyle), b.hcOrigDetached && (T.body.removeChild(b), b.hcOrigDetached = !1), b = b.parentNode;else for (; b && b.style;) {\n          T.body.contains(b) || b.parentNode || (b.hcOrigDetached = !0, T.body.appendChild(b));\n          if (\"none\" === l(b, \"display\", !1) || b.hcOricDetached) b.hcOrigStyle = {\n            display: b.style.display,\n            height: b.style.height,\n            overflow: b.style.overflow\n          }, a = {\n            display: \"block\",\n            overflow: \"hidden\"\n          }, b !== this.renderTo && (a.height = 0), r(b, a), b.offsetWidth || b.style.setProperty(\"display\", \"block\", \"important\");\n          b = b.parentNode;\n          if (b === T.body) break;\n        }\n      },\n      setClassName: function (a) {\n        this.container.className = \"highcharts-container \" + (a || \"\");\n      },\n      getContainer: function () {\n        var b = this.options,\n            d = b.chart;\n        var f = this.renderTo;\n        var h = x(),\n            l,\n            k;\n        f || (this.renderTo = f = d.renderTo);\n        t(f) && (this.renderTo = f = T.getElementById(f));\n        f || m(13, !0, this);\n        var g = S(J(f, \"data-highcharts-chart\"));\n        a(g) && U[g] && U[g].hasRendered && U[g].destroy();\n        J(f, \"data-highcharts-chart\", this.index);\n        f.innerHTML = \"\";\n        d.skipClone || f.offsetWidth || this.temporaryDisplay();\n        this.getChartSize();\n        g = this.chartWidth;\n        var q = this.chartHeight;\n        r(f, {\n          overflow: \"hidden\"\n        });\n        this.styledMode || (l = H({\n          position: \"relative\",\n          overflow: \"hidden\",\n          width: g + \"px\",\n          height: q + \"px\",\n          textAlign: \"left\",\n          lineHeight: \"normal\",\n          zIndex: 0,\n          \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\"\n        }, d.style));\n        this.container = f = z(\"div\", {\n          id: h\n        }, l, f);\n        this._cursor = f.style.cursor;\n        this.renderer = new (e[d.renderer] || e.Renderer)(f, g, q, null, d.forExport, b.exporting && b.exporting.allowHTML, this.styledMode);\n        n(void 0, this);\n        this.setClassName(d.className);\n        if (this.styledMode) for (k in b.defs) this.renderer.definition(b.defs[k]);else this.renderer.setStyle(d.style);\n        this.renderer.chartIndex = this.index;\n        c(this, \"afterGetContainer\");\n      },\n      getMargins: function (a) {\n        var b = this.spacing,\n            d = this.margin,\n            f = this.titleOffset;\n        this.resetMargins();\n        f[0] && !D(d[0]) && (this.plotTop = Math.max(this.plotTop, f[0] + b[0]));\n        f[2] && !D(d[2]) && (this.marginBottom = Math.max(this.marginBottom, f[2] + b[2]));\n        this.legend && this.legend.display && this.legend.adjustMargins(d, b);\n        c(this, \"getMargins\");\n        a || this.getAxisMargins();\n      },\n      getAxisMargins: function () {\n        var a = this,\n            b = a.axisOffset = [0, 0, 0, 0],\n            c = a.colorAxis,\n            d = a.margin,\n            f = function (a) {\n          a.forEach(function (a) {\n            a.visible && a.getOffset();\n          });\n        };\n\n        a.hasCartesianSeries ? f(a.axes) : c && c.length && f(c);\n        q.forEach(function (c, f) {\n          D(d[f]) || (a[c] += b[f]);\n        });\n        a.setChartSize();\n      },\n      reflow: function (a) {\n        var b = this,\n            c = b.options.chart,\n            d = b.renderTo,\n            f = D(c.width) && D(c.height),\n            e = c.width || l(d, \"width\");\n        c = c.height || l(d, \"height\");\n        d = a ? a.target : Z;\n\n        if (!f && !b.isPrinting && e && c && (d === Z || d === T)) {\n          if (e !== b.containerWidth || c !== b.containerHeight) L.clearTimeout(b.reflowTimeout), b.reflowTimeout = B(function () {\n            b.container && b.setSize(void 0, void 0, !1);\n          }, a ? 100 : 0);\n          b.containerWidth = e;\n          b.containerHeight = c;\n        }\n      },\n      setReflow: function (a) {\n        var b = this;\n        !1 === a || this.unbindReflow ? !1 === a && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = E(Z, \"resize\", function (a) {\n          b.options && b.reflow(a);\n        }), E(this, \"destroy\", this.unbindReflow));\n      },\n      setSize: function (a, b, d) {\n        var f = this,\n            e = f.renderer;\n        f.isResizing += 1;\n        n(d, f);\n        f.oldChartHeight = f.chartHeight;\n        f.oldChartWidth = f.chartWidth;\n        \"undefined\" !== typeof a && (f.options.chart.width = a);\n        \"undefined\" !== typeof b && (f.options.chart.height = b);\n        f.getChartSize();\n\n        if (!f.styledMode) {\n          var h = e.globalAnimation;\n          (h ? A : r)(f.container, {\n            width: f.chartWidth + \"px\",\n            height: f.chartHeight + \"px\"\n          }, h);\n        }\n\n        f.setChartSize(!0);\n        e.setSize(f.chartWidth, f.chartHeight, d);\n        f.axes.forEach(function (a) {\n          a.isDirty = !0;\n          a.setScale();\n        });\n        f.isDirtyLegend = !0;\n        f.isDirtyBox = !0;\n        f.layOutTitles();\n        f.getMargins();\n        f.redraw(d);\n        f.oldChartHeight = null;\n        c(f, \"resize\");\n        B(function () {\n          f && c(f, \"endResize\", null, function () {\n            --f.isResizing;\n          });\n        }, C(h).duration || 0);\n      },\n      setChartSize: function (a) {\n        var b = this.inverted,\n            d = this.renderer,\n            f = this.chartWidth,\n            e = this.chartHeight,\n            h = this.options.chart,\n            l = this.spacing,\n            k = this.clipOffset,\n            g,\n            x,\n            q,\n            n;\n        this.plotLeft = g = Math.round(this.plotLeft);\n        this.plotTop = x = Math.round(this.plotTop);\n        this.plotWidth = q = Math.max(0, Math.round(f - g - this.marginRight));\n        this.plotHeight = n = Math.max(0, Math.round(e - x - this.marginBottom));\n        this.plotSizeX = b ? n : q;\n        this.plotSizeY = b ? q : n;\n        this.plotBorderWidth = h.plotBorderWidth || 0;\n        this.spacingBox = d.spacingBox = {\n          x: l[3],\n          y: l[0],\n          width: f - l[3] - l[1],\n          height: e - l[0] - l[2]\n        };\n        this.plotBox = d.plotBox = {\n          x: g,\n          y: x,\n          width: q,\n          height: n\n        };\n        f = 2 * Math.floor(this.plotBorderWidth / 2);\n        b = Math.ceil(Math.max(f, k[3]) / 2);\n        d = Math.ceil(Math.max(f, k[0]) / 2);\n        this.clipBox = {\n          x: b,\n          y: d,\n          width: Math.floor(this.plotSizeX - Math.max(f, k[1]) / 2 - b),\n          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(f, k[2]) / 2 - d))\n        };\n        a || this.axes.forEach(function (a) {\n          a.setAxisSize();\n          a.setAxisTranslation();\n        });\n        c(this, \"afterSetChartSize\", {\n          skipAxes: a\n        });\n      },\n      resetMargins: function () {\n        c(this, \"resetMargins\");\n        var a = this,\n            b = a.options.chart;\n        [\"margin\", \"spacing\"].forEach(function (c) {\n          var d = b[c],\n              f = k(d) ? d : [d, d, d, d];\n          [\"Top\", \"Right\", \"Bottom\", \"Left\"].forEach(function (d, e) {\n            a[c][e] = I(b[c + d], f[e]);\n          });\n        });\n        q.forEach(function (b, c) {\n          a[b] = I(a.margin[c], a.spacing[c]);\n        });\n        a.axisOffset = [0, 0, 0, 0];\n        a.clipOffset = [0, 0, 0, 0];\n      },\n      drawChartBox: function () {\n        var a = this.options.chart,\n            b = this.renderer,\n            d = this.chartWidth,\n            f = this.chartHeight,\n            e = this.chartBackground,\n            h = this.plotBackground,\n            l = this.plotBorder,\n            k = this.styledMode,\n            g = this.plotBGImage,\n            x = a.backgroundColor,\n            q = a.plotBackgroundColor,\n            n = a.plotBackgroundImage,\n            t,\n            m = this.plotLeft,\n            B = this.plotTop,\n            y = this.plotWidth,\n            r = this.plotHeight,\n            w = this.plotBox,\n            v = this.clipRect,\n            P = this.clipBox,\n            z = \"animate\";\n        e || (this.chartBackground = e = b.rect().addClass(\"highcharts-background\").add(), z = \"attr\");\n        if (k) var F = t = e.strokeWidth();else {\n          F = a.borderWidth || 0;\n          t = F + (a.shadow ? 8 : 0);\n          x = {\n            fill: x || \"none\"\n          };\n          if (F || e[\"stroke-width\"]) x.stroke = a.borderColor, x[\"stroke-width\"] = F;\n          e.attr(x).shadow(a.shadow);\n        }\n        e[z]({\n          x: t / 2,\n          y: t / 2,\n          width: d - t - F % 2,\n          height: f - t - F % 2,\n          r: a.borderRadius\n        });\n        z = \"animate\";\n        h || (z = \"attr\", this.plotBackground = h = b.rect().addClass(\"highcharts-plot-background\").add());\n        h[z](w);\n        k || (h.attr({\n          fill: q || \"none\"\n        }).shadow(a.plotShadow), n && (g ? (n !== g.attr(\"href\") && g.attr(\"href\", n), g.animate(w)) : this.plotBGImage = b.image(n, m, B, y, r).add()));\n        v ? v.animate({\n          width: P.width,\n          height: P.height\n        }) : this.clipRect = b.clipRect(P);\n        z = \"animate\";\n        l || (z = \"attr\", this.plotBorder = l = b.rect().addClass(\"highcharts-plot-border\").attr({\n          zIndex: 1\n        }).add());\n        k || l.attr({\n          stroke: a.plotBorderColor,\n          \"stroke-width\": a.plotBorderWidth || 0,\n          fill: \"none\"\n        });\n        l[z](l.crisp({\n          x: m,\n          y: B,\n          width: y,\n          height: r\n        }, -l.strokeWidth()));\n        this.isDirtyBox = !1;\n        c(this, \"afterDrawChartBox\");\n      },\n      propFromSeries: function () {\n        var a = this,\n            b = a.options.chart,\n            c,\n            d = a.options.series,\n            f,\n            e;\n        [\"inverted\", \"angular\", \"polar\"].forEach(function (h) {\n          c = Q[b.type || b.defaultSeriesType];\n          e = b[h] || c && c.prototype[h];\n\n          for (f = d && d.length; !e && f--;) (c = Q[d[f].type]) && c.prototype[h] && (e = !0);\n\n          a[h] = e;\n        });\n      },\n      linkSeries: function () {\n        var a = this,\n            b = a.series;\n        b.forEach(function (a) {\n          a.linkedSeries.length = 0;\n        });\n        b.forEach(function (b) {\n          var c = b.options.linkedTo;\n          t(c) && (c = \":previous\" === c ? a.series[b.index - 1] : a.get(c)) && c.linkedParent !== b && (c.linkedSeries.push(b), b.linkedParent = c, c.enabledDataSorting && b.setDataSortingOptions(), b.visible = I(b.options.visible, c.options.visible, b.visible));\n        });\n        c(this, \"afterLinkSeries\");\n      },\n      renderSeries: function () {\n        this.series.forEach(function (a) {\n          a.translate();\n          a.render();\n        });\n      },\n      renderLabels: function () {\n        var a = this,\n            b = a.options.labels;\n        b.items && b.items.forEach(function (c) {\n          var d = H(b.style, c.style),\n              f = S(d.left) + a.plotLeft,\n              e = S(d.top) + a.plotTop + 12;\n          delete d.left;\n          delete d.top;\n          a.renderer.text(c.html, f, e).attr({\n            zIndex: 2\n          }).css(d).add();\n        });\n      },\n      render: function () {\n        var a = this.axes,\n            b = this.colorAxis,\n            c = this.renderer,\n            d = this.options,\n            f = 0,\n            e = function (a) {\n          a.forEach(function (a) {\n            a.visible && a.render();\n          });\n        };\n\n        this.setTitle();\n        this.legend = new g(this, d.legend);\n        this.getStacks && this.getStacks();\n        this.getMargins(!0);\n        this.setChartSize();\n        d = this.plotWidth;\n        a.some(function (a) {\n          if (a.horiz && a.visible && a.options.labels.enabled && a.series.length) return f = 21, !0;\n        });\n        var h = this.plotHeight = Math.max(this.plotHeight - f, 0);\n        a.forEach(function (a) {\n          a.setScale();\n        });\n        this.getAxisMargins();\n        var l = 1.1 < d / this.plotWidth;\n        var k = 1.05 < h / this.plotHeight;\n        if (l || k) a.forEach(function (a) {\n          (a.horiz && l || !a.horiz && k) && a.setTickInterval(!0);\n        }), this.getMargins();\n        this.drawChartBox();\n        this.hasCartesianSeries ? e(a) : b && b.length && e(b);\n        this.seriesGroup || (this.seriesGroup = c.g(\"series-group\").attr({\n          zIndex: 3\n        }).add());\n        this.renderSeries();\n        this.renderLabels();\n        this.addCredits();\n        this.setResponsive && this.setResponsive();\n        this.updateContainerScaling();\n        this.hasRendered = !0;\n      },\n      addCredits: function (a) {\n        var b = this;\n        a = w(!0, this.options.credits, a);\n        a.enabled && !this.credits && (this.credits = this.renderer.text(a.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function () {\n          a.href && (Z.location.href = a.href);\n        }).attr({\n          align: a.position.align,\n          zIndex: 8\n        }), b.styledMode || this.credits.css(a.style), this.credits.add().align(a.position), this.credits.update = function (a) {\n          b.credits = b.credits.destroy();\n          b.addCredits(a);\n        });\n      },\n      updateContainerScaling: function () {\n        var a = this.container;\n\n        if (a.offsetWidth && a.offsetHeight && a.getBoundingClientRect) {\n          var b = a.getBoundingClientRect(),\n              c = b.width / a.offsetWidth;\n          a = b.height / a.offsetHeight;\n          1 !== c || 1 !== a ? this.containerScaling = {\n            scaleX: c,\n            scaleY: a\n          } : delete this.containerScaling;\n        }\n      },\n      destroy: function () {\n        var a = this,\n            b = a.axes,\n            d = a.series,\n            f = a.container,\n            h,\n            l = f && f.parentNode;\n        c(a, \"destroy\");\n        a.renderer.forExport ? v(U, a) : U[a.index] = void 0;\n        e.chartCount--;\n        a.renderTo.removeAttribute(\"data-highcharts-chart\");\n        N(a);\n\n        for (h = b.length; h--;) b[h] = b[h].destroy();\n\n        this.scroller && this.scroller.destroy && this.scroller.destroy();\n\n        for (h = d.length; h--;) d[h] = d[h].destroy();\n\n        \"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer\".split(\" \").forEach(function (b) {\n          var c = a[b];\n          c && c.destroy && (a[b] = c.destroy());\n        });\n        f && (f.innerHTML = \"\", N(f), l && M(f));\n        F(a, function (b, c) {\n          delete a[c];\n        });\n      },\n      firstRender: function () {\n        var a = this,\n            b = a.options;\n\n        if (!a.isReadyToRender || a.isReadyToRender()) {\n          a.getContainer();\n          a.resetMargins();\n          a.setChartSize();\n          a.propFromSeries();\n          a.getAxes();\n          (h(b.series) ? b.series : []).forEach(function (b) {\n            a.initSeries(b);\n          });\n          a.linkSeries();\n          a.setSeriesData();\n          c(a, \"beforeRender\");\n          u && (a.pointer = e.hasTouch || !Z.PointerEvent && !Z.MSPointerEvent ? new u(a, b) : new p(a, b));\n          a.render();\n          if (!a.renderer.imgCount && !a.hasLoaded) a.onload();\n          a.temporaryDisplay(!0);\n        }\n      },\n      onload: function () {\n        this.callbacks.concat([this.callback]).forEach(function (a) {\n          a && \"undefined\" !== typeof this.index && a.apply(this, [this]);\n        }, this);\n        c(this, \"load\");\n        c(this, \"render\");\n        D(this.index) && this.setReflow(this.options.chart.reflow);\n        this.hasLoaded = !0;\n      }\n    });\n  });\n  R(p, \"parts/ScrollablePlotArea.js\", [p[\"parts/Globals.js\"], p[\"parts/Utilities.js\"]], function (e, g) {\n    var p = g.addEvent,\n        u = g.createElement,\n        K = g.pick,\n        L = g.stop;\n    g = e.Chart;\n    \"\";\n    p(g, \"afterSetChartSize\", function (g) {\n      var u = this.options.chart.scrollablePlotArea,\n          p = u && u.minWidth;\n      u = u && u.minHeight;\n\n      if (!this.renderer.forExport) {\n        if (p) {\n          if (this.scrollablePixelsX = p = Math.max(0, p - this.chartWidth)) {\n            this.plotWidth += p;\n            this.inverted ? (this.clipBox.height += p, this.plotBox.height += p) : (this.clipBox.width += p, this.plotBox.width += p);\n            var E = {\n              1: {\n                name: \"right\",\n                value: p\n              }\n            };\n          }\n        } else u && (this.scrollablePixelsY = p = Math.max(0, u - this.chartHeight)) && (this.plotHeight += p, this.inverted ? (this.clipBox.width += p, this.plotBox.width += p) : (this.clipBox.height += p, this.plotBox.height += p), E = {\n          2: {\n            name: \"bottom\",\n            value: p\n          }\n        });\n\n        E && !g.skipAxes && this.axes.forEach(function (g) {\n          E[g.side] ? g.getPlotLinePath = function () {\n            var r = E[g.side].name,\n                z = this[r];\n            this[r] = z - E[g.side].value;\n            var u = e.Axis.prototype.getPlotLinePath.apply(this, arguments);\n            this[r] = z;\n            return u;\n          } : (g.setAxisSize(), g.setAxisTranslation());\n        });\n      }\n    });\n    p(g, \"render\", function () {\n      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();\n    });\n\n    g.prototype.setUpScrolling = function () {\n      var e = this,\n          g = {\n        WebkitOverflowScrolling: \"touch\",\n        overflowX: \"hidden\",\n        overflowY: \"hidden\"\n      };\n      this.scrollablePixelsX && (g.overflowX = \"auto\");\n      this.scrollablePixelsY && (g.overflowY = \"auto\");\n      this.scrollingContainer = u(\"div\", {\n        className: \"highcharts-scrolling\"\n      }, g, this.renderTo);\n      p(this.scrollingContainer, \"scroll\", function () {\n        e.pointer && delete e.pointer.chartPosition;\n      });\n      this.innerContainer = u(\"div\", {\n        className: \"highcharts-inner-container\"\n      }, null, this.scrollingContainer);\n      this.innerContainer.appendChild(this.container);\n      this.setUpScrolling = null;\n    };\n\n    g.prototype.moveFixedElements = function () {\n      var e = this.container,\n          g = this.fixedRenderer,\n          u = \".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-scrollbar .highcharts-subtitle .highcharts-title\".split(\" \"),\n          p;\n      this.scrollablePixelsX && !this.inverted ? p = \".highcharts-yaxis\" : this.scrollablePixelsX && this.inverted ? p = \".highcharts-xaxis\" : this.scrollablePixelsY && !this.inverted ? p = \".highcharts-xaxis\" : this.scrollablePixelsY && this.inverted && (p = \".highcharts-yaxis\");\n      u.push(p, p + \"-labels\");\n      u.forEach(function (z) {\n        [].forEach.call(e.querySelectorAll(z), function (e) {\n          (e.namespaceURI === g.SVG_NS ? g.box : g.box.parentNode).appendChild(e);\n          e.style.pointerEvents = \"auto\";\n        });\n      });\n    };\n\n    g.prototype.applyFixed = function () {\n      var g,\n          A = !this.fixedDiv,\n          C = this.options.chart.scrollablePlotArea;\n      A ? (this.fixedDiv = u(\"div\", {\n        className: \"highcharts-fixed\"\n      }, {\n        position: \"absolute\",\n        overflow: \"hidden\",\n        pointerEvents: \"none\",\n        zIndex: 2\n      }, null, !0), this.renderTo.insertBefore(this.fixedDiv, this.renderTo.firstChild), this.renderTo.style.overflow = \"visible\", this.fixedRenderer = g = new e.Renderer(this.fixedDiv, this.chartWidth, this.chartHeight), this.scrollableMask = g.path().attr({\n        fill: this.options.chart.backgroundColor || \"#fff\",\n        \"fill-opacity\": K(C.opacity, .85),\n        zIndex: -1\n      }).addClass(\"highcharts-scrollable-mask\").add(), this.moveFixedElements(), p(this, \"afterShowResetZoom\", this.moveFixedElements), p(this, \"afterLayOutTitles\", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);\n      g = this.chartWidth + (this.scrollablePixelsX || 0);\n      var J = this.chartHeight + (this.scrollablePixelsY || 0);\n      L(this.container);\n      this.container.style.width = g + \"px\";\n      this.container.style.height = J + \"px\";\n      this.renderer.boxWrapper.attr({\n        width: g,\n        height: J,\n        viewBox: [0, 0, g, J].join(\" \")\n      });\n      this.chartBackground.attr({\n        width: g,\n        height: J\n      });\n      this.scrollablePixelsY && (this.scrollingContainer.style.height = this.chartHeight + \"px\");\n      A && (C.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * C.scrollPositionX), C.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * C.scrollPositionY));\n      J = this.axisOffset;\n      A = this.plotTop - J[0] - 1;\n      C = this.plotLeft - J[3] - 1;\n      g = this.plotTop + this.plotHeight + J[2] + 1;\n      J = this.plotLeft + this.plotWidth + J[1] + 1;\n      var z = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),\n          r = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);\n      A = this.scrollablePixelsX ? [\"M\", 0, A, \"L\", this.plotLeft - 1, A, \"L\", this.plotLeft - 1, g, \"L\", 0, g, \"Z\", \"M\", z, A, \"L\", this.chartWidth, A, \"L\", this.chartWidth, g, \"L\", z, g, \"Z\"] : this.scrollablePixelsY ? [\"M\", C, 0, \"L\", C, this.plotTop - 1, \"L\", J, this.plotTop - 1, \"L\", J, 0, \"Z\", \"M\", C, r, \"L\", C, this.chartHeight, \"L\", J, this.chartHeight, \"L\", J, r, \"Z\"] : [\"M\", 0, 0];\n      \"adjustHeight\" !== this.redrawTrigger && this.scrollableMask.attr({\n        d: A\n      });\n    };\n  });\n  R(p, \"mixins/legend-symbol.js\", [p[\"parts/Globals.js\"], p[\"parts/Utilities.js\"]], function (e, g) {\n    var p = g.merge,\n        u = g.pick;\n    e.LegendSymbolMixin = {\n      drawRectangle: function (e, g) {\n        var p = e.symbolHeight,\n            A = e.options.squareSymbol;\n        g.legendSymbol = this.chart.renderer.rect(A ? (e.symbolWidth - p) / 2 : 0, e.baseline - p + 1, A ? p : e.symbolWidth, p, u(e.options.symbolRadius, p / 2)).addClass(\"highcharts-point\").attr({\n          zIndex: 3\n        }).add(g.legendGroup);\n      },\n      drawLineMarker: function (e) {\n        var g = this.options,\n            E = g.marker,\n            A = e.symbolWidth,\n            C = e.symbolHeight,\n            J = C / 2,\n            z = this.chart.renderer,\n            r = this.legendGroup;\n        e = e.baseline - Math.round(.3 * e.fontMetrics.b);\n        var D = {};\n        this.chart.styledMode || (D = {\n          \"stroke-width\": g.lineWidth || 0\n        }, g.dashStyle && (D.dashstyle = g.dashStyle));\n        this.legendLine = z.path([\"M\", 0, e, \"L\", A, e]).addClass(\"highcharts-graph\").attr(D).add(r);\n        E && !1 !== E.enabled && A && (g = Math.min(u(E.radius, J), J), 0 === this.symbol.indexOf(\"url\") && (E = p(E, {\n          width: C,\n          height: C\n        }), g = 0), this.legendSymbol = E = z.symbol(this.symbol, A / 2 - g, e - g, 2 * g, 2 * g, E).addClass(\"highcharts-point\").add(r), E.isMarker = !0);\n      }\n    };\n    return e.LegendSymbolMixin;\n  });\n  R(p, \"parts/Point.js\", [p[\"parts/Globals.js\"], p[\"parts/Utilities.js\"]], function (e, g) {\n    \"\";\n\n    var p = g.animObject,\n        u = g.defined,\n        K = g.erase,\n        L = g.extend,\n        E = g.format,\n        A = g.getNestedProperty,\n        C = g.isArray,\n        J = g.isNumber,\n        z = g.isObject,\n        r = g.syncTimeout,\n        D = g.pick,\n        M = g.removeEvent,\n        v = g.uniqueKey,\n        m = e.fireEvent;\n\n    g = function () {\n      function e() {\n        this.colorIndex = this.category = void 0;\n        this.formatPrefix = \"point\";\n        this.id = void 0;\n        this.isNull = !1;\n        this.percentage = this.options = this.name = void 0;\n        this.selected = !1;\n        this.total = this.series = void 0;\n        this.visible = !0;\n        this.x = void 0;\n      }\n\n      e.prototype.animateBeforeDestroy = function () {\n        var f = this,\n            c = {\n          x: f.startXPos,\n          opacity: 0\n        },\n            e,\n            h = f.getGraphicalProps();\n        h.singular.forEach(function (d) {\n          e = \"dataLabel\" === d;\n          f[d] = f[d].animate(e ? {\n            x: f[d].startXPos,\n            y: f[d].startYPos,\n            opacity: 0\n          } : c);\n        });\n        h.plural.forEach(function (c) {\n          f[c].forEach(function (a) {\n            a.element && a.animate(L({\n              x: f.startXPos\n            }, a.startYPos ? {\n              x: a.startXPos,\n              y: a.startYPos\n            } : {}));\n          });\n        });\n      };\n\n      e.prototype.applyOptions = function (f, c) {\n        var l = this.series,\n            h = l.options.pointValKey || l.pointValKey;\n        f = e.prototype.optionsToObject.call(this, f);\n        L(this, f);\n        this.options = this.options ? L(this.options, f) : f;\n        f.group && delete this.group;\n        f.dataLabels && delete this.dataLabels;\n        h && (this.y = e.prototype.getNestedProperty.call(this, h));\n        this.formatPrefix = (this.isNull = D(this.isValid && !this.isValid(), null === this.x || !J(this.y))) ? \"null\" : \"point\";\n        this.selected && (this.state = \"select\");\n        \"name\" in this && \"undefined\" === typeof c && l.xAxis && l.xAxis.hasNames && (this.x = l.xAxis.nameToX(this));\n        \"undefined\" === typeof this.x && l && (this.x = \"undefined\" === typeof c ? l.autoIncrement(this) : c);\n        return this;\n      };\n\n      e.prototype.destroy = function () {\n        function f() {\n          if (c.graphic || c.dataLabel || c.dataLabels) M(c), c.destroyElements();\n\n          for (g in c) c[g] = null;\n        }\n\n        var c = this,\n            e = c.series,\n            h = e.chart;\n        e = e.options.dataSorting;\n        var d = h.hoverPoints,\n            a = p(c.series.chart.renderer.globalAnimation),\n            g;\n        c.legendItem && h.legend.destroyItem(c);\n        d && (c.setState(), K(d, c), d.length || (h.hoverPoints = null));\n        if (c === h.hoverPoint) c.onMouseOut();\n        e && e.enabled ? (this.animateBeforeDestroy(), r(f, a.duration)) : f();\n        h.pointCount--;\n      };\n\n      e.prototype.destroyElements = function (f) {\n        var c = this;\n        f = c.getGraphicalProps(f);\n        f.singular.forEach(function (f) {\n          c[f] = c[f].destroy();\n        });\n        f.plural.forEach(function (f) {\n          c[f].forEach(function (c) {\n            c.element && c.destroy();\n          });\n          delete c[f];\n        });\n      };\n\n      e.prototype.firePointEvent = function (f, c, e) {\n        var h = this,\n            d = this.series.options;\n        (d.point.events[f] || h.options && h.options.events && h.options.events[f]) && h.importEvents();\n        \"click\" === f && d.allowPointSelect && (e = function (a) {\n          h.select && h.select(null, a.ctrlKey || a.metaKey || a.shiftKey);\n        });\n        m(h, f, c, e);\n      };\n\n      e.prototype.getClassName = function () {\n        return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (\"undefined\" !== typeof this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n      };\n\n      e.prototype.getGraphicalProps = function (f) {\n        var c = this,\n            e = [],\n            h,\n            d = {\n          singular: [],\n          plural: []\n        };\n        f = f || {\n          graphic: 1,\n          dataLabel: 1\n        };\n        f.graphic && e.push(\"graphic\", \"shadowGroup\");\n        f.dataLabel && e.push(\"dataLabel\", \"dataLabelUpper\", \"connector\");\n\n        for (h = e.length; h--;) {\n          var a = e[h];\n          c[a] && d.singular.push(a);\n        }\n\n        [\"dataLabel\", \"connector\"].forEach(function (a) {\n          var e = a + \"s\";\n          f[a] && c[e] && d.plural.push(e);\n        });\n        return d;\n      };\n\n      e.prototype.getLabelConfig = function () {\n        return {\n          x: this.category,\n          y: this.y,\n          color: this.color,\n          colorIndex: this.colorIndex,\n          key: this.name || this.category,\n          series: this.series,\n          point: this,\n          percentage: this.percentage,\n          total: this.total || this.stackTotal\n        };\n      };\n\n      e.prototype.getNestedProperty = function (f) {\n        if (f) return 0 === f.indexOf(\"custom.\") ? A(f, this.options) : this[f];\n      };\n\n      e.prototype.getZone = function () {\n        var f = this.series,\n            c = f.zones;\n        f = f.zoneAxis || \"y\";\n        var e = 0,\n            h;\n\n        for (h = c[e]; this[f] >= h.value;) h = c[++e];\n\n        this.nonZonedColor || (this.nonZonedColor = this.color);\n        this.color = h && h.color && !this.options.color ? h.color : this.nonZonedColor;\n        return h;\n      };\n\n      e.prototype.hasNewShapeType = function () {\n        return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;\n      };\n\n      e.prototype.init = function (f, c, e) {\n        this.series = f;\n        this.applyOptions(c, e);\n        this.id = u(this.id) ? this.id : v();\n        this.resolveColor();\n        f.chart.pointCount++;\n        m(this, \"afterInit\");\n        return this;\n      };\n\n      e.prototype.optionsToObject = function (f) {\n        var c = {},\n            g = this.series,\n            h = g.options.keys,\n            d = h || g.pointArrayMap || [\"y\"],\n            a = d.length,\n            k = 0,\n            t = 0;\n        if (J(f) || null === f) c[d[0]] = f;else if (C(f)) for (!h && f.length > a && (g = typeof f[0], \"string\" === g ? c.name = f[0] : \"number\" === g && (c.x = f[0]), k++); t < a;) h && \"undefined\" === typeof f[k] || (0 < d[t].indexOf(\".\") ? e.prototype.setNestedProperty(c, f[k], d[t]) : c[d[t]] = f[k]), k++, t++;else \"object\" === typeof f && (c = f, f.dataLabels && (g._hasPointLabels = !0), f.marker && (g._hasPointMarkers = !0));\n        return c;\n      };\n\n      e.prototype.resolveColor = function () {\n        var f = this.series;\n        var c = f.chart.options.chart.colorCount;\n        var e = f.chart.styledMode;\n        e || this.options.color || (this.color = f.color);\n        f.options.colorByPoint ? (e || (c = f.options.colors || f.chart.options.colors, this.color = this.color || c[f.colorCounter], c = c.length), e = f.colorCounter, f.colorCounter++, f.colorCounter === c && (f.colorCounter = 0)) : e = f.colorIndex;\n        this.colorIndex = D(this.colorIndex, e);\n      };\n\n      e.prototype.setNestedProperty = function (f, c, e) {\n        e.split(\".\").reduce(function (f, d, a, e) {\n          f[d] = e.length - 1 === a ? c : z(f[d], !0) ? f[d] : {};\n          return f[d];\n        }, f);\n        return f;\n      };\n\n      e.prototype.tooltipFormatter = function (f) {\n        var c = this.series,\n            e = c.tooltipOptions,\n            h = D(e.valueDecimals, \"\"),\n            d = e.valuePrefix || \"\",\n            a = e.valueSuffix || \"\";\n        c.chart.styledMode && (f = c.chart.tooltip.styledModeFormat(f));\n        (c.pointArrayMap || [\"y\"]).forEach(function (c) {\n          c = \"{point.\" + c;\n          if (d || a) f = f.replace(RegExp(c + \"}\", \"g\"), d + c + \"}\" + a);\n          f = f.replace(RegExp(c + \"}\", \"g\"), c + \":,.\" + h + \"f}\");\n        });\n        return E(f, {\n          point: this,\n          series: this.series\n        }, c.chart);\n      };\n\n      return e;\n    }();\n\n    e.Point = g;\n    return e.Point;\n  });\n  R(p, \"parts/Series.js\", [p[\"parts/Globals.js\"], p[\"mixins/legend-symbol.js\"], p[\"parts/Point.js\"], p[\"parts/Utilities.js\"]], function (e, g, p, u) {\n    \"\";\n\n    var K = u.addEvent,\n        L = u.animObject,\n        E = u.arrayMax,\n        A = u.arrayMin,\n        C = u.clamp,\n        J = u.correctFloat,\n        z = u.defined,\n        r = u.erase,\n        D = u.error,\n        M = u.extend,\n        v = u.find,\n        m = u.fireEvent,\n        H = u.getNestedProperty,\n        f = u.isArray,\n        c = u.isFunction,\n        l = u.isNumber,\n        h = u.isString,\n        d = u.merge,\n        a = u.objectEach,\n        k = u.pick,\n        t = u.removeEvent,\n        w = u.seriesType,\n        y = u.splat,\n        F = u.syncTimeout,\n        I = e.defaultOptions,\n        S = e.defaultPlotOptions,\n        O = e.seriesTypes,\n        N = e.SVGElement,\n        n = e.win;\n    e.Series = w(\"line\", null, {\n      lineWidth: 2,\n      allowPointSelect: !1,\n      showCheckbox: !1,\n      animation: {\n        duration: 1E3\n      },\n      events: {},\n      marker: {\n        enabledThreshold: 2,\n        lineColor: \"#ffffff\",\n        lineWidth: 0,\n        radius: 4,\n        states: {\n          normal: {\n            animation: !0\n          },\n          hover: {\n            animation: {\n              duration: 50\n            },\n            enabled: !0,\n            radiusPlus: 2,\n            lineWidthPlus: 1\n          },\n          select: {\n            fillColor: \"#cccccc\",\n            lineColor: \"#000000\",\n            lineWidth: 2\n          }\n        }\n      },\n      point: {\n        events: {}\n      },\n      dataLabels: {\n        align: \"center\",\n        formatter: function () {\n          var a = this.series.chart.numberFormatter;\n          return \"number\" !== typeof this.y ? \"\" : a(this.y, -1);\n        },\n        padding: 5,\n        style: {\n          fontSize: \"11px\",\n          fontWeight: \"bold\",\n          color: \"contrast\",\n          textOutline: \"1px contrast\"\n        },\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0\n      },\n      cropThreshold: 300,\n      opacity: 1,\n      pointRange: 0,\n      softThreshold: !0,\n      states: {\n        normal: {\n          animation: !0\n        },\n        hover: {\n          animation: {\n            duration: 50\n          },\n          lineWidthPlus: 1,\n          marker: {},\n          halo: {\n            size: 10,\n            opacity: .25\n          }\n        },\n        select: {\n          animation: {\n            duration: 0\n          }\n        },\n        inactive: {\n          animation: {\n            duration: 50\n          },\n          opacity: .2\n        }\n      },\n      stickyTracking: !0,\n      turboThreshold: 1E3,\n      findNearestPointBy: \"x\"\n    }, {\n      axisTypes: [\"xAxis\", \"yAxis\"],\n      coll: \"series\",\n      colorCounter: 0,\n      cropShoulder: 1,\n      directTouch: !1,\n      eventsToUnbind: [],\n      isCartesian: !0,\n      parallelArrays: [\"x\", \"y\"],\n      pointClass: p,\n      requireSorting: !0,\n      sorted: !0,\n      init: function (b, d) {\n        m(this, \"init\", {\n          options: d\n        });\n        var f = this,\n            e = b.series,\n            h;\n        this.eventOptions = this.eventOptions || {};\n        f.chart = b;\n        f.options = d = f.setOptions(d);\n        f.linkedSeries = [];\n        f.bindAxes();\n        M(f, {\n          name: d.name,\n          state: \"\",\n          visible: !1 !== d.visible,\n          selected: !0 === d.selected\n        });\n        var g = d.events;\n        a(g, function (a, b) {\n          c(a) && f.eventOptions[b] !== a && (c(f.eventOptions[b]) && t(f, b, f.eventOptions[b]), f.eventOptions[b] = a, K(f, b, a));\n        });\n        if (g && g.click || d.point && d.point.events && d.point.events.click || d.allowPointSelect) b.runTrackerClick = !0;\n        f.getColor();\n        f.getSymbol();\n        f.parallelArrays.forEach(function (a) {\n          f[a + \"Data\"] || (f[a + \"Data\"] = []);\n        });\n        f.isCartesian && (b.hasCartesianSeries = !0);\n        e.length && (h = e[e.length - 1]);\n        f._i = k(h && h._i, -1) + 1;\n        b.orderSeries(this.insert(e));\n        d.dataSorting && d.dataSorting.enabled ? f.setDataSortingOptions() : f.points || f.data || f.setData(d.data, !1);\n        m(this, \"afterInit\");\n      },\n      is: function (a) {\n        return O[a] && this instanceof O[a];\n      },\n      insert: function (a) {\n        var b = this.options.index,\n            c;\n\n        if (l(b)) {\n          for (c = a.length; c--;) if (b >= k(a[c].options.index, a[c]._i)) {\n            a.splice(c + 1, 0, this);\n            break;\n          }\n\n          -1 === c && a.unshift(this);\n          c += 1;\n        } else a.push(this);\n\n        return k(c, a.length - 1);\n      },\n      bindAxes: function () {\n        var a = this,\n            c = a.options,\n            d = a.chart,\n            f;\n        m(this, \"bindAxes\", null, function () {\n          (a.axisTypes || []).forEach(function (b) {\n            d[b].forEach(function (d) {\n              f = d.options;\n              if (c[b] === f.index || \"undefined\" !== typeof c[b] && c[b] === f.id || \"undefined\" === typeof c[b] && 0 === f.index) a.insert(d.series), a[b] = d, d.isDirty = !0;\n            });\n            a[b] || a.optionalAxis === b || D(18, !0, d);\n          });\n        });\n        m(this, \"afterBindAxes\");\n      },\n      updateParallelArrays: function (a, c) {\n        var b = a.series,\n            d = arguments,\n            f = l(c) ? function (d) {\n          var f = \"y\" === d && b.toYData ? b.toYData(a) : a[d];\n          b[d + \"Data\"][c] = f;\n        } : function (a) {\n          Array.prototype[c].apply(b[a + \"Data\"], Array.prototype.slice.call(d, 2));\n        };\n        b.parallelArrays.forEach(f);\n      },\n      hasData: function () {\n        return this.visible && \"undefined\" !== typeof this.dataMax && \"undefined\" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;\n      },\n      autoIncrement: function () {\n        var a = this.options,\n            c = this.xIncrement,\n            d,\n            f = a.pointIntervalUnit,\n            e = this.chart.time;\n        c = k(c, a.pointStart, 0);\n        this.pointInterval = d = k(this.pointInterval, a.pointInterval, 1);\n        f && (a = new e.Date(c), \"day\" === f ? e.set(\"Date\", a, e.get(\"Date\", a) + d) : \"month\" === f ? e.set(\"Month\", a, e.get(\"Month\", a) + d) : \"year\" === f && e.set(\"FullYear\", a, e.get(\"FullYear\", a) + d), d = a.getTime() - c);\n        this.xIncrement = c + d;\n        return c;\n      },\n      setDataSortingOptions: function () {\n        var a = this.options;\n        M(this, {\n          requireSorting: !1,\n          sorted: !1,\n          enabledDataSorting: !0,\n          allowDG: !1\n        });\n        z(a.pointRange) || (a.pointRange = 1);\n      },\n      setOptions: function (a) {\n        var b = this.chart,\n            c = b.options,\n            f = c.plotOptions,\n            e = b.userOptions || {};\n        a = d(a);\n        b = b.styledMode;\n        var h = {\n          plotOptions: f,\n          userOptions: a\n        };\n        m(this, \"setOptions\", h);\n        var g = h.plotOptions[this.type],\n            l = e.plotOptions || {};\n        this.userOptions = h.userOptions;\n        e = d(g, f.series, e.plotOptions && e.plotOptions[this.type], a);\n        this.tooltipOptions = d(I.tooltip, I.plotOptions.series && I.plotOptions.series.tooltip, I.plotOptions[this.type].tooltip, c.tooltip.userOptions, f.series && f.series.tooltip, f[this.type].tooltip, a.tooltip);\n        this.stickyTracking = k(a.stickyTracking, l[this.type] && l[this.type].stickyTracking, l.series && l.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : e.stickyTracking);\n        null === g.marker && delete e.marker;\n        this.zoneAxis = e.zoneAxis;\n        c = this.zones = (e.zones || []).slice();\n        !e.negativeColor && !e.negativeFillColor || e.zones || (f = {\n          value: e[this.zoneAxis + \"Threshold\"] || e.threshold || 0,\n          className: \"highcharts-negative\"\n        }, b || (f.color = e.negativeColor, f.fillColor = e.negativeFillColor), c.push(f));\n        c.length && z(c[c.length - 1].value) && c.push(b ? {} : {\n          color: this.color,\n          fillColor: this.fillColor\n        });\n        m(this, \"afterSetOptions\", {\n          options: e\n        });\n        return e;\n      },\n      getName: function () {\n        return k(this.options.name, \"Series \" + (this.index + 1));\n      },\n      getCyclic: function (a, c, d) {\n        var b = this.chart,\n            f = this.userOptions,\n            e = a + \"Index\",\n            h = a + \"Counter\",\n            g = d ? d.length : k(b.options.chart[a + \"Count\"], b[a + \"Count\"]);\n\n        if (!c) {\n          var l = k(f[e], f[\"_\" + e]);\n          z(l) || (b.series.length || (b[h] = 0), f[\"_\" + e] = l = b[h] % g, b[h] += 1);\n          d && (c = d[l]);\n        }\n\n        \"undefined\" !== typeof l && (this[e] = l);\n        this[a] = c;\n      },\n      getColor: function () {\n        this.chart.styledMode ? this.getCyclic(\"color\") : this.options.colorByPoint ? this.options.color = null : this.getCyclic(\"color\", this.options.color || S[this.type].color, this.chart.options.colors);\n      },\n      getPointsCollection: function () {\n        return (this.hasGroupedData ? this.points : this.data) || [];\n      },\n      getSymbol: function () {\n        this.getCyclic(\"symbol\", this.options.marker.symbol, this.chart.options.symbols);\n      },\n      findPointIndex: function (a, c) {\n        var b = a.id,\n            d = a.x,\n            f = this.points,\n            e,\n            h = this.options.dataSorting;\n        if (b) var g = this.chart.get(b);else if (this.linkedParent || this.enabledDataSorting) {\n          var k = h && h.matchByName ? \"name\" : \"index\";\n          g = v(f, function (b) {\n            return !b.touched && b[k] === a[k];\n          });\n          if (!g) return;\n        }\n\n        if (g) {\n          var n = g && g.index;\n          \"undefined\" !== typeof n && (e = !0);\n        }\n\n        \"undefined\" === typeof n && l(d) && (n = this.xData.indexOf(d, c));\n        -1 !== n && \"undefined\" !== typeof n && this.cropped && (n = n >= this.cropStart ? n - this.cropStart : n);\n        !e && f[n] && f[n].touched && (n = void 0);\n        return n;\n      },\n      drawLegendSymbol: g.drawLineMarker,\n      updateData: function (a, c) {\n        var b = this.options,\n            d = b.dataSorting,\n            f = this.points,\n            e = [],\n            h,\n            g,\n            k,\n            n = this.requireSorting,\n            t = a.length === f.length,\n            m = !0;\n        this.xIncrement = null;\n        a.forEach(function (a, c) {\n          var g = z(a) && this.pointClass.prototype.optionsToObject.call({\n            series: this\n          }, a) || {};\n          var q = g.x;\n\n          if (g.id || l(q)) {\n            if (q = this.findPointIndex(g, k), -1 === q || \"undefined\" === typeof q ? e.push(a) : f[q] && a !== b.data[q] ? (f[q].update(a, !1, null, !1), f[q].touched = !0, n && (k = q + 1)) : f[q] && (f[q].touched = !0), !t || c !== q || d && d.enabled || this.hasDerivedData) h = !0;\n          } else e.push(a);\n        }, this);\n        if (h) for (a = f.length; a--;) (g = f[a]) && !g.touched && g.remove && g.remove(!1, c);else !t || d && d.enabled ? m = !1 : (a.forEach(function (a, b) {\n          f[b].update && a !== f[b].y && f[b].update(a, !1, null, !1);\n        }), e.length = 0);\n        f.forEach(function (a) {\n          a && (a.touched = !1);\n        });\n        if (!m) return !1;\n        e.forEach(function (a) {\n          this.addPoint(a, !1, null, null, !1);\n        }, this);\n        null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = E(this.xData), this.autoIncrement());\n        return !0;\n      },\n      setData: function (a, c, d, e) {\n        var b = this,\n            g = b.points,\n            n = g && g.length || 0,\n            q,\n            x = b.options,\n            t = b.chart,\n            m = x.dataSorting,\n            y = null,\n            r = b.xAxis;\n        y = x.turboThreshold;\n        var B = this.xData,\n            w = this.yData,\n            v = (q = b.pointArrayMap) && q.length,\n            z = x.keys,\n            F = 0,\n            N = 1,\n            u;\n        a = a || [];\n        q = a.length;\n        c = k(c, !0);\n        m && m.enabled && (a = this.sortData(a));\n        !1 !== e && q && n && !b.cropped && !b.hasGroupedData && b.visible && !b.isSeriesBoosting && (u = this.updateData(a, d));\n\n        if (!u) {\n          b.xIncrement = null;\n          b.colorCounter = 0;\n          this.parallelArrays.forEach(function (a) {\n            b[a + \"Data\"].length = 0;\n          });\n          if (y && q > y) {\n            if (y = b.getFirstValidPoint(a), l(y)) for (d = 0; d < q; d++) B[d] = this.autoIncrement(), w[d] = a[d];else if (f(y)) {\n              if (v) for (d = 0; d < q; d++) e = a[d], B[d] = e[0], w[d] = e.slice(1, v + 1);else for (z && (F = z.indexOf(\"x\"), N = z.indexOf(\"y\"), F = 0 <= F ? F : 0, N = 0 <= N ? N : 1), d = 0; d < q; d++) e = a[d], B[d] = e[F], w[d] = e[N];\n            } else D(12, !1, t);\n          } else for (d = 0; d < q; d++) \"undefined\" !== typeof a[d] && (e = {\n            series: b\n          }, b.pointClass.prototype.applyOptions.apply(e, [a[d]]), b.updateParallelArrays(e, d));\n          w && h(w[0]) && D(14, !0, t);\n          b.data = [];\n          b.options.data = b.userOptions.data = a;\n\n          for (d = n; d--;) g[d] && g[d].destroy && g[d].destroy();\n\n          r && (r.minRange = r.userMinRange);\n          b.isDirty = t.isDirtyBox = !0;\n          b.isDirtyData = !!g;\n          d = !1;\n        }\n\n        \"point\" === x.legendType && (this.processData(), this.generatePoints());\n        c && t.redraw(d);\n      },\n      sortData: function (a) {\n        var b = this,\n            c = b.options.dataSorting.sortKey || \"y\",\n            d = function (a, b) {\n          return z(b) && a.pointClass.prototype.optionsToObject.call({\n            series: a\n          }, b) || {};\n        };\n\n        a.forEach(function (c, f) {\n          a[f] = d(b, c);\n          a[f].index = f;\n        }, this);\n        a.concat().sort(function (a, b) {\n          a = H(c, a);\n          b = H(c, b);\n          return b < a ? -1 : b > a ? 1 : 0;\n        }).forEach(function (a, b) {\n          a.x = b;\n        }, this);\n        b.linkedSeries && b.linkedSeries.forEach(function (b) {\n          var c = b.options,\n              f = c.data;\n          c.dataSorting && c.dataSorting.enabled || !f || (f.forEach(function (c, e) {\n            f[e] = d(b, c);\n            a[e] && (f[e].x = a[e].x, f[e].index = e);\n          }), b.setData(f, !1));\n        });\n        return a;\n      },\n      processData: function (a) {\n        var b = this.xData,\n            c = this.yData,\n            d = b.length;\n        var f = 0;\n        var e = this.xAxis,\n            h = this.options;\n        var g = h.cropThreshold;\n        var l = this.getExtremesFromAll || h.getExtremesFromAll,\n            k = this.isCartesian;\n        h = e && e.val2lin;\n        var n = e && e.isLog,\n            t = this.requireSorting;\n        if (k && !this.isDirty && !e.isDirty && !this.yAxis.isDirty && !a) return !1;\n\n        if (e) {\n          a = e.getExtremes();\n          var m = a.min;\n          var y = a.max;\n        }\n\n        if (k && this.sorted && !l && (!g || d > g || this.forceCrop)) if (b[d - 1] < m || b[0] > y) b = [], c = [];else if (this.yData && (b[0] < m || b[d - 1] > y)) {\n          f = this.cropData(this.xData, this.yData, m, y);\n          b = f.xData;\n          c = f.yData;\n          f = f.start;\n          var r = !0;\n        }\n\n        for (g = b.length || 1; --g;) if (d = n ? h(b[g]) - h(b[g - 1]) : b[g] - b[g - 1], 0 < d && (\"undefined\" === typeof w || d < w)) var w = d;else 0 > d && t && (D(15, !1, this.chart), t = !1);\n\n        this.cropped = r;\n        this.cropStart = f;\n        this.processedXData = b;\n        this.processedYData = c;\n        this.closestPointRange = this.basePointRange = w;\n      },\n      cropData: function (a, c, d, f, e) {\n        var b = a.length,\n            h = 0,\n            g = b,\n            l;\n        e = k(e, this.cropShoulder);\n\n        for (l = 0; l < b; l++) if (a[l] >= d) {\n          h = Math.max(0, l - e);\n          break;\n        }\n\n        for (d = l; d < b; d++) if (a[d] > f) {\n          g = d + e;\n          break;\n        }\n\n        return {\n          xData: a.slice(h, g),\n          yData: c.slice(h, g),\n          start: h,\n          end: g\n        };\n      },\n      generatePoints: function () {\n        var a = this.options,\n            c = a.data,\n            d = this.data,\n            f,\n            e = this.processedXData,\n            h = this.processedYData,\n            g = this.pointClass,\n            l = e.length,\n            k = this.cropStart || 0,\n            n = this.hasGroupedData;\n        a = a.keys;\n        var t = [],\n            r;\n        d || n || (d = [], d.length = c.length, d = this.data = d);\n        a && n && (this.options.keys = !1);\n\n        for (r = 0; r < l; r++) {\n          var w = k + r;\n\n          if (n) {\n            var v = new g().init(this, [e[r]].concat(y(h[r])));\n            v.dataGroup = this.groupMap[r];\n            v.dataGroup.options && (v.options = v.dataGroup.options, M(v, v.dataGroup.options), delete v.dataLabels);\n          } else (v = d[w]) || \"undefined\" === typeof c[w] || (d[w] = v = new g().init(this, c[w], e[r]));\n\n          v && (v.index = w, t[r] = v);\n        }\n\n        this.options.keys = a;\n        if (d && (l !== (f = d.length) || n)) for (r = 0; r < f; r++) r !== k || n || (r += l), d[r] && (d[r].destroyElements(), d[r].plotX = void 0);\n        this.data = d;\n        this.points = t;\n        m(this, \"afterGeneratePoints\");\n      },\n      getXExtremes: function (a) {\n        return {\n          min: A(a),\n          max: E(a)\n        };\n      },\n      getExtremes: function (a) {\n        var b = this.xAxis,\n            c = this.yAxis,\n            d = this.processedXData || this.xData,\n            e = [],\n            h = 0,\n            g = 0;\n        var k = 0;\n        var n = this.requireSorting ? this.cropShoulder : 0,\n            t = c ? c.positiveValuesOnly : !1,\n            y;\n        a = a || this.stackedYData || this.processedYData || [];\n        c = a.length;\n        b && (k = b.getExtremes(), g = k.min, k = k.max);\n\n        for (y = 0; y < c; y++) {\n          var r = d[y];\n          var w = a[y];\n          var v = (l(w) || f(w)) && (w.length || 0 < w || !t);\n          r = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !b || (d[y + n] || r) >= g && (d[y - n] || r) <= k;\n          if (v && r) if (v = w.length) for (; v--;) l(w[v]) && (e[h++] = w[v]);else e[h++] = w;\n        }\n\n        this.dataMin = A(e);\n        this.dataMax = E(e);\n        m(this, \"afterGetExtremes\");\n      },\n      getFirstValidPoint: function (a) {\n        for (var b = null, c = a.length, d = 0; null === b && d < c;) b = a[d], d++;\n\n        return b;\n      },\n      translate: function () {\n        this.processedXData || this.processData();\n        this.generatePoints();\n        var a = this.options,\n            c = a.stacking,\n            d = this.xAxis,\n            e = d.categories,\n            h = this.enabledDataSorting,\n            g = this.yAxis,\n            n = this.points,\n            q = n.length,\n            t = !!this.modifyValue,\n            y,\n            r = this.pointPlacementToXValue(),\n            w = !!r,\n            v = a.threshold,\n            F = a.startFromThreshold ? v : 0,\n            N,\n            u = this.zoneAxis || \"y\",\n            I = Number.MAX_VALUE;\n\n        for (y = 0; y < q; y++) {\n          var p = n[y],\n              D = p.x;\n          var O = p.y;\n          var A = p.low,\n              M = c && g.stacks[(this.negStacks && O < (F ? 0 : v) ? \"-\" : \"\") + this.stackKey];\n          g.positiveValuesOnly && null !== O && 0 >= O && (p.isNull = !0);\n          p.plotX = N = J(C(d.translate(D, 0, 0, 0, 1, r, \"flags\" === this.type), -1E5, 1E5));\n\n          if (c && this.visible && M && M[D]) {\n            var H = this.getStackIndicator(H, D, this.index);\n\n            if (!p.isNull) {\n              var S = M[D];\n              var E = S.points[H.key];\n            }\n          }\n\n          f(E) && (A = E[0], O = E[1], A === F && H.key === M[D].base && (A = k(l(v) && v, g.min)), g.positiveValuesOnly && 0 >= A && (A = null), p.total = p.stackTotal = S.total, p.percentage = S.total && p.y / S.total * 100, p.stackY = O, this.irregularWidths || S.setOffset(this.pointXOffset || 0, this.barW || 0));\n          p.yBottom = z(A) ? C(g.translate(A, 0, 1, 0, 1), -1E5, 1E5) : null;\n          t && (O = this.modifyValue(O, p));\n          p.plotY = O = \"number\" === typeof O && Infinity !== O ? C(g.translate(O, 0, 1, 0, 1), -1E5, 1E5) : void 0;\n          p.isInside = \"undefined\" !== typeof O && 0 <= O && O <= g.len && 0 <= N && N <= d.len;\n          p.clientX = w ? J(d.translate(D, 0, 0, 0, 1, r)) : N;\n          p.negative = p[u] < (a[u + \"Threshold\"] || v || 0);\n          p.category = e && \"undefined\" !== typeof e[p.x] ? e[p.x] : p.x;\n\n          if (!p.isNull && !1 !== p.visible) {\n            \"undefined\" !== typeof L && (I = Math.min(I, Math.abs(N - L)));\n            var L = N;\n          }\n\n          p.zone = this.zones.length && p.getZone();\n          !p.graphic && this.group && h && (p.isNew = !0);\n        }\n\n        this.closestPointRangePx = I;\n        m(this, \"afterTranslate\");\n      },\n      getValidPoints: function (a, c, d) {\n        var b = this.chart;\n        return (a || this.points || []).filter(function (a) {\n          return c && !b.isInsidePlot(a.plotX, a.plotY, b.inverted) ? !1 : !1 !== a.visible && (d || !a.isNull);\n        });\n      },\n      getClipBox: function (a, c) {\n        var b = this.options,\n            d = this.chart,\n            f = d.inverted,\n            e = this.xAxis,\n            h = e && this.yAxis;\n        a && !1 === b.clip && h ? a = f ? {\n          y: -d.chartWidth + h.len + h.pos,\n          height: d.chartWidth,\n          width: d.chartHeight,\n          x: -d.chartHeight + e.len + e.pos\n        } : {\n          y: -h.pos,\n          height: d.chartHeight,\n          width: d.chartWidth,\n          x: -e.pos\n        } : (a = this.clipBox || d.clipBox, c && (a.width = d.plotSizeX, a.x = 0));\n        return c ? {\n          width: a.width,\n          x: a.x\n        } : a;\n      },\n      setClip: function (a) {\n        var b = this.chart,\n            c = this.options,\n            d = b.renderer,\n            f = b.inverted,\n            e = this.clipBox,\n            h = this.getClipBox(a),\n            g = this.sharedClipKey || [\"_sharedClip\", a && a.duration, a && a.easing, h.height, c.xAxis, c.yAxis].join(),\n            l = b[g],\n            k = b[g + \"m\"];\n        l || (a && (h.width = 0, f && (h.x = b.plotSizeX + (!1 !== c.clip ? 0 : b.plotTop)), b[g + \"m\"] = k = d.clipRect(f ? b.plotSizeX + 99 : -99, f ? -b.plotLeft : -b.plotTop, 99, f ? b.chartWidth : b.chartHeight)), b[g] = l = d.clipRect(h), l.count = {\n          length: 0\n        });\n        a && !l.count[this.index] && (l.count[this.index] = !0, l.count.length += 1);\n        if (!1 !== c.clip || a) this.group.clip(a || e ? l : b.clipRect), this.markerGroup.clip(k), this.sharedClipKey = g;\n        a || (l.count[this.index] && (delete l.count[this.index], --l.count.length), 0 === l.count.length && g && b[g] && (e || (b[g] = b[g].destroy()), b[g + \"m\"] && (b[g + \"m\"] = b[g + \"m\"].destroy())));\n      },\n      animate: function (a) {\n        var b = this.chart,\n            c = L(this.options.animation);\n        if (a) this.setClip(c);else {\n          var d = this.sharedClipKey;\n          a = b[d];\n          var f = this.getClipBox(c, !0);\n          a && a.animate(f, c);\n          b[d + \"m\"] && b[d + \"m\"].animate({\n            width: f.width + 99,\n            x: f.x - (b.inverted ? 0 : 99)\n          }, c);\n          this.animate = null;\n        }\n      },\n      afterAnimate: function () {\n        this.setClip();\n        m(this, \"afterAnimate\");\n        this.finishedAnimating = !0;\n      },\n      drawPoints: function () {\n        var a = this.points,\n            c = this.chart,\n            d,\n            f,\n            e = this.options.marker,\n            h = this[this.specialGroup] || this.markerGroup,\n            g = this.xAxis,\n            l = k(e.enabled, !g || g.isRadial ? !0 : null, this.closestPointRangePx >= e.enabledThreshold * e.radius);\n        if (!1 !== e.enabled || this._hasPointMarkers) for (d = 0; d < a.length; d++) {\n          var n = a[d];\n          var t = (f = n.graphic) ? \"animate\" : \"attr\";\n          var m = n.marker || {};\n          var y = !!n.marker;\n\n          if ((l && \"undefined\" === typeof m.enabled || m.enabled) && !n.isNull && !1 !== n.visible) {\n            var r = k(m.symbol, this.symbol);\n            var w = this.markerAttribs(n, n.selected && \"select\");\n            this.enabledDataSorting && (n.startXPos = g.reversed ? -w.width : g.width);\n            var v = !1 !== n.isInside;\n            f ? f[v ? \"show\" : \"hide\"](v).animate(w) : v && (0 < w.width || n.hasImage) && (n.graphic = f = c.renderer.symbol(r, w.x, w.y, w.width, w.height, y ? m : e).add(h), this.enabledDataSorting && c.hasRendered && (f.attr({\n              x: n.startXPos\n            }), t = \"animate\"));\n            f && \"animate\" === t && f[v ? \"show\" : \"hide\"](v).animate(w);\n            if (f && !c.styledMode) f[t](this.pointAttribs(n, n.selected && \"select\"));\n            f && f.addClass(n.getClassName(), !0);\n          } else f && (n.graphic = f.destroy());\n        }\n      },\n      markerAttribs: function (a, c) {\n        var b = this.options.marker,\n            d = a.marker || {},\n            f = d.symbol || b.symbol,\n            e = k(d.radius, b.radius);\n        c && (b = b.states[c], c = d.states && d.states[c], e = k(c && c.radius, b && b.radius, e + (b && b.radiusPlus || 0)));\n        a.hasImage = f && 0 === f.indexOf(\"url\");\n        a.hasImage && (e = 0);\n        a = {\n          x: Math.floor(a.plotX) - e,\n          y: a.plotY - e\n        };\n        e && (a.width = a.height = 2 * e);\n        return a;\n      },\n      pointAttribs: function (a, c) {\n        var b = this.options.marker,\n            d = a && a.options,\n            f = d && d.marker || {},\n            e = this.color,\n            h = d && d.color,\n            g = a && a.color;\n        d = k(f.lineWidth, b.lineWidth);\n        var l = a && a.zone && a.zone.color;\n        a = 1;\n        e = h || l || g || e;\n        h = f.fillColor || b.fillColor || e;\n        e = f.lineColor || b.lineColor || e;\n        c = c || \"normal\";\n        b = b.states[c];\n        c = f.states && f.states[c] || {};\n        d = k(c.lineWidth, b.lineWidth, d + k(c.lineWidthPlus, b.lineWidthPlus, 0));\n        h = c.fillColor || b.fillColor || h;\n        e = c.lineColor || b.lineColor || e;\n        a = k(c.opacity, b.opacity, a);\n        return {\n          stroke: e,\n          \"stroke-width\": d,\n          fill: h,\n          opacity: a\n        };\n      },\n      destroy: function (b) {\n        var c = this,\n            d = c.chart,\n            f = /AppleWebKit\\/533/.test(n.navigator.userAgent),\n            e,\n            h,\n            g = c.data || [],\n            l,\n            k;\n        m(c, \"destroy\");\n        this.removeEvents(b);\n        (c.axisTypes || []).forEach(function (a) {\n          (k = c[a]) && k.series && (r(k.series, c), k.isDirty = k.forceRedraw = !0);\n        });\n        c.legendItem && c.chart.legend.destroyItem(c);\n\n        for (h = g.length; h--;) (l = g[h]) && l.destroy && l.destroy();\n\n        c.points = null;\n        u.clearTimeout(c.animationTimeout);\n        a(c, function (a, b) {\n          a instanceof N && !a.survive && (e = f && \"group\" === b ? \"hide\" : \"destroy\", a[e]());\n        });\n        d.hoverSeries === c && (d.hoverSeries = null);\n        r(d.series, c);\n        d.orderSeries();\n        a(c, function (a, d) {\n          b && \"hcEvents\" === d || delete c[d];\n        });\n      },\n      getGraphPath: function (a, c, d) {\n        var b = this,\n            f = b.options,\n            e = f.step,\n            h,\n            g = [],\n            l = [],\n            k;\n        a = a || b.points;\n        (h = a.reversed) && a.reverse();\n        (e = {\n          right: 1,\n          center: 2\n        }[e] || e && 3) && h && (e = 4 - e);\n        a = this.getValidPoints(a, !1, !(f.connectNulls && !c && !d));\n        a.forEach(function (h, n) {\n          var q = h.plotX,\n              t = h.plotY,\n              m = a[n - 1];\n          (h.leftCliff || m && m.rightCliff) && !d && (k = !0);\n          h.isNull && !z(c) && 0 < n ? k = !f.connectNulls : h.isNull && !c ? k = !0 : (0 === n || k ? n = [\"M\", h.plotX, h.plotY] : b.getPointSpline ? n = b.getPointSpline(a, h, n) : e ? (n = 1 === e ? [\"L\", m.plotX, t] : 2 === e ? [\"L\", (m.plotX + q) / 2, m.plotY, \"L\", (m.plotX + q) / 2, t] : [\"L\", q, m.plotY], n.push(\"L\", q, t)) : n = [\"L\", q, t], l.push(h.x), e && (l.push(h.x), 2 === e && l.push(h.x)), g.push.apply(g, n), k = !1);\n        });\n        g.xMap = l;\n        return b.graphPath = g;\n      },\n      drawGraph: function () {\n        var a = this,\n            c = this.options,\n            d = (this.gappedPath || this.getGraphPath).call(this),\n            f = this.chart.styledMode,\n            e = [[\"graph\", \"highcharts-graph\"]];\n        f || e[0].push(c.lineColor || this.color || \"#cccccc\", c.dashStyle);\n        e = a.getZonesGraphs(e);\n        e.forEach(function (b, e) {\n          var h = b[0],\n              g = a[h],\n              l = g ? \"animate\" : \"attr\";\n          g ? (g.endX = a.preventGraphAnimation ? null : d.xMap, g.animate({\n            d: d\n          })) : d.length && (a[h] = g = a.chart.renderer.path(d).addClass(b[1]).attr({\n            zIndex: 1\n          }).add(a.group));\n          g && !f && (h = {\n            stroke: b[2],\n            \"stroke-width\": c.lineWidth,\n            fill: a.fillGraph && a.color || \"none\"\n          }, b[3] ? h.dashstyle = b[3] : \"square\" !== c.linecap && (h[\"stroke-linecap\"] = h[\"stroke-linejoin\"] = \"round\"), g[l](h).shadow(2 > e && c.shadow));\n          g && (g.startX = d.xMap, g.isArea = d.isArea);\n        });\n      },\n      getZonesGraphs: function (a) {\n        this.zones.forEach(function (b, c) {\n          c = [\"zone-graph-\" + c, \"highcharts-graph highcharts-zone-graph-\" + c + \" \" + (b.className || \"\")];\n          this.chart.styledMode || c.push(b.color || this.color, b.dashStyle || this.options.dashStyle);\n          a.push(c);\n        }, this);\n        return a;\n      },\n      applyZones: function () {\n        var a = this,\n            c = this.chart,\n            d = c.renderer,\n            f = this.zones,\n            e,\n            h,\n            g = this.clips || [],\n            l,\n            n = this.graph,\n            t = this.area,\n            m = Math.max(c.chartWidth, c.chartHeight),\n            y = this[(this.zoneAxis || \"y\") + \"Axis\"],\n            r = c.inverted,\n            w,\n            v,\n            z,\n            F = !1;\n\n        if (f.length && (n || t) && y && \"undefined\" !== typeof y.min) {\n          var N = y.reversed;\n          var p = y.horiz;\n          n && !this.showLine && n.hide();\n          t && t.hide();\n          var u = y.getExtremes();\n          f.forEach(function (b, f) {\n            e = N ? p ? c.plotWidth : 0 : p ? 0 : y.toPixels(u.min) || 0;\n            e = C(k(h, e), 0, m);\n            h = C(Math.round(y.toPixels(k(b.value, u.max), !0) || 0), 0, m);\n            F && (e = h = y.toPixels(u.max));\n            w = Math.abs(e - h);\n            v = Math.min(e, h);\n            z = Math.max(e, h);\n            y.isXAxis ? (l = {\n              x: r ? z : v,\n              y: 0,\n              width: w,\n              height: m\n            }, p || (l.x = c.plotHeight - l.x)) : (l = {\n              x: 0,\n              y: r ? z : v,\n              width: m,\n              height: w\n            }, p && (l.y = c.plotWidth - l.y));\n            r && d.isVML && (l = y.isXAxis ? {\n              x: 0,\n              y: N ? v : z,\n              height: l.width,\n              width: c.chartWidth\n            } : {\n              x: l.y - c.plotLeft - c.spacingBox.x,\n              y: 0,\n              width: l.height,\n              height: c.chartHeight\n            });\n            g[f] ? g[f].animate(l) : g[f] = d.clipRect(l);\n            n && a[\"zone-graph-\" + f].clip(g[f]);\n            t && a[\"zone-area-\" + f].clip(g[f]);\n            F = b.value > u.max;\n            a.resetZones && 0 === h && (h = void 0);\n          });\n          this.clips = g;\n        } else a.visible && (n && n.show(!0), t && t.show(!0));\n      },\n      invertGroups: function (a) {\n        function b() {\n          [\"group\", \"markerGroup\"].forEach(function (b) {\n            c[b] && (d.renderer.isVML && c[b].attr({\n              width: c.yAxis.len,\n              height: c.xAxis.len\n            }), c[b].width = c.yAxis.len, c[b].height = c.xAxis.len, c[b].invert(c.isRadialSeries ? !1 : a));\n          });\n        }\n\n        var c = this,\n            d = c.chart;\n        c.xAxis && (c.eventsToUnbind.push(K(d, \"resize\", b)), b(), c.invertGroups = b);\n      },\n      plotGroup: function (a, c, d, f, e) {\n        var b = this[a],\n            h = !b;\n        h && (this[a] = b = this.chart.renderer.g().attr({\n          zIndex: f || .1\n        }).add(e));\n        b.addClass(\"highcharts-\" + c + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series \" + (z(this.colorIndex) ? \"highcharts-color-\" + this.colorIndex + \" \" : \"\") + (this.options.className || \"\") + (b.hasClass(\"highcharts-tracker\") ? \" highcharts-tracker\" : \"\"), !0);\n        b.attr({\n          visibility: d\n        })[h ? \"attr\" : \"animate\"](this.getPlotBox());\n        return b;\n      },\n      getPlotBox: function () {\n        var a = this.chart,\n            c = this.xAxis,\n            d = this.yAxis;\n        a.inverted && (c = d, d = this.xAxis);\n        return {\n          translateX: c ? c.left : a.plotLeft,\n          translateY: d ? d.top : a.plotTop,\n          scaleX: 1,\n          scaleY: 1\n        };\n      },\n      removeEvents: function (a) {\n        a ? this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (a) {\n          a();\n        }), this.eventsToUnbind.length = 0) : t(this);\n      },\n      render: function () {\n        var a = this,\n            c = a.chart,\n            d = a.options,\n            f = !!a.animate && c.renderer.isSVG && L(d.animation).duration,\n            e = a.visible ? \"inherit\" : \"hidden\",\n            h = d.zIndex,\n            g = a.hasRendered,\n            l = c.seriesGroup,\n            k = c.inverted;\n        m(this, \"render\");\n        var n = a.plotGroup(\"group\", \"series\", e, h, l);\n        a.markerGroup = a.plotGroup(\"markerGroup\", \"markers\", e, h, l);\n        f && a.animate(!0);\n        n.inverted = a.isCartesian || a.invertable ? k : !1;\n        a.drawGraph && (a.drawGraph(), a.applyZones());\n        a.visible && a.drawPoints();\n        a.drawDataLabels && a.drawDataLabels();\n        a.redrawPoints && a.redrawPoints();\n        a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();\n        a.invertGroups(k);\n        !1 === d.clip || a.sharedClipKey || g || n.clip(c.clipRect);\n        f && a.animate();\n        g || (a.animationTimeout = F(function () {\n          a.afterAnimate();\n        }, f || 0));\n        a.isDirty = !1;\n        a.hasRendered = !0;\n        m(a, \"afterRender\");\n      },\n      redraw: function () {\n        var a = this.chart,\n            c = this.isDirty || this.isDirtyData,\n            d = this.group,\n            f = this.xAxis,\n            e = this.yAxis;\n        d && (a.inverted && d.attr({\n          width: a.plotWidth,\n          height: a.plotHeight\n        }), d.animate({\n          translateX: k(f && f.left, a.plotLeft),\n          translateY: k(e && e.top, a.plotTop)\n        }));\n        this.translate();\n        this.render();\n        c && delete this.kdTree;\n      },\n      kdAxisArray: [\"clientX\", \"plotY\"],\n      searchPoint: function (a, c) {\n        var b = this.xAxis,\n            d = this.yAxis,\n            f = this.chart.inverted;\n        return this.searchKDTree({\n          clientX: f ? b.len - a.chartY + b.pos : a.chartX - b.pos,\n          plotY: f ? d.len - a.chartX + d.pos : a.chartY - d.pos\n        }, c, a);\n      },\n      buildKDTree: function (a) {\n        function b(a, d, f) {\n          var e;\n\n          if (e = a && a.length) {\n            var h = c.kdAxisArray[d % f];\n            a.sort(function (a, b) {\n              return a[h] - b[h];\n            });\n            e = Math.floor(e / 2);\n            return {\n              point: a[e],\n              left: b(a.slice(0, e), d + 1, f),\n              right: b(a.slice(e + 1), d + 1, f)\n            };\n          }\n        }\n\n        this.buildingKdTree = !0;\n        var c = this,\n            d = -1 < c.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        delete c.kdTree;\n        F(function () {\n          c.kdTree = b(c.getValidPoints(null, !c.directTouch), d, d);\n          c.buildingKdTree = !1;\n        }, c.options.kdNow || a && \"touchstart\" === a.type ? 0 : 1);\n      },\n      searchKDTree: function (a, c, d) {\n        function b(a, c, d, l) {\n          var k = c.point,\n              n = f.kdAxisArray[d % l],\n              t = k;\n          var q = z(a[e]) && z(k[e]) ? Math.pow(a[e] - k[e], 2) : null;\n          var m = z(a[h]) && z(k[h]) ? Math.pow(a[h] - k[h], 2) : null;\n          m = (q || 0) + (m || 0);\n          k.dist = z(m) ? Math.sqrt(m) : Number.MAX_VALUE;\n          k.distX = z(q) ? Math.sqrt(q) : Number.MAX_VALUE;\n          n = a[n] - k[n];\n          m = 0 > n ? \"left\" : \"right\";\n          q = 0 > n ? \"right\" : \"left\";\n          c[m] && (m = b(a, c[m], d + 1, l), t = m[g] < t[g] ? m : k);\n          c[q] && Math.sqrt(n * n) < t[g] && (a = b(a, c[q], d + 1, l), t = a[g] < t[g] ? a : t);\n          return t;\n        }\n\n        var f = this,\n            e = this.kdAxisArray[0],\n            h = this.kdAxisArray[1],\n            g = c ? \"distX\" : \"dist\";\n        c = -1 < f.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        this.kdTree || this.buildingKdTree || this.buildKDTree(d);\n        if (this.kdTree) return b(a, this.kdTree, c, c);\n      },\n      pointPlacementToXValue: function () {\n        var a = this.options,\n            c = a.pointRange,\n            d = this.xAxis;\n        a = a.pointPlacement;\n        \"between\" === a && (a = d.reversed ? -.5 : .5);\n        return l(a) ? a * k(c, d.pointRange) : 0;\n      }\n    });\n    \"\";\n  });\n  R(p, \"parts/Stacking.js\", [p[\"parts/Globals.js\"], p[\"parts/Utilities.js\"]], function (e, g) {\n    var p = g.correctFloat,\n        u = g.defined,\n        K = g.destroyObjectProperties,\n        L = g.format,\n        E = g.objectEach,\n        A = g.pick;\n    g = e.Axis;\n    var C = e.Chart,\n        J = e.Series;\n\n    e.StackItem = function (e, g, p, u, v) {\n      var m = e.chart.inverted;\n      this.axis = e;\n      this.isNegative = p;\n      this.options = g = g || {};\n      this.x = u;\n      this.total = null;\n      this.points = {};\n      this.stack = v;\n      this.rightCliff = this.leftCliff = 0;\n      this.alignOptions = {\n        align: g.align || (m ? p ? \"left\" : \"right\" : \"center\"),\n        verticalAlign: g.verticalAlign || (m ? \"middle\" : p ? \"bottom\" : \"top\"),\n        y: g.y,\n        x: g.x\n      };\n      this.textAlign = g.textAlign || (m ? p ? \"right\" : \"left\" : \"center\");\n    };\n\n    e.StackItem.prototype = {\n      destroy: function () {\n        K(this, this.axis);\n      },\n      render: function (e) {\n        var g = this.axis.chart,\n            z = this.options,\n            p = z.format;\n        p = p ? L(p, this, g) : z.formatter.call(this);\n        this.label ? this.label.attr({\n          text: p,\n          visibility: \"hidden\"\n        }) : (this.label = g.renderer.label(p, null, null, z.shape, null, null, z.useHTML, !1, \"stack-labels\"), p = {\n          text: p,\n          rotation: z.rotation,\n          padding: A(z.padding, 5),\n          visibility: \"hidden\"\n        }, this.label.attr(p), g.styledMode || this.label.css(z.style), this.label.added || this.label.add(e));\n        this.label.labelrank = g.plotHeight;\n      },\n      setOffset: function (e, g, p, M, v) {\n        var m = this.axis,\n            r = m.chart;\n        M = m.translate(m.usePercentage ? 100 : M ? M : this.total, 0, 0, 0, 1);\n        p = m.translate(p ? p : 0);\n        p = u(M) && Math.abs(M - p);\n        e = A(v, r.xAxis[0].translate(this.x)) + e;\n        m = u(M) && this.getStackBox(r, this, e, M, g, p, m);\n        g = this.label;\n        p = this.isNegative;\n        e = \"justify\" === A(this.options.overflow, \"justify\");\n        var f = this.textAlign;\n        g && m && (v = g.getBBox(), M = g.padding, f = \"left\" === f ? r.inverted ? -M : M : \"right\" === f ? v.width : r.inverted && \"center\" === f ? v.width / 2 : r.inverted ? p ? v.width + M : -M : v.width / 2, p = r.inverted ? v.height / 2 : p ? -M : v.height, this.alignOptions.x = A(this.options.x, 0), this.alignOptions.y = A(this.options.y, 0), m.x -= f, m.y -= p, g.align(this.alignOptions, null, m), r.isInsidePlot(g.alignAttr.x + f - this.alignOptions.x, g.alignAttr.y + p - this.alignOptions.y) ? g.show() : (g.alignAttr.y = -9999, e = !1), e && J.prototype.justifyDataLabel.call(this.axis, g, this.alignOptions, g.alignAttr, v, m), g.attr({\n          x: g.alignAttr.x,\n          y: g.alignAttr.y\n        }), A(!e && this.options.crop, !0) && ((r = r.isInsidePlot(g.x - M + g.width, g.y) && r.isInsidePlot(g.x + M, g.y)) || g.hide()));\n      },\n      getStackBox: function (e, g, p, u, v, m, A) {\n        var f = g.axis.reversed,\n            c = e.inverted;\n        e = A.height + A.pos - (c ? e.plotLeft : e.plotTop);\n        g = g.isNegative && !f || !g.isNegative && f;\n        return {\n          x: c ? g ? u : u - m : p,\n          y: c ? e - p - v : g ? e - u - m : e - u,\n          width: c ? m : v,\n          height: c ? v : m\n        };\n      }\n    };\n\n    C.prototype.getStacks = function () {\n      var e = this,\n          g = e.inverted;\n      e.yAxis.forEach(function (e) {\n        e.stacks && e.hasVisibleSeries && (e.oldStacks = e.stacks);\n      });\n      e.series.forEach(function (r) {\n        var p = r.xAxis && r.xAxis.options || {};\n        !r.options.stacking || !0 !== r.visible && !1 !== e.options.chart.ignoreHiddenSeries || (r.stackKey = [r.type, A(r.options.stack, \"\"), g ? p.top : p.left, g ? p.height : p.width].join());\n      });\n    };\n\n    g.prototype.buildStacks = function () {\n      var g = this.series,\n          r = A(this.options.reversedStacks, !0),\n          p = g.length,\n          u;\n\n      if (!this.isXAxis) {\n        this.usePercentage = !1;\n\n        for (u = p; u--;) {\n          var v = g[r ? u : p - u - 1];\n          v.setStackedPoints();\n        }\n\n        for (u = 0; u < p; u++) g[u].modifyStacks();\n\n        e.fireEvent(this, \"afterBuildStacks\");\n      }\n    };\n\n    g.prototype.renderStackTotals = function () {\n      var e = this.chart,\n          g = e.renderer,\n          p = this.stacks,\n          u = this.stackTotalGroup;\n      u || (this.stackTotalGroup = u = g.g(\"stack-labels\").attr({\n        visibility: \"visible\",\n        zIndex: 6\n      }).add());\n      u.translate(e.plotLeft, e.plotTop);\n      E(p, function (e) {\n        E(e, function (e) {\n          e.render(u);\n        });\n      });\n    };\n\n    g.prototype.resetStacks = function () {\n      var e = this,\n          g = e.stacks;\n      e.isXAxis || E(g, function (g) {\n        E(g, function (r, v) {\n          r.touched < e.stacksTouched ? (r.destroy(), delete g[v]) : (r.total = null, r.cumulative = null);\n        });\n      });\n    };\n\n    g.prototype.cleanStacks = function () {\n      if (!this.isXAxis) {\n        if (this.oldStacks) var e = this.stacks = this.oldStacks;\n        E(e, function (e) {\n          E(e, function (e) {\n            e.cumulative = e.total;\n          });\n        });\n      }\n    };\n\n    J.prototype.setStackedPoints = function () {\n      if (this.options.stacking && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {\n        var g = this.processedXData,\n            r = this.processedYData,\n            D = [],\n            C = r.length,\n            v = this.options,\n            m = v.threshold,\n            H = A(v.startFromThreshold && m, 0),\n            f = v.stack;\n        v = v.stacking;\n        var c = this.stackKey,\n            l = \"-\" + c,\n            h = this.negStacks,\n            d = this.yAxis,\n            a = d.stacks,\n            k = d.oldStacks,\n            t,\n            w;\n        d.stacksTouched += 1;\n\n        for (w = 0; w < C; w++) {\n          var y = g[w];\n          var F = r[w];\n          var I = this.getStackIndicator(I, y, this.index);\n          var S = I.key;\n          var O = (t = h && F < (H ? 0 : m)) ? l : c;\n          a[O] || (a[O] = {});\n          a[O][y] || (k[O] && k[O][y] ? (a[O][y] = k[O][y], a[O][y].total = null) : a[O][y] = new e.StackItem(d, d.options.stackLabels, t, y, f));\n          O = a[O][y];\n          null !== F ? (O.points[S] = O.points[this.index] = [A(O.cumulative, H)], u(O.cumulative) || (O.base = S), O.touched = d.stacksTouched, 0 < I.index && !1 === this.singleStacks && (O.points[S][0] = O.points[this.index + \",\" + y + \",0\"][0])) : O.points[S] = O.points[this.index] = null;\n          \"percent\" === v ? (t = t ? c : l, h && a[t] && a[t][y] ? (t = a[t][y], O.total = t.total = Math.max(t.total, O.total) + Math.abs(F) || 0) : O.total = p(O.total + (Math.abs(F) || 0))) : O.total = p(O.total + (F || 0));\n          O.cumulative = A(O.cumulative, H) + (F || 0);\n          null !== F && (O.points[S].push(O.cumulative), D[w] = O.cumulative);\n        }\n\n        \"percent\" === v && (d.usePercentage = !0);\n        this.stackedYData = D;\n        d.oldStacks = {};\n      }\n    };\n\n    J.prototype.modifyStacks = function () {\n      var e = this,\n          g = e.stackKey,\n          p = e.yAxis.stacks,\n          u = e.processedXData,\n          v,\n          m = e.options.stacking;\n      e[m + \"Stacker\"] && [g, \"-\" + g].forEach(function (g) {\n        for (var f = u.length, c, l; f--;) if (c = u[f], v = e.getStackIndicator(v, c, e.index, g), l = (c = p[g] && p[g][c]) && c.points[v.key]) e[m + \"Stacker\"](l, c, f);\n      });\n    };\n\n    J.prototype.percentStacker = function (e, g, u) {\n      g = g.total ? 100 / g.total : 0;\n      e[0] = p(e[0] * g);\n      e[1] = p(e[1] * g);\n      this.stackedYData[u] = e[1];\n    };\n\n    J.prototype.getStackIndicator = function (e, g, p, A) {\n      !u(e) || e.x !== g || A && e.key !== A ? e = {\n        x: g,\n        index: 0,\n        key: A\n      } : e.index++;\n      e.key = [p, g, e.index].join();\n      return e;\n    };\n  });\n  R(p, \"parts/Dynamics.js\", [p[\"parts/Globals.js\"], p[\"parts/Point.js\"], p[\"parts/Time.js\"], p[\"parts/Utilities.js\"]], function (e, g, p, u) {\n    var K = u.addEvent,\n        L = u.animate,\n        E = u.createElement,\n        A = u.css,\n        C = u.defined,\n        J = u.erase,\n        z = u.error,\n        r = u.extend,\n        D = u.fireEvent,\n        M = u.isArray,\n        v = u.isNumber,\n        m = u.isObject,\n        H = u.isString,\n        f = u.merge,\n        c = u.objectEach,\n        l = u.pick,\n        h = u.relativeLength,\n        d = u.setAnimation,\n        a = u.splat,\n        k = e.Axis;\n    u = e.Chart;\n    var t = e.Series,\n        w = e.seriesTypes;\n\n    e.cleanRecursively = function (a, d) {\n      var f = {};\n      c(a, function (c, g) {\n        if (m(a[g], !0) && !a.nodeType && d[g]) c = e.cleanRecursively(a[g], d[g]), Object.keys(c).length && (f[g] = c);else if (m(a[g]) || a[g] !== d[g]) f[g] = a[g];\n      });\n      return f;\n    };\n\n    r(u.prototype, {\n      addSeries: function (a, c, d) {\n        var f,\n            e = this;\n        a && (c = l(c, !0), D(e, \"addSeries\", {\n          options: a\n        }, function () {\n          f = e.initSeries(a);\n          e.isDirtyLegend = !0;\n          e.linkSeries();\n          f.enabledDataSorting && f.setData(a.data, !1);\n          D(e, \"afterAddSeries\", {\n            series: f\n          });\n          c && e.redraw(d);\n        }));\n        return f;\n      },\n      addAxis: function (a, c, d, f) {\n        return this.createAxis(c ? \"xAxis\" : \"yAxis\", {\n          axis: a,\n          redraw: d,\n          animation: f\n        });\n      },\n      addColorAxis: function (a, c, d) {\n        return this.createAxis(\"colorAxis\", {\n          axis: a,\n          redraw: c,\n          animation: d\n        });\n      },\n      createAxis: function (c, d) {\n        var g = this.options,\n            h = \"colorAxis\" === c,\n            t = d.redraw,\n            m = d.animation;\n        d = f(d.axis, {\n          index: this[c].length,\n          isX: \"xAxis\" === c\n        });\n        var n = h ? new e.ColorAxis(this, d) : new k(this, d);\n        g[c] = a(g[c] || {});\n        g[c].push(d);\n        h && (this.isDirtyLegend = !0, this.axes.forEach(function (a) {\n          a.series = [];\n        }), this.series.forEach(function (a) {\n          a.bindAxes();\n          a.isDirtyData = !0;\n        }));\n        l(t, !0) && this.redraw(m);\n        return n;\n      },\n      showLoading: function (a) {\n        var c = this,\n            d = c.options,\n            f = c.loadingDiv,\n            e = d.loading,\n            g = function () {\n          f && A(f, {\n            left: c.plotLeft + \"px\",\n            top: c.plotTop + \"px\",\n            width: c.plotWidth + \"px\",\n            height: c.plotHeight + \"px\"\n          });\n        };\n\n        f || (c.loadingDiv = f = E(\"div\", {\n          className: \"highcharts-loading highcharts-loading-hidden\"\n        }, null, c.container), c.loadingSpan = E(\"span\", {\n          className: \"highcharts-loading-inner\"\n        }, null, f), K(c, \"redraw\", g));\n        f.className = \"highcharts-loading\";\n        c.loadingSpan.innerHTML = l(a, d.lang.loading, \"\");\n        c.styledMode || (A(f, r(e.style, {\n          zIndex: 10\n        })), A(c.loadingSpan, e.labelStyle), c.loadingShown || (A(f, {\n          opacity: 0,\n          display: \"\"\n        }), L(f, {\n          opacity: e.style.opacity || .5\n        }, {\n          duration: e.showDuration || 0\n        })));\n        c.loadingShown = !0;\n        g();\n      },\n      hideLoading: function () {\n        var a = this.options,\n            c = this.loadingDiv;\n        c && (c.className = \"highcharts-loading highcharts-loading-hidden\", this.styledMode || L(c, {\n          opacity: 0\n        }, {\n          duration: a.loading.hideDuration || 100,\n          complete: function () {\n            A(c, {\n              display: \"none\"\n            });\n          }\n        }));\n        this.loadingShown = !1;\n      },\n      propsRequireDirtyBox: \"backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow\".split(\" \"),\n      propsRequireReflow: \"margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft\".split(\" \"),\n      propsRequireUpdateSeries: \"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip\".split(\" \"),\n      collectionsWithUpdate: [\"xAxis\", \"yAxis\", \"zAxis\", \"series\"],\n      update: function (d, g, k, t) {\n        var m = this,\n            y = {\n          credits: \"addCredits\",\n          title: \"setTitle\",\n          subtitle: \"setSubtitle\",\n          caption: \"setCaption\"\n        },\n            n,\n            b,\n            w,\n            r = d.isResponsiveOptions,\n            u = [];\n        D(m, \"update\", {\n          options: d\n        });\n        r || m.setResponsive(!1, !0);\n        d = e.cleanRecursively(d, m.options);\n        f(!0, m.userOptions, d);\n\n        if (n = d.chart) {\n          f(!0, m.options.chart, n);\n          \"className\" in n && m.setClassName(n.className);\n          \"reflow\" in n && m.setReflow(n.reflow);\n\n          if (\"inverted\" in n || \"polar\" in n || \"type\" in n) {\n            m.propFromSeries();\n            var F = !0;\n          }\n\n          \"alignTicks\" in n && (F = !0);\n          c(n, function (a, c) {\n            -1 !== m.propsRequireUpdateSeries.indexOf(\"chart.\" + c) && (b = !0);\n            -1 !== m.propsRequireDirtyBox.indexOf(c) && (m.isDirtyBox = !0);\n            r || -1 === m.propsRequireReflow.indexOf(c) || (w = !0);\n          });\n          !m.styledMode && \"style\" in n && m.renderer.setStyle(n.style);\n        }\n\n        !m.styledMode && d.colors && (this.options.colors = d.colors);\n        d.plotOptions && f(!0, this.options.plotOptions, d.plotOptions);\n        d.time && this.time === e.time && (this.time = new p(d.time));\n        c(d, function (a, c) {\n          if (m[c] && \"function\" === typeof m[c].update) m[c].update(a, !1);else if (\"function\" === typeof m[y[c]]) m[y[c]](a);\n          \"chart\" !== c && -1 !== m.propsRequireUpdateSeries.indexOf(c) && (b = !0);\n        });\n        this.collectionsWithUpdate.forEach(function (b) {\n          if (d[b]) {\n            if (\"series\" === b) {\n              var c = [];\n              m[b].forEach(function (a, b) {\n                a.options.isInternal || c.push(l(a.options.index, b));\n              });\n            }\n\n            a(d[b]).forEach(function (a, d) {\n              (d = C(a.id) && m.get(a.id) || m[b][c ? c[d] : d]) && d.coll === b && (d.update(a, !1), k && (d.touched = !0));\n              !d && k && m.collectionsWithInit[b] && (m.collectionsWithInit[b][0].apply(m, [a].concat(m.collectionsWithInit[b][1] || []).concat([!1])).touched = !0);\n            });\n            k && m[b].forEach(function (a) {\n              a.touched || a.options.isInternal ? delete a.touched : u.push(a);\n            });\n          }\n        });\n        u.forEach(function (a) {\n          a.remove && a.remove(!1);\n        });\n        F && m.axes.forEach(function (a) {\n          a.update({}, !1);\n        });\n        b && m.getSeriesOrderByLinks().forEach(function (a) {\n          a.chart && a.update({}, !1);\n        }, this);\n        d.loading && f(!0, m.options.loading, d.loading);\n        F = n && n.width;\n        n = n && n.height;\n        H(n) && (n = h(n, F || m.chartWidth));\n        w || v(F) && F !== m.chartWidth || v(n) && n !== m.chartHeight ? m.setSize(F, n, t) : l(g, !0) && m.redraw(t);\n        D(m, \"afterUpdate\", {\n          options: d,\n          redraw: g,\n          animation: t\n        });\n      },\n      setSubtitle: function (a, c) {\n        this.applyDescription(\"subtitle\", a);\n        this.layOutTitles(c);\n      },\n      setCaption: function (a, c) {\n        this.applyDescription(\"caption\", a);\n        this.layOutTitles(c);\n      }\n    });\n    u.prototype.collectionsWithInit = {\n      xAxis: [u.prototype.addAxis, [!0]],\n      yAxis: [u.prototype.addAxis, [!1]],\n      series: [u.prototype.addSeries]\n    };\n    r(g.prototype, {\n      update: function (a, c, d, f) {\n        function e() {\n          g.applyOptions(a);\n          var f = b && g.hasDummyGraphic;\n          f = null === g.y ? !f : f;\n          b && f && (g.graphic = b.destroy(), delete g.hasDummyGraphic);\n          m(a, !0) && (b && b.element && a && a.marker && \"undefined\" !== typeof a.marker.symbol && (g.graphic = b.destroy()), a && a.dataLabels && g.dataLabel && (g.dataLabel = g.dataLabel.destroy()), g.connector && (g.connector = g.connector.destroy()));\n          k = g.index;\n          h.updateParallelArrays(g, k);\n          y.data[k] = m(y.data[k], !0) || m(a, !0) ? g.options : l(a, y.data[k]);\n          h.isDirty = h.isDirtyData = !0;\n          !h.fixedBox && h.hasCartesianSeries && (t.isDirtyBox = !0);\n          \"point\" === y.legendType && (t.isDirtyLegend = !0);\n          c && t.redraw(d);\n        }\n\n        var g = this,\n            h = g.series,\n            b = g.graphic,\n            k,\n            t = h.chart,\n            y = h.options;\n        c = l(c, !0);\n        !1 === f ? e() : g.firePointEvent(\"update\", {\n          options: a\n        }, e);\n      },\n      remove: function (a, c) {\n        this.series.removePoint(this.series.data.indexOf(this), a, c);\n      }\n    });\n    r(t.prototype, {\n      addPoint: function (a, c, d, f, e) {\n        var g = this.options,\n            h = this.data,\n            b = this.chart,\n            k = this.xAxis;\n        k = k && k.hasNames && k.names;\n        var m = g.data,\n            t = this.xData,\n            y;\n        c = l(c, !0);\n        var w = {\n          series: this\n        };\n        this.pointClass.prototype.applyOptions.apply(w, [a]);\n        var r = w.x;\n        var q = t.length;\n        if (this.requireSorting && r < t[q - 1]) for (y = !0; q && t[q - 1] > r;) q--;\n        this.updateParallelArrays(w, \"splice\", q, 0, 0);\n        this.updateParallelArrays(w, q);\n        k && w.name && (k[r] = w.name);\n        m.splice(q, 0, a);\n        y && (this.data.splice(q, 0, null), this.processData());\n        \"point\" === g.legendType && this.generatePoints();\n        d && (h[0] && h[0].remove ? h[0].remove(!1) : (h.shift(), this.updateParallelArrays(w, \"shift\"), m.shift()));\n        !1 !== e && D(this, \"addPoint\", {\n          point: w\n        });\n        this.isDirtyData = this.isDirty = !0;\n        c && b.redraw(f);\n      },\n      removePoint: function (a, c, f) {\n        var e = this,\n            g = e.data,\n            h = g[a],\n            k = e.points,\n            b = e.chart,\n            m = function () {\n          k && k.length === g.length && k.splice(a, 1);\n          g.splice(a, 1);\n          e.options.data.splice(a, 1);\n          e.updateParallelArrays(h || {\n            series: e\n          }, \"splice\", a, 1);\n          h && h.destroy();\n          e.isDirty = !0;\n          e.isDirtyData = !0;\n          c && b.redraw();\n        };\n\n        d(f, b);\n        c = l(c, !0);\n        h ? h.firePointEvent(\"remove\", null, m) : m();\n      },\n      remove: function (a, c, d, f) {\n        function e() {\n          g.destroy(f);\n          g.remove = null;\n          h.isDirtyLegend = h.isDirtyBox = !0;\n          h.linkSeries();\n          l(a, !0) && h.redraw(c);\n        }\n\n        var g = this,\n            h = g.chart;\n        !1 !== d ? D(g, \"remove\", null, e) : e();\n      },\n      update: function (a, c) {\n        a = e.cleanRecursively(a, this.userOptions);\n        D(this, \"update\", {\n          options: a\n        });\n        var d = this,\n            g = d.chart,\n            h = d.userOptions,\n            k = d.initialType || d.type,\n            n = a.type || h.type || g.options.chart.type,\n            b = !(this.hasDerivedData || a.dataGrouping || n && n !== this.type || \"undefined\" !== typeof a.pointStart || a.pointInterval || a.pointIntervalUnit || a.keys),\n            m = w[k].prototype,\n            t,\n            y = [\"group\", \"markerGroup\", \"dataLabelsGroup\", \"transformGroup\"],\n            v = [\"eventOptions\", \"navigatorSeries\", \"baseSeries\"],\n            p = d.finishedAnimating && {\n          animation: !1\n        },\n            u = {};\n        b && (v.push(\"data\", \"isDirtyData\", \"points\", \"processedXData\", \"processedYData\", \"xIncrement\", \"_hasPointMarkers\", \"_hasPointLabels\", \"mapMap\", \"mapData\", \"minY\", \"maxY\", \"minX\", \"maxX\"), !1 !== a.visible && v.push(\"area\", \"graph\"), d.parallelArrays.forEach(function (a) {\n          v.push(a + \"Data\");\n        }), a.data && (a.dataSorting && r(d.options.dataSorting, a.dataSorting), this.setData(a.data, !1)));\n        a = f(h, p, {\n          index: \"undefined\" === typeof h.index ? d.index : h.index,\n          pointStart: l(h.pointStart, d.xData[0])\n        }, !b && {\n          data: d.options.data\n        }, a);\n        b && a.data && (a.data = d.options.data);\n        v = y.concat(v);\n        v.forEach(function (a) {\n          v[a] = d[a];\n          delete d[a];\n        });\n        d.remove(!1, null, !1, !0);\n\n        for (t in m) d[t] = void 0;\n\n        w[n || k] ? r(d, w[n || k].prototype) : z(17, !0, g, {\n          missingModuleFor: n || k\n        });\n        v.forEach(function (a) {\n          d[a] = v[a];\n        });\n        d.init(g, a);\n\n        if (b && this.points) {\n          var q = d.options;\n          !1 === q.visible ? (u.graphic = 1, u.dataLabel = 1) : d._hasPointLabels || (n = q.marker, m = q.dataLabels, n && (!1 === n.enabled || \"symbol\" in n) && (u.graphic = 1), m && !1 === m.enabled && (u.dataLabel = 1));\n          this.points.forEach(function (a) {\n            a && a.series && (a.resolveColor(), Object.keys(u).length && a.destroyElements(u), !1 === q.showInLegend && a.legendItem && g.legend.destroyItem(a));\n          }, this);\n        }\n\n        a.zIndex !== h.zIndex && y.forEach(function (b) {\n          d[b] && d[b].attr({\n            zIndex: a.zIndex\n          });\n        });\n        d.initialType = k;\n        g.linkSeries();\n        D(this, \"afterUpdate\");\n        l(c, !0) && g.redraw(b ? void 0 : !1);\n      },\n      setName: function (a) {\n        this.name = this.options.name = this.userOptions.name = a;\n        this.chart.isDirtyLegend = !0;\n      }\n    });\n    r(k.prototype, {\n      update: function (a, d) {\n        var e = this.chart,\n            g = a && a.events || {};\n        a = f(this.userOptions, a);\n        e.options[this.coll].indexOf && (e.options[this.coll][e.options[this.coll].indexOf(this.userOptions)] = a);\n        c(e.options[this.coll].events, function (a, c) {\n          \"undefined\" === typeof g[c] && (g[c] = void 0);\n        });\n        this.destroy(!0);\n        this.init(e, r(a, {\n          events: g\n        }));\n        e.isDirtyBox = !0;\n        l(d, !0) && e.redraw();\n      },\n      remove: function (a) {\n        for (var c = this.chart, d = this.coll, f = this.series, e = f.length; e--;) f[e] && f[e].remove(!1);\n\n        J(c.axes, this);\n        J(c[d], this);\n        M(c.options[d]) ? c.options[d].splice(this.options.index, 1) : delete c.options[d];\n        c[d].forEach(function (a, c) {\n          a.options.index = a.userOptions.index = c;\n        });\n        this.destroy();\n        c.isDirtyBox = !0;\n        l(a, !0) && c.redraw();\n      },\n      setTitle: function (a, c) {\n        this.update({\n          title: a\n        }, c);\n      },\n      setCategories: function (a, c) {\n        this.update({\n          categories: a\n        }, c);\n      }\n    });\n  });\n  R(p, \"parts/AreaSeries.js\", [p[\"parts/Globals.js\"], p[\"parts/Color.js\"], p[\"mixins/legend-symbol.js\"], p[\"parts/Utilities.js\"]], function (e, g, p, u) {\n    var K = g.parse,\n        L = u.objectEach,\n        E = u.pick;\n    g = u.seriesType;\n    var A = e.Series;\n    g(\"area\", \"line\", {\n      softThreshold: !1,\n      threshold: 0\n    }, {\n      singleStacks: !1,\n      getStackPoints: function (e) {\n        var g = [],\n            p = [],\n            r = this.xAxis,\n            u = this.yAxis,\n            A = u.stacks[this.stackKey],\n            v = {},\n            m = this.index,\n            C = u.series,\n            f = C.length,\n            c = E(u.options.reversedStacks, !0) ? 1 : -1,\n            l;\n        e = e || this.points;\n\n        if (this.options.stacking) {\n          for (l = 0; l < e.length; l++) e[l].leftNull = e[l].rightNull = void 0, v[e[l].x] = e[l];\n\n          L(A, function (c, a) {\n            null !== c.total && p.push(a);\n          });\n          p.sort(function (c, a) {\n            return c - a;\n          });\n          var h = C.map(function (c) {\n            return c.visible;\n          });\n          p.forEach(function (d, a) {\n            var e = 0,\n                t,\n                w;\n            if (v[d] && !v[d].isNull) g.push(v[d]), [-1, 1].forEach(function (e) {\n              var g = 1 === e ? \"rightNull\" : \"leftNull\",\n                  k = 0,\n                  r = A[p[a + e]];\n              if (r) for (l = m; 0 <= l && l < f;) t = r.points[l], t || (l === m ? v[d][g] = !0 : h[l] && (w = A[d].points[l]) && (k -= w[1] - w[0])), l += c;\n              v[d][1 === e ? \"rightCliff\" : \"leftCliff\"] = k;\n            });else {\n              for (l = m; 0 <= l && l < f;) {\n                if (t = A[d].points[l]) {\n                  e = t[1];\n                  break;\n                }\n\n                l += c;\n              }\n\n              e = u.translate(e, 0, 1, 0, 1);\n              g.push({\n                isNull: !0,\n                plotX: r.translate(d, 0, 0, 0, 1),\n                x: d,\n                plotY: e,\n                yBottom: e\n              });\n            }\n          });\n        }\n\n        return g;\n      },\n      getGraphPath: function (e) {\n        var g = A.prototype.getGraphPath,\n            p = this.options,\n            r = p.stacking,\n            u = this.yAxis,\n            C,\n            v = [],\n            m = [],\n            H = this.index,\n            f = u.stacks[this.stackKey],\n            c = p.threshold,\n            l = Math.round(u.getThreshold(p.threshold));\n        p = E(p.connectNulls, \"percent\" === r);\n\n        var h = function (d, g, h) {\n          var k = e[d];\n          d = r && f[k.x].points[H];\n          var t = k[h + \"Null\"] || 0;\n          h = k[h + \"Cliff\"] || 0;\n          k = !0;\n\n          if (h || t) {\n            var w = (t ? d[0] : d[1]) + h;\n            var p = d[0] + h;\n            k = !!t;\n          } else !r && e[g] && e[g].isNull && (w = p = c);\n\n          \"undefined\" !== typeof w && (m.push({\n            plotX: a,\n            plotY: null === w ? l : u.getThreshold(w),\n            isNull: k,\n            isCliff: !0\n          }), v.push({\n            plotX: a,\n            plotY: null === p ? l : u.getThreshold(p),\n            doCurve: !1\n          }));\n        };\n\n        e = e || this.points;\n        r && (e = this.getStackPoints(e));\n\n        for (C = 0; C < e.length; C++) {\n          r || (e[C].leftCliff = e[C].rightCliff = e[C].leftNull = e[C].rightNull = void 0);\n          var d = e[C].isNull;\n          var a = E(e[C].rectPlotX, e[C].plotX);\n          var k = E(e[C].yBottom, l);\n          if (!d || p) p || h(C, C - 1, \"left\"), d && !r && p || (m.push(e[C]), v.push({\n            x: C,\n            plotX: a,\n            plotY: k\n          })), p || h(C, C + 1, \"right\");\n        }\n\n        C = g.call(this, m, !0, !0);\n        v.reversed = !0;\n        d = g.call(this, v, !0, !0);\n        d.length && (d[0] = \"L\");\n        d = C.concat(d);\n        g = g.call(this, m, !1, p);\n        d.xMap = C.xMap;\n        this.areaPath = d;\n        return g;\n      },\n      drawGraph: function () {\n        this.areaPath = [];\n        A.prototype.drawGraph.apply(this);\n        var e = this,\n            g = this.areaPath,\n            p = this.options,\n            r = [[\"area\", \"highcharts-area\", this.color, p.fillColor]];\n        this.zones.forEach(function (g, u) {\n          r.push([\"zone-area-\" + u, \"highcharts-area highcharts-zone-area-\" + u + \" \" + g.className, g.color || e.color, g.fillColor || p.fillColor]);\n        });\n        r.forEach(function (r) {\n          var u = r[0],\n              v = e[u],\n              m = v ? \"animate\" : \"attr\",\n              z = {};\n          v ? (v.endX = e.preventGraphAnimation ? null : g.xMap, v.animate({\n            d: g\n          })) : (z.zIndex = 0, v = e[u] = e.chart.renderer.path(g).addClass(r[1]).add(e.group), v.isArea = !0);\n          e.chart.styledMode || (z.fill = E(r[3], K(r[2]).setOpacity(E(p.fillOpacity, .75)).get()));\n          v[m](z);\n          v.startX = g.xMap;\n          v.shiftUnit = p.step ? 2 : 1;\n        });\n      },\n      drawLegendSymbol: p.drawRectangle\n    });\n    \"\";\n  });\n  R(p, \"parts/SplineSeries.js\", [p[\"parts/Utilities.js\"]], function (e) {\n    var g = e.pick;\n    e = e.seriesType;\n    e(\"spline\", \"line\", {}, {\n      getPointSpline: function (e, p, K) {\n        var u = p.plotX,\n            E = p.plotY,\n            A = e[K - 1];\n        K = e[K + 1];\n\n        if (A && !A.isNull && !1 !== A.doCurve && !p.isCliff && K && !K.isNull && !1 !== K.doCurve && !p.isCliff) {\n          e = A.plotY;\n          var C = K.plotX;\n          K = K.plotY;\n          var J = 0;\n          var z = (1.5 * u + A.plotX) / 2.5;\n          var r = (1.5 * E + e) / 2.5;\n          C = (1.5 * u + C) / 2.5;\n          var D = (1.5 * E + K) / 2.5;\n          C !== z && (J = (D - r) * (C - u) / (C - z) + E - D);\n          r += J;\n          D += J;\n          r > e && r > E ? (r = Math.max(e, E), D = 2 * E - r) : r < e && r < E && (r = Math.min(e, E), D = 2 * E - r);\n          D > K && D > E ? (D = Math.max(K, E), r = 2 * E - D) : D < K && D < E && (D = Math.min(K, E), r = 2 * E - D);\n          p.rightContX = C;\n          p.rightContY = D;\n        }\n\n        p = [\"C\", g(A.rightContX, A.plotX), g(A.rightContY, A.plotY), g(z, u), g(r, E), u, E];\n        A.rightContX = A.rightContY = null;\n        return p;\n      }\n    });\n    \"\";\n  });\n  R(p, \"parts/AreaSplineSeries.js\", [p[\"parts/Globals.js\"], p[\"mixins/legend-symbol.js\"], p[\"parts/Utilities.js\"]], function (e, g, p) {\n    p = p.seriesType;\n    var u = e.seriesTypes.area.prototype;\n    p(\"areaspline\", \"spline\", e.defaultPlotOptions.area, {\n      getStackPoints: u.getStackPoints,\n      getGraphPath: u.getGraphPath,\n      drawGraph: u.drawGraph,\n      drawLegendSymbol: g.drawRectangle\n    });\n    \"\";\n  });\n  R(p, \"parts/ColumnSeries.js\", [p[\"parts/Globals.js\"], p[\"parts/Color.js\"], p[\"mixins/legend-symbol.js\"], p[\"parts/Utilities.js\"]], function (e, g, p, u) {\n    var K = g.parse,\n        L = u.animObject,\n        E = u.clamp,\n        A = u.defined,\n        C = u.extend,\n        J = u.isNumber,\n        z = u.merge,\n        r = u.pick;\n    g = u.seriesType;\n    var D = e.Series,\n        M = e.svg;\n    g(\"column\", \"line\", {\n      borderRadius: 0,\n      crisp: !0,\n      groupPadding: .2,\n      marker: null,\n      pointPadding: .1,\n      minPointLength: 0,\n      cropThreshold: 50,\n      pointRange: null,\n      states: {\n        hover: {\n          halo: !1,\n          brightness: .1\n        },\n        select: {\n          color: \"#cccccc\",\n          borderColor: \"#000000\"\n        }\n      },\n      dataLabels: {\n        align: null,\n        verticalAlign: null,\n        y: null\n      },\n      softThreshold: !1,\n      startFromThreshold: !0,\n      stickyTracking: !1,\n      tooltip: {\n        distance: 6\n      },\n      threshold: 0,\n      borderColor: \"#ffffff\"\n    }, {\n      cropShoulder: 0,\n      directTouch: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      negStacks: !0,\n      init: function () {\n        D.prototype.init.apply(this, arguments);\n        var e = this,\n            g = e.chart;\n        g.hasRendered && g.series.forEach(function (g) {\n          g.type === e.type && (g.isDirty = !0);\n        });\n      },\n      getColumnMetrics: function () {\n        var e = this,\n            g = e.options,\n            p = e.xAxis,\n            f = e.yAxis,\n            c = p.options.reversedStacks;\n        c = p.reversed && !c || !p.reversed && c;\n        var l,\n            h = {},\n            d = 0;\n        !1 === g.grouping ? d = 1 : e.chart.series.forEach(function (a) {\n          var c = a.yAxis,\n              g = a.options;\n\n          if (a.type === e.type && (a.visible || !e.chart.options.chart.ignoreHiddenSeries) && f.len === c.len && f.pos === c.pos) {\n            if (g.stacking) {\n              l = a.stackKey;\n              \"undefined\" === typeof h[l] && (h[l] = d++);\n              var k = h[l];\n            } else !1 !== g.grouping && (k = d++);\n\n            a.columnIndex = k;\n          }\n        });\n        var a = Math.min(Math.abs(p.transA) * (p.ordinalSlope || g.pointRange || p.closestPointRange || p.tickInterval || 1), p.len),\n            k = a * g.groupPadding,\n            t = (a - 2 * k) / (d || 1);\n        g = Math.min(g.maxPointWidth || p.len, r(g.pointWidth, t * (1 - 2 * g.pointPadding)));\n        e.columnMetrics = {\n          width: g,\n          offset: (t - g) / 2 + (k + ((e.columnIndex || 0) + (c ? 1 : 0)) * t - a / 2) * (c ? -1 : 1)\n        };\n        return e.columnMetrics;\n      },\n      crispCol: function (e, g, r, f) {\n        var c = this.chart,\n            l = this.borderWidth,\n            h = -(l % 2 ? .5 : 0);\n        l = l % 2 ? .5 : 1;\n        c.inverted && c.renderer.isVML && (l += 1);\n        this.options.crisp && (r = Math.round(e + r) + h, e = Math.round(e) + h, r -= e);\n        f = Math.round(g + f) + l;\n        h = .5 >= Math.abs(g) && .5 < f;\n        g = Math.round(g) + l;\n        f -= g;\n        h && f && (--g, f += 1);\n        return {\n          x: e,\n          y: g,\n          width: r,\n          height: f\n        };\n      },\n      translate: function () {\n        var e = this,\n            g = e.chart,\n            p = e.options,\n            f = e.dense = 2 > e.closestPointRange * e.xAxis.transA;\n        f = e.borderWidth = r(p.borderWidth, f ? 0 : 1);\n        var c = e.xAxis,\n            l = e.yAxis,\n            h = p.threshold,\n            d = e.translatedThreshold = l.getThreshold(h),\n            a = r(p.minPointLength, 5),\n            k = e.getColumnMetrics(),\n            t = k.width,\n            w = e.barW = Math.max(t, 1 + 2 * f),\n            y = e.pointXOffset = k.offset,\n            u = e.dataMin,\n            z = e.dataMax;\n        g.inverted && (d -= .5);\n        p.pointPadding && (w = Math.ceil(w));\n        D.prototype.translate.apply(e);\n        e.points.forEach(function (f) {\n          var k = r(f.yBottom, d),\n              m = 999 + Math.abs(k),\n              n = t,\n              b = f.plotX;\n          m = E(f.plotY, -m, l.len + m);\n          var p = f.plotX + y,\n              x = w,\n              v = Math.min(m, k),\n              F = Math.max(m, k) - v;\n\n          if (a && Math.abs(F) < a) {\n            F = a;\n            var I = !l.reversed && !f.negative || l.reversed && f.negative;\n            f.y === h && e.dataMax <= h && l.min < h && u !== z && (I = !I);\n            v = Math.abs(v - d) > a ? k - a : d - (I ? a : 0);\n          }\n\n          A(f.options.pointWidth) && (n = x = Math.ceil(f.options.pointWidth), p -= Math.round((n - t) / 2));\n          f.barX = p;\n          f.pointWidth = n;\n          f.tooltipPos = g.inverted ? [l.len + l.pos - g.plotLeft - m, c.len + c.pos - g.plotTop - (b || 0) - y - x / 2, F] : [p + x / 2, m + l.pos - g.plotTop, F];\n          f.shapeType = e.pointClass.prototype.shapeType || \"rect\";\n          f.shapeArgs = e.crispCol.apply(e, f.isNull ? [p, d, x, 0] : [p, v, x, F]);\n        });\n      },\n      getSymbol: e.noop,\n      drawLegendSymbol: p.drawRectangle,\n      drawGraph: function () {\n        this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n      },\n      pointAttribs: function (e, g) {\n        var m = this.options,\n            f = this.pointAttrToOptions || {};\n        var c = f.stroke || \"borderColor\";\n        var l = f[\"stroke-width\"] || \"borderWidth\",\n            h = e && e.color || this.color,\n            d = e && e[c] || m[c] || this.color || h,\n            a = e && e[l] || m[l] || this[l] || 0;\n        f = e && e.options.dashStyle || m.dashStyle;\n        var k = r(e && e.opacity, m.opacity, 1);\n\n        if (e && this.zones.length) {\n          var t = e.getZone();\n          h = e.options.color || t && (t.color || e.nonZonedColor) || this.color;\n          t && (d = t.borderColor || d, f = t.dashStyle || f, a = t.borderWidth || a);\n        }\n\n        g && e && (e = z(m.states[g], e.options.states && e.options.states[g] || {}), g = e.brightness, h = e.color || \"undefined\" !== typeof g && K(h).brighten(e.brightness).get() || h, d = e[c] || d, a = e[l] || a, f = e.dashStyle || f, k = r(e.opacity, k));\n        c = {\n          fill: h,\n          stroke: d,\n          \"stroke-width\": a,\n          opacity: k\n        };\n        f && (c.dashstyle = f);\n        return c;\n      },\n      drawPoints: function () {\n        var e = this,\n            g = this.chart,\n            r = e.options,\n            f = g.renderer,\n            c = r.animationLimit || 250,\n            l;\n        e.points.forEach(function (h) {\n          var d = h.graphic,\n              a = !!d,\n              k = d && g.pointCount < c ? \"animate\" : \"attr\";\n\n          if (J(h.plotY) && null !== h.y) {\n            l = h.shapeArgs;\n            d && h.hasNewShapeType() && (d = d.destroy());\n            e.enabledDataSorting && (h.startXPos = e.xAxis.reversed ? -(l ? l.width : 0) : e.xAxis.width);\n            d || (h.graphic = d = f[h.shapeType](l).add(h.group || e.group)) && e.enabledDataSorting && g.hasRendered && g.pointCount < c && (d.attr({\n              x: h.startXPos\n            }), a = !0, k = \"animate\");\n            if (d && a) d[k](z(l));\n            if (r.borderRadius) d[k]({\n              r: r.borderRadius\n            });\n            g.styledMode || d[k](e.pointAttribs(h, h.selected && \"select\")).shadow(!1 !== h.allowShadow && r.shadow, null, r.stacking && !r.borderRadius);\n            d.addClass(h.getClassName(), !0);\n          } else d && (h.graphic = d.destroy());\n        });\n      },\n      animate: function (e) {\n        var g = this,\n            r = this.yAxis,\n            f = g.options,\n            c = this.chart.inverted,\n            l = {},\n            h = c ? \"translateX\" : \"translateY\";\n        if (M) if (e) l.scaleY = .001, e = E(r.toPixels(f.threshold), r.pos, r.pos + r.len), c ? l.translateX = e - r.len : l.translateY = e, g.clipBox && g.setClip(), g.group.attr(l);else {\n          var d = g.group.attr(h);\n          g.group.animate({\n            scaleY: 1\n          }, C(L(g.options.animation), {\n            step: function (a, c) {\n              l[h] = d + c.pos * (r.pos - d);\n              g.group.attr(l);\n            }\n          }));\n          g.animate = null;\n        }\n      },\n      remove: function () {\n        var e = this,\n            g = e.chart;\n        g.hasRendered && g.series.forEach(function (g) {\n          g.type === e.type && (g.isDirty = !0);\n        });\n        D.prototype.remove.apply(e, arguments);\n      }\n    });\n    \"\";\n  });\n  R(p, \"parts/BarSeries.js\", [p[\"parts/Utilities.js\"]], function (e) {\n    e = e.seriesType;\n    e(\"bar\", \"column\", null, {\n      inverted: !0\n    });\n    \"\";\n  });\n  R(p, \"parts/ScatterSeries.js\", [p[\"parts/Globals.js\"], p[\"parts/Utilities.js\"]], function (e, g) {\n    var p = g.addEvent;\n    g = g.seriesType;\n    var u = e.Series;\n    g(\"scatter\", \"line\", {\n      lineWidth: 0,\n      findNearestPointBy: \"xy\",\n      jitter: {\n        x: 0,\n        y: 0\n      },\n      marker: {\n        enabled: !0\n      },\n      tooltip: {\n        headerFormat: '<span style=\"color:{point.color}\">\\u25cf</span> <span style=\"font-size: 10px\"> {series.name}</span><br/>',\n        pointFormat: \"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>\"\n      }\n    }, {\n      sorted: !1,\n      requireSorting: !1,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      takeOrdinalPosition: !1,\n      drawGraph: function () {\n        this.options.lineWidth && u.prototype.drawGraph.call(this);\n      },\n      applyJitter: function () {\n        var e = this,\n            g = this.options.jitter,\n            p = this.points.length;\n        g && this.points.forEach(function (u, C) {\n          [\"x\", \"y\"].forEach(function (A, z) {\n            var r = \"plot\" + A.toUpperCase();\n\n            if (g[A] && !u.isNull) {\n              var D = e[A + \"Axis\"];\n              var E = g[A] * D.transA;\n\n              if (D && !D.isLog) {\n                var v = Math.max(0, u[r] - E);\n                D = Math.min(D.len, u[r] + E);\n                z = 1E4 * Math.sin(C + z * p);\n                u[r] = v + (D - v) * (z - Math.floor(z));\n                \"x\" === A && (u.clientX = u.plotX);\n              }\n            }\n          });\n        });\n      }\n    });\n    p(u, \"afterTranslate\", function () {\n      this.applyJitter && this.applyJitter();\n    });\n    \"\";\n  });\n  R(p, \"mixins/centered-series.js\", [p[\"parts/Globals.js\"], p[\"parts/Utilities.js\"]], function (e, g) {\n    var p = g.isNumber,\n        u = g.pick,\n        K = g.relativeLength,\n        L = e.deg2rad;\n    e.CenteredSeriesMixin = {\n      getCenter: function () {\n        var e = this.options,\n            g = this.chart,\n            p = 2 * (e.slicedOffset || 0),\n            J = g.plotWidth - 2 * p,\n            z = g.plotHeight - 2 * p,\n            r = e.center,\n            D = Math.min(J, z),\n            M = e.size,\n            v = e.innerSize || 0;\n        \"string\" === typeof M && (M = parseFloat(M));\n        \"string\" === typeof v && (v = parseFloat(v));\n        e = [u(r[0], \"50%\"), u(r[1], \"50%\"), u(M && 0 > M ? void 0 : e.size, \"100%\"), u(v && 0 > v ? void 0 : e.innerSize || 0, \"0%\")];\n        g.angular && (e[3] = 0);\n\n        for (r = 0; 4 > r; ++r) M = e[r], g = 2 > r || 2 === r && /%$/.test(M), e[r] = K(M, [J, z, D, e[2]][r]) + (g ? p : 0);\n\n        e[3] > e[2] && (e[3] = e[2]);\n        return e;\n      },\n      getStartAndEndRadians: function (e, g) {\n        e = p(e) ? e : 0;\n        g = p(g) && g > e && 360 > g - e ? g : e + 360;\n        return {\n          start: L * (e + -90),\n          end: L * (g + -90)\n        };\n      }\n    };\n  });\n  R(p, \"parts/PieSeries.js\", [p[\"parts/Globals.js\"], p[\"mixins/legend-symbol.js\"], p[\"parts/Point.js\"], p[\"parts/Utilities.js\"]], function (e, g, p, u) {\n    var K = u.addEvent,\n        L = u.clamp,\n        E = u.defined,\n        A = u.fireEvent,\n        C = u.isNumber,\n        J = u.merge,\n        z = u.pick,\n        r = u.relativeLength,\n        D = u.seriesType,\n        M = u.setAnimation;\n    u = e.CenteredSeriesMixin;\n    var v = u.getStartAndEndRadians,\n        m = e.noop,\n        H = e.Series;\n    D(\"pie\", \"line\", {\n      center: [null, null],\n      clip: !1,\n      colorByPoint: !0,\n      dataLabels: {\n        allowOverlap: !0,\n        connectorPadding: 5,\n        connectorShape: \"fixedOffset\",\n        crookDistance: \"70%\",\n        distance: 30,\n        enabled: !0,\n        formatter: function () {\n          return this.point.isNull ? void 0 : this.point.name;\n        },\n        softConnector: !0,\n        x: 0\n      },\n      fillColor: void 0,\n      ignoreHiddenPoint: !0,\n      inactiveOtherPoints: !0,\n      legendType: \"point\",\n      marker: null,\n      size: null,\n      showInLegend: !1,\n      slicedOffset: 10,\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0\n      },\n      borderColor: \"#ffffff\",\n      borderWidth: 1,\n      lineWidth: void 0,\n      states: {\n        hover: {\n          brightness: .1\n        }\n      }\n    }, {\n      isCartesian: !1,\n      requireSorting: !1,\n      directTouch: !0,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      axisTypes: [],\n      pointAttribs: e.seriesTypes.column.prototype.pointAttribs,\n      animate: function (f) {\n        var c = this,\n            e = c.points,\n            g = c.startAngleRad;\n        f || (e.forEach(function (d) {\n          var a = d.graphic,\n              f = d.shapeArgs;\n          a && f && (a.attr({\n            r: z(d.startR, c.center && c.center[3] / 2),\n            start: g,\n            end: g\n          }), a.animate({\n            r: f.r,\n            start: f.start,\n            end: f.end\n          }, c.options.animation));\n        }), c.animate = null);\n      },\n      hasData: function () {\n        return !!this.processedXData.length;\n      },\n      updateTotals: function () {\n        var f,\n            c = 0,\n            e = this.points,\n            g = e.length,\n            d = this.options.ignoreHiddenPoint;\n\n        for (f = 0; f < g; f++) {\n          var a = e[f];\n          c += d && !a.visible ? 0 : a.isNull ? 0 : a.y;\n        }\n\n        this.total = c;\n\n        for (f = 0; f < g; f++) a = e[f], a.percentage = 0 < c && (a.visible || !d) ? a.y / c * 100 : 0, a.total = c;\n      },\n      generatePoints: function () {\n        H.prototype.generatePoints.call(this);\n        this.updateTotals();\n      },\n      getX: function (f, c, e) {\n        var g = this.center,\n            d = this.radii ? this.radii[e.index] : g[2] / 2;\n        f = Math.asin(L((f - g[1]) / (d + e.labelDistance), -1, 1));\n        return g[0] + (c ? -1 : 1) * Math.cos(f) * (d + e.labelDistance) + (0 < e.labelDistance ? (c ? -1 : 1) * this.options.dataLabels.padding : 0);\n      },\n      translate: function (f) {\n        this.generatePoints();\n        var c = 0,\n            e = this.options,\n            g = e.slicedOffset,\n            d = g + (e.borderWidth || 0),\n            a = v(e.startAngle, e.endAngle),\n            k = this.startAngleRad = a.start;\n        a = (this.endAngleRad = a.end) - k;\n        var t = this.points,\n            m = e.dataLabels.distance;\n        e = e.ignoreHiddenPoint;\n        var p,\n            u = t.length;\n        f || (this.center = f = this.getCenter());\n\n        for (p = 0; p < u; p++) {\n          var I = t[p];\n          var D = k + c * a;\n          if (!e || I.visible) c += I.percentage / 100;\n          var C = k + c * a;\n          I.shapeType = \"arc\";\n          I.shapeArgs = {\n            x: f[0],\n            y: f[1],\n            r: f[2] / 2,\n            innerR: f[3] / 2,\n            start: Math.round(1E3 * D) / 1E3,\n            end: Math.round(1E3 * C) / 1E3\n          };\n          I.labelDistance = z(I.options.dataLabels && I.options.dataLabels.distance, m);\n          I.labelDistance = r(I.labelDistance, I.shapeArgs.r);\n          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, I.labelDistance);\n          C = (C + D) / 2;\n          C > 1.5 * Math.PI ? C -= 2 * Math.PI : C < -Math.PI / 2 && (C += 2 * Math.PI);\n          I.slicedTranslation = {\n            translateX: Math.round(Math.cos(C) * g),\n            translateY: Math.round(Math.sin(C) * g)\n          };\n          var N = Math.cos(C) * f[2] / 2;\n          var n = Math.sin(C) * f[2] / 2;\n          I.tooltipPos = [f[0] + .7 * N, f[1] + .7 * n];\n          I.half = C < -Math.PI / 2 || C > Math.PI / 2 ? 1 : 0;\n          I.angle = C;\n          D = Math.min(d, I.labelDistance / 5);\n          I.labelPosition = {\n            natural: {\n              x: f[0] + N + Math.cos(C) * I.labelDistance,\n              y: f[1] + n + Math.sin(C) * I.labelDistance\n            },\n            \"final\": {},\n            alignment: 0 > I.labelDistance ? \"center\" : I.half ? \"right\" : \"left\",\n            connectorPosition: {\n              breakAt: {\n                x: f[0] + N + Math.cos(C) * D,\n                y: f[1] + n + Math.sin(C) * D\n              },\n              touchingSliceAt: {\n                x: f[0] + N,\n                y: f[1] + n\n              }\n            }\n          };\n        }\n\n        A(this, \"afterTranslate\");\n      },\n      drawEmpty: function () {\n        var f = this.options;\n\n        if (0 === this.total) {\n          var c = this.center[0];\n          var e = this.center[1];\n          this.graph || (this.graph = this.chart.renderer.circle(c, e, 0).addClass(\"highcharts-graph\").add(this.group));\n          this.graph.animate({\n            \"stroke-width\": f.borderWidth,\n            cx: c,\n            cy: e,\n            r: this.center[2] / 2,\n            fill: f.fillColor || \"none\",\n            stroke: f.color || \"#cccccc\"\n          }, this.options.animation);\n        } else this.graph && (this.graph = this.graph.destroy());\n      },\n      redrawPoints: function () {\n        var f = this,\n            c = f.chart,\n            e = c.renderer,\n            g,\n            d,\n            a,\n            k,\n            t = f.options.shadow;\n        this.drawEmpty();\n        !t || f.shadowGroup || c.styledMode || (f.shadowGroup = e.g(\"shadow\").attr({\n          zIndex: -1\n        }).add(f.group));\n        f.points.forEach(function (h) {\n          var l = {};\n          d = h.graphic;\n\n          if (!h.isNull && d) {\n            k = h.shapeArgs;\n            g = h.getTranslate();\n\n            if (!c.styledMode) {\n              var m = h.shadowGroup;\n              t && !m && (m = h.shadowGroup = e.g(\"shadow\").add(f.shadowGroup));\n              m && m.attr(g);\n              a = f.pointAttribs(h, h.selected && \"select\");\n            }\n\n            h.delayedRendering ? (d.setRadialReference(f.center).attr(k).attr(g), c.styledMode || d.attr(a).attr({\n              \"stroke-linejoin\": \"round\"\n            }).shadow(t, m), h.delayedRendering = !1) : (d.setRadialReference(f.center), c.styledMode || J(!0, l, a), J(!0, l, k, g), d.animate(l));\n            d.attr({\n              visibility: h.visible ? \"inherit\" : \"hidden\"\n            });\n            d.addClass(h.getClassName());\n          } else d && (h.graphic = d.destroy());\n        });\n      },\n      drawPoints: function () {\n        var f = this.chart.renderer;\n        this.points.forEach(function (c) {\n          c.graphic && c.hasNewShapeType() && (c.graphic = c.graphic.destroy());\n          c.graphic || (c.graphic = f[c.shapeType](c.shapeArgs).add(c.series.group), c.delayedRendering = !0);\n        });\n      },\n      searchPoint: m,\n      sortByAngle: function (f, c) {\n        f.sort(function (f, e) {\n          return \"undefined\" !== typeof f.angle && (e.angle - f.angle) * c;\n        });\n      },\n      drawLegendSymbol: g.drawRectangle,\n      getCenter: u.getCenter,\n      getSymbol: m,\n      drawGraph: null\n    }, {\n      init: function () {\n        p.prototype.init.apply(this, arguments);\n        var f = this;\n        f.name = z(f.name, \"Slice\");\n\n        var c = function (c) {\n          f.slice(\"select\" === c.type);\n        };\n\n        K(f, \"select\", c);\n        K(f, \"unselect\", c);\n        return f;\n      },\n      isValid: function () {\n        return C(this.y) && 0 <= this.y;\n      },\n      setVisible: function (f, c) {\n        var e = this,\n            g = e.series,\n            d = g.chart,\n            a = g.options.ignoreHiddenPoint;\n        c = z(c, a);\n        f !== e.visible && (e.visible = e.options.visible = f = \"undefined\" === typeof f ? !e.visible : f, g.options.data[g.data.indexOf(e)] = e.options, [\"graphic\", \"dataLabel\", \"connector\", \"shadowGroup\"].forEach(function (a) {\n          if (e[a]) e[a][f ? \"show\" : \"hide\"](!0);\n        }), e.legendItem && d.legend.colorizeItem(e, f), f || \"hover\" !== e.state || e.setState(\"\"), a && (g.isDirty = !0), c && d.redraw());\n      },\n      slice: function (f, c, e) {\n        var g = this.series;\n        M(e, g.chart);\n        z(c, !0);\n        this.sliced = this.options.sliced = E(f) ? f : !this.sliced;\n        g.options.data[g.data.indexOf(this)] = this.options;\n        this.graphic.animate(this.getTranslate());\n        this.shadowGroup && this.shadowGroup.animate(this.getTranslate());\n      },\n      getTranslate: function () {\n        return this.sliced ? this.slicedTranslation : {\n          translateX: 0,\n          translateY: 0\n        };\n      },\n      haloPath: function (f) {\n        var c = this.shapeArgs;\n        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(c.x, c.y, c.r + f, c.r + f, {\n          innerR: c.r - 1,\n          start: c.start,\n          end: c.end\n        });\n      },\n      connectorShapes: {\n        fixedOffset: function (f, c, e) {\n          var g = c.breakAt;\n          c = c.touchingSliceAt;\n          return [\"M\", f.x, f.y].concat(e.softConnector ? [\"C\", f.x + (\"left\" === f.alignment ? -5 : 5), f.y, 2 * g.x - c.x, 2 * g.y - c.y, g.x, g.y] : [\"L\", g.x, g.y]).concat([\"L\", c.x, c.y]);\n        },\n        straight: function (f, c) {\n          c = c.touchingSliceAt;\n          return [\"M\", f.x, f.y, \"L\", c.x, c.y];\n        },\n        crookedLine: function (f, c, e) {\n          c = c.touchingSliceAt;\n          var g = this.series,\n              d = g.center[0],\n              a = g.chart.plotWidth,\n              k = g.chart.plotLeft;\n          g = f.alignment;\n          var l = this.shapeArgs.r;\n          e = r(e.crookDistance, 1);\n          e = \"left\" === g ? d + l + (a + k - d - l) * (1 - e) : k + (d - l) * e;\n          d = [\"L\", e, f.y];\n          if (\"left\" === g ? e > f.x || e < c.x : e < f.x || e > c.x) d = [];\n          return [\"M\", f.x, f.y].concat(d).concat([\"L\", c.x, c.y]);\n        }\n      },\n      getConnectorPath: function () {\n        var e = this.labelPosition,\n            c = this.series.options.dataLabels,\n            g = c.connectorShape,\n            h = this.connectorShapes;\n        h[g] && (g = h[g]);\n        return g.call(this, {\n          x: e.final.x,\n          y: e.final.y,\n          alignment: e.alignment\n        }, e.connectorPosition, c);\n      }\n    });\n    \"\";\n  });\n  R(p, \"parts/DataLabels.js\", [p[\"parts/Globals.js\"], p[\"parts/Utilities.js\"]], function (e, g) {\n    var p = g.animObject,\n        u = g.arrayMax,\n        K = g.clamp,\n        L = g.defined,\n        E = g.extend,\n        A = g.format,\n        C = g.isArray,\n        J = g.merge,\n        z = g.objectEach,\n        r = g.pick,\n        D = g.relativeLength,\n        M = g.splat,\n        v = g.stableSort;\n    g = e.noop;\n    var m = e.Series,\n        H = e.seriesTypes;\n\n    e.distribute = function (f, c, g) {\n      function h(a, c) {\n        return a.target - c.target;\n      }\n\n      var d,\n          a = !0,\n          k = f,\n          l = [];\n      var m = 0;\n      var p = k.reducedLen || c;\n\n      for (d = f.length; d--;) m += f[d].size;\n\n      if (m > p) {\n        v(f, function (a, c) {\n          return (c.rank || 0) - (a.rank || 0);\n        });\n\n        for (m = d = 0; m <= p;) m += f[d].size, d++;\n\n        l = f.splice(d - 1, f.length);\n      }\n\n      v(f, h);\n\n      for (f = f.map(function (a) {\n        return {\n          size: a.size,\n          targets: [a.target],\n          align: r(a.align, .5)\n        };\n      }); a;) {\n        for (d = f.length; d--;) a = f[d], m = (Math.min.apply(0, a.targets) + Math.max.apply(0, a.targets)) / 2, a.pos = K(m - a.size * a.align, 0, c - a.size);\n\n        d = f.length;\n\n        for (a = !1; d--;) 0 < d && f[d - 1].pos + f[d - 1].size > f[d].pos && (f[d - 1].size += f[d].size, f[d - 1].targets = f[d - 1].targets.concat(f[d].targets), f[d - 1].align = .5, f[d - 1].pos + f[d - 1].size > c && (f[d - 1].pos = c - f[d - 1].size), f.splice(d, 1), a = !0);\n      }\n\n      k.push.apply(k, l);\n      d = 0;\n      f.some(function (a) {\n        var f = 0;\n        if (a.targets.some(function () {\n          k[d].pos = a.pos + f;\n          if (\"undefined\" !== typeof g && Math.abs(k[d].pos - k[d].target) > g) return k.slice(0, d + 1).forEach(function (a) {\n            delete a.pos;\n          }), k.reducedLen = (k.reducedLen || c) - .1 * c, k.reducedLen > .1 * c && e.distribute(k, c, g), !0;\n          f += k[d].size;\n          d++;\n        })) return !0;\n      });\n      v(k, h);\n    };\n\n    m.prototype.drawDataLabels = function () {\n      function f(a, c) {\n        var b = c.filter;\n        return b ? (c = b.operator, a = a[b.property], b = b.value, \">\" === c && a > b || \"<\" === c && a < b || \">=\" === c && a >= b || \"<=\" === c && a <= b || \"==\" === c && a == b || \"===\" === c && a === b ? !0 : !1) : !0;\n      }\n\n      function c(a, c) {\n        var b = [],\n            d;\n        if (C(a) && !C(c)) b = a.map(function (a) {\n          return J(a, c);\n        });else if (C(c) && !C(a)) b = c.map(function (b) {\n          return J(a, b);\n        });else if (C(a) || C(c)) for (d = Math.max(a.length, c.length); d--;) b[d] = J(a[d], c[d]);else b = J(a, c);\n        return b;\n      }\n\n      var g = this,\n          h = g.chart,\n          d = g.options,\n          a = d.dataLabels,\n          k = g.points,\n          m,\n          w = g.hasRendered || 0,\n          y = p(d.animation).duration,\n          u = Math.min(y, 200),\n          v = !h.renderer.forExport && r(a.defer, 0 < u),\n          D = h.renderer;\n      a = c(c(h.options.plotOptions && h.options.plotOptions.series && h.options.plotOptions.series.dataLabels, h.options.plotOptions && h.options.plotOptions[g.type] && h.options.plotOptions[g.type].dataLabels), a);\n      e.fireEvent(this, \"drawDataLabels\");\n\n      if (C(a) || a.enabled || g._hasPointLabels) {\n        var E = g.plotGroup(\"dataLabelsGroup\", \"data-labels\", v && !w ? \"hidden\" : \"inherit\", a.zIndex || 6);\n        v && (E.attr({\n          opacity: +w\n        }), w || setTimeout(function () {\n          var a = g.dataLabelsGroup;\n          a && (g.visible && E.show(!0), a[d.animation ? \"animate\" : \"attr\"]({\n            opacity: 1\n          }, {\n            duration: u\n          }));\n        }, y - u));\n        k.forEach(function (e) {\n          m = M(c(a, e.dlOptions || e.options && e.options.dataLabels));\n          m.forEach(function (a, b) {\n            var c = a.enabled && (!e.isNull || e.dataLabelOnNull) && f(e, a),\n                k = e.dataLabels ? e.dataLabels[b] : e.dataLabel,\n                l = e.connectors ? e.connectors[b] : e.connector,\n                n = r(a.distance, e.labelDistance),\n                m = !k;\n\n            if (c) {\n              var t = e.getLabelConfig();\n              var q = r(a[e.formatPrefix + \"Format\"], a.format);\n              t = L(q) ? A(q, t, h) : (a[e.formatPrefix + \"Formatter\"] || a.formatter).call(t, a);\n              q = a.style;\n              var p = a.rotation;\n              h.styledMode || (q.color = r(a.color, q.color, g.color, \"#000000\"), \"contrast\" === q.color ? (e.contrastColor = D.getContrast(e.color || g.color), q.color = !L(n) && a.inside || 0 > n || d.stacking ? e.contrastColor : \"#000000\") : delete e.contrastColor, d.cursor && (q.cursor = d.cursor));\n              var w = {\n                r: a.borderRadius || 0,\n                rotation: p,\n                padding: a.padding,\n                zIndex: 1\n              };\n              h.styledMode || (w.fill = a.backgroundColor, w.stroke = a.borderColor, w[\"stroke-width\"] = a.borderWidth);\n              z(w, function (a, b) {\n                \"undefined\" === typeof a && delete w[b];\n              });\n            }\n\n            !k || c && L(t) ? c && L(t) && (k ? w.text = t : (e.dataLabels = e.dataLabels || [], k = e.dataLabels[b] = p ? D.text(t, 0, -9999, a.useHTML).addClass(\"highcharts-data-label\") : D.label(t, 0, -9999, a.shape, null, null, a.useHTML, null, \"data-label\"), b || (e.dataLabel = k), k.addClass(\" highcharts-data-label-color-\" + e.colorIndex + \" \" + (a.className || \"\") + (a.useHTML ? \" highcharts-tracker\" : \"\"))), k.options = a, k.attr(w), h.styledMode || k.css(q).shadow(a.shadow), k.added || k.add(E), a.textPath && !a.useHTML && (k.setTextPath(e.getDataLabelPath && e.getDataLabelPath(k) || e.graphic, a.textPath), e.dataLabelPath && !a.textPath.enabled && (e.dataLabelPath = e.dataLabelPath.destroy())), g.alignDataLabel(e, k, a, null, m)) : (e.dataLabel = e.dataLabel && e.dataLabel.destroy(), e.dataLabels && (1 === e.dataLabels.length ? delete e.dataLabels : delete e.dataLabels[b]), b || delete e.dataLabel, l && (e.connector = e.connector.destroy(), e.connectors && (1 === e.connectors.length ? delete e.connectors : delete e.connectors[b])));\n          });\n        });\n      }\n\n      e.fireEvent(this, \"afterDrawDataLabels\");\n    };\n\n    m.prototype.alignDataLabel = function (e, c, g, h, d) {\n      var a = this,\n          f = this.chart,\n          l = this.isCartesian && f.inverted,\n          m = this.enabledDataSorting,\n          p = r(e.dlBox && e.dlBox.centerX, e.plotX, -9999),\n          u = r(e.plotY, -9999),\n          v = c.getBBox(),\n          z = g.rotation,\n          A = g.align,\n          C = f.isInsidePlot(p, Math.round(u), l),\n          n = \"justify\" === r(g.overflow, m ? \"none\" : \"justify\"),\n          b = this.visible && !1 !== e.visible && (e.series.forceDL || m && !n || C || g.inside && h && f.isInsidePlot(p, l ? h.x + 1 : h.y + h.height - 1, l));\n\n      var B = function (b) {\n        m && a.xAxis && !n && a.setDataLabelStartPos(e, c, d, C, b);\n      };\n\n      if (b) {\n        var x = f.renderer.fontMetrics(f.styledMode ? void 0 : g.style.fontSize, c).b;\n        h = E({\n          x: l ? this.yAxis.len - u : p,\n          y: Math.round(l ? this.xAxis.len - p : u),\n          width: 0,\n          height: 0\n        }, h);\n        E(g, {\n          width: v.width,\n          height: v.height\n        });\n        z ? (n = !1, p = f.renderer.rotCorr(x, z), p = {\n          x: h.x + g.x + h.width / 2 + p.x,\n          y: h.y + g.y + {\n            top: 0,\n            middle: .5,\n            bottom: 1\n          }[g.verticalAlign] * h.height\n        }, B(p), c[d ? \"attr\" : \"animate\"](p).attr({\n          align: A\n        }), B = (z + 720) % 360, B = 180 < B && 360 > B, \"left\" === A ? p.y -= B ? v.height : 0 : \"center\" === A ? (p.x -= v.width / 2, p.y -= v.height / 2) : \"right\" === A && (p.x -= v.width, p.y -= B ? 0 : v.height), c.placed = !0, c.alignAttr = p) : (B(h), c.align(g, null, h), p = c.alignAttr);\n        n && 0 <= h.height ? this.justifyDataLabel(c, g, p, v, h, d) : r(g.crop, !0) && (b = f.isInsidePlot(p.x, p.y) && f.isInsidePlot(p.x + v.width, p.y + v.height));\n        if (g.shape && !z) c[d ? \"attr\" : \"animate\"]({\n          anchorX: l ? f.plotWidth - e.plotY : e.plotX,\n          anchorY: l ? f.plotHeight - e.plotX : e.plotY\n        });\n      }\n\n      d && m && (c.placed = !1);\n      b || m && !n || (c.hide(!0), c.placed = !1);\n    };\n\n    m.prototype.setDataLabelStartPos = function (e, c, g, h, d) {\n      var a = this.chart,\n          f = a.inverted,\n          l = this.xAxis,\n          m = l.reversed,\n          p = f ? c.height / 2 : c.width / 2;\n      e = (e = e.pointWidth) ? e / 2 : 0;\n      l = f ? d.x : m ? -p - e : l.width - p + e;\n      d = f ? m ? this.yAxis.height - p + e : -p - e : d.y;\n      c.startXPos = l;\n      c.startYPos = d;\n      h ? \"hidden\" === c.visibility && (c.show(), c.attr({\n        opacity: 0\n      }).animate({\n        opacity: 1\n      })) : c.attr({\n        opacity: 1\n      }).animate({\n        opacity: 0\n      }, void 0, c.hide);\n      a.hasRendered && (g && c.attr({\n        x: c.startXPos,\n        y: c.startYPos\n      }), c.placed = !0);\n    };\n\n    m.prototype.justifyDataLabel = function (e, c, g, h, d, a) {\n      var f = this.chart,\n          l = c.align,\n          m = c.verticalAlign,\n          p = e.box ? 0 : e.padding || 0;\n      var r = g.x + p;\n\n      if (0 > r) {\n        \"right\" === l ? (c.align = \"left\", c.inside = !0) : c.x = -r;\n        var u = !0;\n      }\n\n      r = g.x + h.width - p;\n      r > f.plotWidth && (\"left\" === l ? (c.align = \"right\", c.inside = !0) : c.x = f.plotWidth - r, u = !0);\n      r = g.y + p;\n      0 > r && (\"bottom\" === m ? (c.verticalAlign = \"top\", c.inside = !0) : c.y = -r, u = !0);\n      r = g.y + h.height - p;\n      r > f.plotHeight && (\"top\" === m ? (c.verticalAlign = \"bottom\", c.inside = !0) : c.y = f.plotHeight - r, u = !0);\n      u && (e.placed = !a, e.align(c, null, d));\n      return u;\n    };\n\n    H.pie && (H.pie.prototype.dataLabelPositioners = {\n      radialDistributionY: function (e) {\n        return e.top + e.distributeBox.pos;\n      },\n      radialDistributionX: function (e, c, g, h) {\n        return e.getX(g < c.top + 2 || g > c.bottom - 2 ? h : g, c.half, c);\n      },\n      justify: function (e, c, g) {\n        return g[0] + (e.half ? -1 : 1) * (c + e.labelDistance);\n      },\n      alignToPlotEdges: function (e, c, g, h) {\n        e = e.getBBox().width;\n        return c ? e + h : g - e - h;\n      },\n      alignToConnectors: function (e, c, g, h) {\n        var d = 0,\n            a;\n        e.forEach(function (c) {\n          a = c.dataLabel.getBBox().width;\n          a > d && (d = a);\n        });\n        return c ? d + h : g - d - h;\n      }\n    }, H.pie.prototype.drawDataLabels = function () {\n      var f = this,\n          c = f.data,\n          g,\n          h = f.chart,\n          d = f.options.dataLabels || {},\n          a = d.connectorPadding,\n          k,\n          t = h.plotWidth,\n          p = h.plotHeight,\n          v = h.plotLeft,\n          z = Math.round(h.chartWidth / 3),\n          A,\n          C = f.center,\n          D = C[2] / 2,\n          N = C[1],\n          n,\n          b,\n          B,\n          x,\n          E = [[], []],\n          H,\n          M,\n          K,\n          q,\n          Q = [0, 0, 0, 0],\n          R = f.dataLabelPositioners,\n          X;\n      f.visible && (d.enabled || f._hasPointLabels) && (c.forEach(function (a) {\n        a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({\n          width: \"auto\"\n        }).css({\n          width: \"auto\",\n          textOverflow: \"clip\"\n        }), a.dataLabel.shortened = !1);\n      }), m.prototype.drawDataLabels.apply(f), c.forEach(function (a) {\n        a.dataLabel && (a.visible ? (E[a.half].push(a), a.dataLabel._pos = null, !L(d.style.width) && !L(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > z && (a.dataLabel.css({\n          width: .7 * z\n        }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));\n      }), E.forEach(function (c, k) {\n        var l = c.length,\n            m = [],\n            w;\n\n        if (l) {\n          f.sortByAngle(c, k - .5);\n\n          if (0 < f.maxLabelDistance) {\n            var u = Math.max(0, N - D - f.maxLabelDistance);\n            var y = Math.min(N + D + f.maxLabelDistance, h.plotHeight);\n            c.forEach(function (a) {\n              0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, N - D - a.labelDistance), a.bottom = Math.min(N + D + a.labelDistance, h.plotHeight), w = a.dataLabel.getBBox().height || 21, a.distributeBox = {\n                target: a.labelPosition.natural.y - a.top + w / 2,\n                size: w,\n                rank: a.y\n              }, m.push(a.distributeBox));\n            });\n            u = y + w - u;\n            e.distribute(m, u, u / 5);\n          }\n\n          for (q = 0; q < l; q++) {\n            g = c[q];\n            B = g.labelPosition;\n            n = g.dataLabel;\n            K = !1 === g.visible ? \"hidden\" : \"inherit\";\n            M = u = B.natural.y;\n            m && L(g.distributeBox) && (\"undefined\" === typeof g.distributeBox.pos ? K = \"hidden\" : (x = g.distributeBox.size, M = R.radialDistributionY(g)));\n            delete g.positionIndex;\n            if (d.justify) H = R.justify(g, D, C);else switch (d.alignTo) {\n              case \"connectors\":\n                H = R.alignToConnectors(c, k, t, v);\n                break;\n\n              case \"plotEdges\":\n                H = R.alignToPlotEdges(n, k, t, v);\n                break;\n\n              default:\n                H = R.radialDistributionX(f, g, M, u);\n            }\n            n._attr = {\n              visibility: K,\n              align: B.alignment\n            };\n            X = g.options.dataLabels || {};\n            n._pos = {\n              x: H + r(X.x, d.x) + ({\n                left: a,\n                right: -a\n              }[B.alignment] || 0),\n              y: M + r(X.y, d.y) - 10\n            };\n            B.final.x = H;\n            B.final.y = M;\n            r(d.crop, !0) && (b = n.getBBox().width, u = null, H - b < a && 1 === k ? (u = Math.round(b - H + a), Q[3] = Math.max(u, Q[3])) : H + b > t - a && 0 === k && (u = Math.round(H + b - t + a), Q[1] = Math.max(u, Q[1])), 0 > M - x / 2 ? Q[0] = Math.max(Math.round(-M + x / 2), Q[0]) : M + x / 2 > p && (Q[2] = Math.max(Math.round(M + x / 2 - p), Q[2])), n.sideOverflow = u);\n          }\n        }\n      }), 0 === u(Q) || this.verifyDataLabelOverflow(Q)) && (this.placeDataLabels(), this.points.forEach(function (a) {\n        X = J(d, a.options.dataLabels);\n\n        if (k = r(X.connectorWidth, 1)) {\n          var b;\n          A = a.connector;\n\n          if ((n = a.dataLabel) && n._pos && a.visible && 0 < a.labelDistance) {\n            K = n._attr.visibility;\n            if (b = !A) a.connector = A = h.renderer.path().addClass(\"highcharts-data-label-connector  highcharts-color-\" + a.colorIndex + (a.className ? \" \" + a.className : \"\")).add(f.dataLabelsGroup), h.styledMode || A.attr({\n              \"stroke-width\": k,\n              stroke: X.connectorColor || a.color || \"#666666\"\n            });\n            A[b ? \"attr\" : \"animate\"]({\n              d: a.getConnectorPath()\n            });\n            A.attr(\"visibility\", K);\n          } else A && (a.connector = A.destroy());\n        }\n      }));\n    }, H.pie.prototype.placeDataLabels = function () {\n      this.points.forEach(function (e) {\n        var c = e.dataLabel,\n            f;\n        c && e.visible && ((f = c._pos) ? (c.sideOverflow && (c._attr.width = Math.max(c.getBBox().width - c.sideOverflow, 0), c.css({\n          width: c._attr.width + \"px\",\n          textOverflow: (this.options.dataLabels.style || {}).textOverflow || \"ellipsis\"\n        }), c.shortened = !0), c.attr(c._attr), c[c.moved ? \"animate\" : \"attr\"](f), c.moved = !0) : c && c.attr({\n          y: -9999\n        }));\n        delete e.distributeBox;\n      }, this);\n    }, H.pie.prototype.alignDataLabel = g, H.pie.prototype.verifyDataLabelOverflow = function (e) {\n      var c = this.center,\n          f = this.options,\n          g = f.center,\n          d = f.minSize || 80,\n          a = null !== f.size;\n\n      if (!a) {\n        if (null !== g[0]) var k = Math.max(c[2] - Math.max(e[1], e[3]), d);else k = Math.max(c[2] - e[1] - e[3], d), c[0] += (e[3] - e[1]) / 2;\n        null !== g[1] ? k = K(k, d, c[2] - Math.max(e[0], e[2])) : (k = K(k, d, c[2] - e[0] - e[2]), c[1] += (e[0] - e[2]) / 2);\n        k < c[2] ? (c[2] = k, c[3] = Math.min(D(f.innerSize || 0, k), k), this.translate(c), this.drawDataLabels && this.drawDataLabels()) : a = !0;\n      }\n\n      return a;\n    });\n    H.column && (H.column.prototype.alignDataLabel = function (e, c, g, h, d) {\n      var a = this.chart.inverted,\n          f = e.series,\n          l = e.dlBox || e.shapeArgs,\n          p = r(e.below, e.plotY > r(this.translatedThreshold, f.yAxis.len)),\n          u = r(g.inside, !!this.options.stacking);\n      l && (h = J(l), 0 > h.y && (h.height += h.y, h.y = 0), l = h.y + h.height - f.yAxis.len, 0 < l && l < h.height && (h.height -= l), a && (h = {\n        x: f.yAxis.len - h.y - h.height,\n        y: f.xAxis.len - h.x - h.width,\n        width: h.height,\n        height: h.width\n      }), u || (a ? (h.x += p ? 0 : h.width, h.width = 0) : (h.y += p ? h.height : 0, h.height = 0)));\n      g.align = r(g.align, !a || u ? \"center\" : p ? \"right\" : \"left\");\n      g.verticalAlign = r(g.verticalAlign, a || u ? \"middle\" : p ? \"top\" : \"bottom\");\n      m.prototype.alignDataLabel.call(this, e, c, g, h, d);\n      g.inside && e.contrastColor && c.css({\n        color: e.contrastColor\n      });\n    });\n  });\n  R(p, \"modules/overlapping-datalabels.src.js\", [p[\"parts/Globals.js\"], p[\"parts/Utilities.js\"]], function (e, g) {\n    var p = g.addEvent,\n        u = g.fireEvent,\n        K = g.isArray,\n        L = g.objectEach,\n        E = g.pick;\n    e = e.Chart;\n    p(e, \"render\", function () {\n      var e = [];\n      (this.labelCollectors || []).forEach(function (g) {\n        e = e.concat(g());\n      });\n      (this.yAxis || []).forEach(function (g) {\n        g.options.stackLabels && !g.options.stackLabels.allowOverlap && L(g.stacks, function (g) {\n          L(g, function (g) {\n            e.push(g.label);\n          });\n        });\n      });\n      (this.series || []).forEach(function (g) {\n        var p = g.options.dataLabels;\n        g.visible && (!1 !== p.enabled || g._hasPointLabels) && (g.nodes || g.points).forEach(function (g) {\n          g.visible && (K(g.dataLabels) ? g.dataLabels : g.dataLabel ? [g.dataLabel] : []).forEach(function (p) {\n            var r = p.options;\n            p.labelrank = E(r.labelrank, g.labelrank, g.shapeArgs && g.shapeArgs.height);\n            r.allowOverlap || e.push(p);\n          });\n        });\n      });\n      this.hideOverlappingLabels(e);\n    });\n\n    e.prototype.hideOverlappingLabels = function (e) {\n      var g = this,\n          p = e.length,\n          z = g.renderer,\n          r,\n          A,\n          E,\n          v = !1;\n\n      var m = function (c) {\n        var e = c.box ? 0 : c.padding || 0;\n        var f = 0;\n\n        if (c && (!c.alignAttr || c.placed)) {\n          var d = c.alignAttr || {\n            x: c.attr(\"x\"),\n            y: c.attr(\"y\")\n          };\n          var a = c.parentGroup;\n          c.width || (f = c.getBBox(), c.width = f.width, c.height = f.height, f = z.fontMetrics(null, c.element).h);\n          return {\n            x: d.x + (a.translateX || 0) + e,\n            y: d.y + (a.translateY || 0) + e - f,\n            width: c.width - 2 * e,\n            height: c.height - 2 * e\n          };\n        }\n      };\n\n      for (A = 0; A < p; A++) if (r = e[A]) r.oldOpacity = r.opacity, r.newOpacity = 1, r.absoluteBox = m(r);\n\n      e.sort(function (c, e) {\n        return (e.labelrank || 0) - (c.labelrank || 0);\n      });\n\n      for (A = 0; A < p; A++) {\n        var H = (m = e[A]) && m.absoluteBox;\n\n        for (r = A + 1; r < p; ++r) {\n          var f = (E = e[r]) && E.absoluteBox;\n          !H || !f || m === E || 0 === m.newOpacity || 0 === E.newOpacity || f.x > H.x + H.width || f.x + f.width < H.x || f.y > H.y + H.height || f.y + f.height < H.y || ((m.labelrank < E.labelrank ? m : E).newOpacity = 0);\n        }\n      }\n\n      e.forEach(function (c) {\n        var e;\n\n        if (c) {\n          var f = c.newOpacity;\n          c.oldOpacity !== f && (c.alignAttr && c.placed ? (f ? c.show(!0) : e = function () {\n            c.hide(!0);\n            c.placed = !1;\n          }, v = !0, c.alignAttr.opacity = f, c[c.isOld ? \"animate\" : \"attr\"](c.alignAttr, null, e), u(g, \"afterHideOverlappingLabel\")) : c.attr({\n            opacity: f\n          }));\n          c.isOld = !0;\n        }\n      });\n      v && u(g, \"afterHideAllOverlappingLabels\");\n    };\n  });\n  R(p, \"parts/Interaction.js\", [p[\"parts/Globals.js\"], p[\"parts/Legend.js\"], p[\"parts/Point.js\"], p[\"parts/Utilities.js\"]], function (e, g, p, u) {\n    var K = u.addEvent,\n        L = u.createElement,\n        E = u.css,\n        A = u.defined,\n        C = u.extend,\n        J = u.fireEvent,\n        z = u.isArray,\n        r = u.isFunction,\n        D = u.isObject,\n        M = u.merge,\n        v = u.objectEach,\n        m = u.pick;\n    u = e.Chart;\n    var H = e.defaultOptions,\n        f = e.defaultPlotOptions,\n        c = e.hasTouch,\n        l = e.Series,\n        h = e.seriesTypes,\n        d = e.svg;\n    e = e.TrackerMixin = {\n      drawTrackerPoint: function () {\n        var a = this,\n            d = a.chart,\n            e = d.pointer,\n            f = function (a) {\n          var c = e.getPointFromEvent(a);\n          \"undefined\" !== typeof c && (e.isDirectTouch = !0, c.onMouseOver(a));\n        },\n            g;\n\n        a.points.forEach(function (a) {\n          g = z(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : [];\n          a.graphic && (a.graphic.element.point = a);\n          g.forEach(function (c) {\n            c.div ? c.div.point = a : c.element.point = a;\n          });\n        });\n        a._hasTracking || (a.trackerGroups.forEach(function (g) {\n          if (a[g]) {\n            a[g].addClass(\"highcharts-tracker\").on(\"mouseover\", f).on(\"mouseout\", function (a) {\n              e.onTrackerMouseOut(a);\n            });\n            if (c) a[g].on(\"touchstart\", f);\n            !d.styledMode && a.options.cursor && a[g].css(E).css({\n              cursor: a.options.cursor\n            });\n          }\n        }), a._hasTracking = !0);\n        J(this, \"afterDrawTracker\");\n      },\n      drawTrackerGraph: function () {\n        var a = this,\n            e = a.options,\n            f = e.trackByArea,\n            g = [].concat(f ? a.areaPath : a.graphPath),\n            h = g.length,\n            l = a.chart,\n            m = l.pointer,\n            p = l.renderer,\n            r = l.options.tooltip.snap,\n            u = a.tracker,\n            n,\n            b = function (b) {\n          m.normalize(b);\n          if (l.hoverSeries !== a && !m.isStickyTooltip(b)) a.onMouseOver();\n        },\n            v = \"rgba(192,192,192,\" + (d ? .0001 : .002) + \")\";\n\n        if (h && !f) for (n = h + 1; n--;) \"M\" === g[n] && g.splice(n + 1, 0, g[n + 1] - r, g[n + 2], \"L\"), (n && \"M\" === g[n] || n === h) && g.splice(n, 0, \"L\", g[n - 2] + r, g[n - 1]);\n        u ? u.attr({\n          d: g\n        }) : a.graph && (a.tracker = p.path(g).attr({\n          visibility: a.visible ? \"visible\" : \"hidden\",\n          zIndex: 2\n        }).addClass(f ? \"highcharts-tracker-area\" : \"highcharts-tracker-line\").add(a.group), l.styledMode || a.tracker.attr({\n          \"stroke-linejoin\": \"round\",\n          stroke: v,\n          fill: f ? v : \"none\",\n          \"stroke-width\": a.graph.strokeWidth() + (f ? 0 : 2 * r)\n        }), [a.tracker, a.markerGroup].forEach(function (a) {\n          a.addClass(\"highcharts-tracker\").on(\"mouseover\", b).on(\"mouseout\", function (a) {\n            m.onTrackerMouseOut(a);\n          });\n          e.cursor && !l.styledMode && a.css({\n            cursor: e.cursor\n          });\n          if (c) a.on(\"touchstart\", b);\n        }));\n        J(this, \"afterDrawTracker\");\n      }\n    };\n    h.column && (h.column.prototype.drawTracker = e.drawTrackerPoint);\n    h.pie && (h.pie.prototype.drawTracker = e.drawTrackerPoint);\n    h.scatter && (h.scatter.prototype.drawTracker = e.drawTrackerPoint);\n    C(g.prototype, {\n      setItemEvents: function (a, c, d) {\n        var e = this,\n            f = e.chart.renderer.boxWrapper,\n            g = a instanceof p,\n            h = \"highcharts-legend-\" + (g ? \"point\" : \"series\") + \"-active\",\n            k = e.chart.styledMode;\n        (d ? [c, a.legendSymbol] : [a.legendGroup]).forEach(function (d) {\n          if (d) d.on(\"mouseover\", function () {\n            a.visible && e.allItems.forEach(function (c) {\n              a !== c && c.setState(\"inactive\", !g);\n            });\n            a.setState(\"hover\");\n            a.visible && f.addClass(h);\n            k || c.css(e.options.itemHoverStyle);\n          }).on(\"mouseout\", function () {\n            e.chart.styledMode || c.css(M(a.visible ? e.itemStyle : e.itemHiddenStyle));\n            e.allItems.forEach(function (c) {\n              a !== c && c.setState(\"\", !g);\n            });\n            f.removeClass(h);\n            a.setState();\n          }).on(\"click\", function (c) {\n            var d = function () {\n              a.setVisible && a.setVisible();\n              e.allItems.forEach(function (b) {\n                a !== b && b.setState(a.visible ? \"inactive\" : \"\", !g);\n              });\n            };\n\n            f.removeClass(h);\n            c = {\n              browserEvent: c\n            };\n            a.firePointEvent ? a.firePointEvent(\"legendItemClick\", c, d) : J(a, \"legendItemClick\", c, d);\n          });\n        });\n      },\n      createCheckboxForItem: function (a) {\n        a.checkbox = L(\"input\", {\n          type: \"checkbox\",\n          className: \"highcharts-legend-checkbox\",\n          checked: a.selected,\n          defaultChecked: a.selected\n        }, this.options.itemCheckboxStyle, this.chart.container);\n        K(a.checkbox, \"click\", function (c) {\n          J(a.series || a, \"checkboxClick\", {\n            checked: c.target.checked,\n            item: a\n          }, function () {\n            a.select();\n          });\n        });\n      }\n    });\n    C(u.prototype, {\n      showResetZoom: function () {\n        function a() {\n          c.zoomOut();\n        }\n\n        var c = this,\n            d = H.lang,\n            e = c.options.chart.resetZoomButton,\n            f = e.theme,\n            g = f.states,\n            h = \"chart\" === e.relativeTo || \"spaceBox\" === e.relativeTo ? null : \"plotBox\";\n        J(this, \"beforeShowResetZoom\", null, function () {\n          c.resetZoomButton = c.renderer.button(d.resetZoom, null, null, a, f, g && g.hover).attr({\n            align: e.position.align,\n            title: d.resetZoomTitle\n          }).addClass(\"highcharts-reset-zoom\").add().align(e.position, !1, h);\n        });\n        J(this, \"afterShowResetZoom\");\n      },\n      zoomOut: function () {\n        J(this, \"selection\", {\n          resetSelection: !0\n        }, this.zoom);\n      },\n      zoom: function (a) {\n        var c = this,\n            e,\n            d = c.pointer,\n            f = !1,\n            g = c.inverted ? d.mouseDownX : d.mouseDownY;\n        !a || a.resetSelection ? (c.axes.forEach(function (a) {\n          e = a.zoom();\n        }), d.initiated = !1) : a.xAxis.concat(a.yAxis).forEach(function (a) {\n          var h = a.axis,\n              k = c.inverted ? h.left : h.top,\n              l = c.inverted ? k + h.width : k + h.height,\n              b = h.isXAxis,\n              m = !1;\n          if (!b && g >= k && g <= l || b || !A(g)) m = !0;\n          d[b ? \"zoomX\" : \"zoomY\"] && m && (e = h.zoom(a.min, a.max), h.displayBtn && (f = !0));\n        });\n        var h = c.resetZoomButton;\n        f && !h ? c.showResetZoom() : !f && D(h) && (c.resetZoomButton = h.destroy());\n        e && c.redraw(m(c.options.chart.animation, a && a.animation, 100 > c.pointCount));\n      },\n      pan: function (a, c) {\n        var e = this,\n            d = e.hoverPoints,\n            f = e.options.chart,\n            g;\n        c = \"object\" === typeof c ? c : {\n          enabled: c,\n          type: \"x\"\n        };\n        f && f.panning && (f.panning = c);\n        var h = c.type;\n        J(this, \"pan\", {\n          originalEvent: a\n        }, function () {\n          d && d.forEach(function (a) {\n            a.setState();\n          });\n          var c = [1];\n          \"xy\" === h ? c = [1, 0] : \"y\" === h && (c = [0]);\n          c.forEach(function (c) {\n            var d = e[c ? \"xAxis\" : \"yAxis\"][0],\n                f = d.options,\n                b = d.horiz,\n                h = a[b ? \"chartX\" : \"chartY\"];\n            b = b ? \"mouseDownX\" : \"mouseDownY\";\n            var k = e[b],\n                l = (d.pointRange || 0) / 2,\n                m = d.reversed && !e.inverted || !d.reversed && e.inverted ? -1 : 1,\n                p = d.getExtremes(),\n                t = d.toValue(k - h, !0) + l * m;\n            m = d.toValue(k + d.len - h, !0) - l * m;\n            var q = m < t;\n            k = q ? m : t;\n            t = q ? t : m;\n            m = Math.min(p.dataMin, l ? p.min : d.toValue(d.toPixels(p.min) - d.minPixelPadding));\n            l = Math.max(p.dataMax, l ? p.max : d.toValue(d.toPixels(p.max) + d.minPixelPadding));\n\n            if (!f.ordinal) {\n              c && (f = m - k, 0 < f && (t += f, k = m), f = t - l, 0 < f && (t = l, k -= f));\n              if (d.series.length && k !== p.min && t !== p.max && c || d.panningState && k >= d.panningState.startMin && t <= d.panningState.startMax) d.setExtremes(k, t, !1, !1, {\n                trigger: \"pan\"\n              }), g = !0;\n              e[b] = h;\n            }\n          });\n          g && e.redraw(!1);\n          E(e.container, {\n            cursor: \"move\"\n          });\n        });\n      }\n    });\n    C(p.prototype, {\n      select: function (a, c) {\n        var d = this,\n            e = d.series,\n            f = e.chart;\n        this.selectedStaging = a = m(a, !d.selected);\n        d.firePointEvent(a ? \"select\" : \"unselect\", {\n          accumulate: c\n        }, function () {\n          d.selected = d.options.selected = a;\n          e.options.data[e.data.indexOf(d)] = d.options;\n          d.setState(a && \"select\");\n          c || f.getSelectedPoints().forEach(function (a) {\n            var c = a.series;\n            a.selected && a !== d && (a.selected = a.options.selected = !1, c.options.data[c.data.indexOf(a)] = a.options, a.setState(f.hoverPoints && c.options.inactiveOtherPoints ? \"inactive\" : \"\"), a.firePointEvent(\"unselect\"));\n          });\n        });\n        delete this.selectedStaging;\n      },\n      onMouseOver: function (a) {\n        var c = this.series.chart,\n            d = c.pointer;\n        a = a ? d.normalize(a) : d.getChartCoordinatesFromPoint(this, c.inverted);\n        d.runPointActions(a, this);\n      },\n      onMouseOut: function () {\n        var a = this.series.chart;\n        this.firePointEvent(\"mouseOut\");\n        this.series.options.inactiveOtherPoints || (a.hoverPoints || []).forEach(function (a) {\n          a.setState();\n        });\n        a.hoverPoints = a.hoverPoint = null;\n      },\n      importEvents: function () {\n        if (!this.hasImportedEvents) {\n          var a = this,\n              c = M(a.series.options.point, a.options).events;\n          a.events = c;\n          v(c, function (c, d) {\n            r(c) && K(a, d, c);\n          });\n          this.hasImportedEvents = !0;\n        }\n      },\n      setState: function (a, c) {\n        var d = this.series,\n            e = this.state,\n            g = d.options.states[a || \"normal\"] || {},\n            h = f[d.type].marker && d.options.marker,\n            k = h && !1 === h.enabled,\n            l = h && h.states && h.states[a || \"normal\"] || {},\n            p = !1 === l.enabled,\n            r = d.stateMarkerGraphic,\n            n = this.marker || {},\n            b = d.chart,\n            u = d.halo,\n            v,\n            z = h && d.markerAttribs;\n        a = a || \"\";\n\n        if (!(a === this.state && !c || this.selected && \"select\" !== a || !1 === g.enabled || a && (p || k && !1 === l.enabled) || a && n.states && n.states[a] && !1 === n.states[a].enabled)) {\n          this.state = a;\n          z && (v = d.markerAttribs(this, a));\n\n          if (this.graphic) {\n            e && this.graphic.removeClass(\"highcharts-point-\" + e);\n            a && this.graphic.addClass(\"highcharts-point-\" + a);\n\n            if (!b.styledMode) {\n              var A = d.pointAttribs(this, a);\n              var D = m(b.options.chart.animation, g.animation);\n              d.options.inactiveOtherPoints && ((this.dataLabels || []).forEach(function (a) {\n                a && a.animate({\n                  opacity: A.opacity\n                }, D);\n              }), this.connector && this.connector.animate({\n                opacity: A.opacity\n              }, D));\n              this.graphic.animate(A, D);\n            }\n\n            v && this.graphic.animate(v, m(b.options.chart.animation, l.animation, h.animation));\n            r && r.hide();\n          } else {\n            if (a && l) {\n              e = n.symbol || d.symbol;\n              r && r.currentSymbol !== e && (r = r.destroy());\n              if (v) if (r) r[c ? \"animate\" : \"attr\"]({\n                x: v.x,\n                y: v.y\n              });else e && (d.stateMarkerGraphic = r = b.renderer.symbol(e, v.x, v.y, v.width, v.height).add(d.markerGroup), r.currentSymbol = e);\n              !b.styledMode && r && r.attr(d.pointAttribs(this, a));\n            }\n\n            r && (r[a && this.isInside ? \"show\" : \"hide\"](), r.element.point = this);\n          }\n\n          a = g.halo;\n          g = (r = this.graphic || r) && r.visibility || \"inherit\";\n          a && a.size && r && \"hidden\" !== g && !this.isCluster ? (u || (d.halo = u = b.renderer.path().add(r.parentGroup)), u.show()[c ? \"animate\" : \"attr\"]({\n            d: this.haloPath(a.size)\n          }), u.attr({\n            \"class\": \"highcharts-halo highcharts-color-\" + m(this.colorIndex, d.colorIndex) + (this.className ? \" \" + this.className : \"\"),\n            visibility: g,\n            zIndex: -1\n          }), u.point = this, b.styledMode || u.attr(C({\n            fill: this.color || d.color,\n            \"fill-opacity\": a.opacity\n          }, a.attributes))) : u && u.point && u.point.haloPath && u.animate({\n            d: u.point.haloPath(0)\n          }, null, u.hide);\n          J(this, \"afterSetState\");\n        }\n      },\n      haloPath: function (a) {\n        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);\n      }\n    });\n    C(l.prototype, {\n      onMouseOver: function () {\n        var a = this.chart,\n            c = a.hoverSeries;\n        if (c && c !== this) c.onMouseOut();\n        this.options.events.mouseOver && J(this, \"mouseOver\");\n        this.setState(\"hover\");\n        a.hoverSeries = this;\n      },\n      onMouseOut: function () {\n        var a = this.options,\n            c = this.chart,\n            d = c.tooltip,\n            e = c.hoverPoint;\n        c.hoverSeries = null;\n        if (e) e.onMouseOut();\n        this && a.events.mouseOut && J(this, \"mouseOut\");\n        !d || this.stickyTracking || d.shared && !this.noSharedTooltip || d.hide();\n        c.series.forEach(function (a) {\n          a.setState(\"\", !0);\n        });\n      },\n      setState: function (a, c) {\n        var d = this,\n            e = d.options,\n            f = d.graph,\n            g = e.inactiveOtherPoints,\n            h = e.states,\n            k = e.lineWidth,\n            l = e.opacity,\n            p = m(h[a || \"normal\"] && h[a || \"normal\"].animation, d.chart.options.chart.animation);\n        e = 0;\n        a = a || \"\";\n\n        if (d.state !== a && ([d.group, d.markerGroup, d.dataLabelsGroup].forEach(function (c) {\n          c && (d.state && c.removeClass(\"highcharts-series-\" + d.state), a && c.addClass(\"highcharts-series-\" + a));\n        }), d.state = a, !d.chart.styledMode)) {\n          if (h[a] && !1 === h[a].enabled) return;\n          a && (k = h[a].lineWidth || k + (h[a].lineWidthPlus || 0), l = m(h[a].opacity, l));\n          if (f && !f.dashstyle) for (h = {\n            \"stroke-width\": k\n          }, f.animate(h, p); d[\"zone-graph-\" + e];) d[\"zone-graph-\" + e].attr(h), e += 1;\n          g || [d.group, d.markerGroup, d.dataLabelsGroup, d.labelBySeries].forEach(function (a) {\n            a && a.animate({\n              opacity: l\n            }, p);\n          });\n        }\n\n        c && g && d.points && d.setAllPointsToState(a);\n      },\n      setAllPointsToState: function (a) {\n        this.points.forEach(function (c) {\n          c.setState && c.setState(a);\n        });\n      },\n      setVisible: function (a, c) {\n        var d = this,\n            e = d.chart,\n            f = d.legendItem,\n            g = e.options.chart.ignoreHiddenSeries,\n            h = d.visible;\n        var k = (d.visible = a = d.options.visible = d.userOptions.visible = \"undefined\" === typeof a ? !h : a) ? \"show\" : \"hide\";\n        [\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"].forEach(function (a) {\n          if (d[a]) d[a][k]();\n        });\n        if (e.hoverSeries === d || (e.hoverPoint && e.hoverPoint.series) === d) d.onMouseOut();\n        f && e.legend.colorizeItem(d, a);\n        d.isDirty = !0;\n        d.options.stacking && e.series.forEach(function (a) {\n          a.options.stacking && a.visible && (a.isDirty = !0);\n        });\n        d.linkedSeries.forEach(function (c) {\n          c.setVisible(a, !1);\n        });\n        g && (e.isDirtyBox = !0);\n        J(d, k);\n        !1 !== c && e.redraw();\n      },\n      show: function () {\n        this.setVisible(!0);\n      },\n      hide: function () {\n        this.setVisible(!1);\n      },\n      select: function (a) {\n        this.selected = a = this.options.selected = \"undefined\" === typeof a ? !this.selected : a;\n        this.checkbox && (this.checkbox.checked = a);\n        J(this, a ? \"select\" : \"unselect\");\n      },\n      drawTracker: e.drawTrackerGraph\n    });\n  });\n  R(p, \"parts/Responsive.js\", [p[\"parts/Globals.js\"], p[\"parts/Utilities.js\"]], function (e, g) {\n    var p = g.find,\n        u = g.isArray,\n        K = g.isObject,\n        L = g.merge,\n        E = g.objectEach,\n        A = g.pick,\n        C = g.splat,\n        J = g.uniqueKey;\n    e = e.Chart;\n\n    e.prototype.setResponsive = function (e, g) {\n      var r = this.options.responsive,\n          u = [],\n          v = this.currentResponsive;\n      !g && r && r.rules && r.rules.forEach(function (e) {\n        \"undefined\" === typeof e._id && (e._id = J());\n        this.matchResponsiveRule(e, u);\n      }, this);\n      g = L.apply(0, u.map(function (e) {\n        return p(r.rules, function (g) {\n          return g._id === e;\n        }).chartOptions;\n      }));\n      g.isResponsiveOptions = !0;\n      u = u.toString() || void 0;\n      u !== (v && v.ruleIds) && (v && this.update(v.undoOptions, e, !0), u ? (v = this.currentOptions(g), v.isResponsiveOptions = !0, this.currentResponsive = {\n        ruleIds: u,\n        mergedOptions: g,\n        undoOptions: v\n      }, this.update(g, e, !0)) : this.currentResponsive = void 0);\n    };\n\n    e.prototype.matchResponsiveRule = function (e, g) {\n      var p = e.condition;\n      (p.callback || function () {\n        return this.chartWidth <= A(p.maxWidth, Number.MAX_VALUE) && this.chartHeight <= A(p.maxHeight, Number.MAX_VALUE) && this.chartWidth >= A(p.minWidth, 0) && this.chartHeight >= A(p.minHeight, 0);\n      }).call(this) && g.push(e._id);\n    };\n\n    e.prototype.currentOptions = function (e) {\n      function g(e, m, r, f) {\n        var c;\n        E(e, function (e, h) {\n          if (!f && -1 < p.collectionsWithUpdate.indexOf(h)) for (e = C(e), r[h] = [], c = 0; c < e.length; c++) m[h][c] && (r[h][c] = {}, g(e[c], m[h][c], r[h][c], f + 1));else K(e) ? (r[h] = u(e) ? [] : {}, g(e, m[h] || {}, r[h], f + 1)) : r[h] = \"undefined\" === typeof m[h] ? null : m[h];\n        });\n      }\n\n      var p = this,\n          z = {};\n      g(e, this.options, z, 0);\n      return z;\n    };\n  });\n  R(p, \"masters/highcharts.src.js\", [p[\"parts/Globals.js\"]], function (e) {\n    return e;\n  });\n  p[\"masters/highcharts.src.js\"]._modules = p;\n  return p[\"masters/highcharts.src.js\"];\n});","map":null,"metadata":{},"sourceType":"script"}