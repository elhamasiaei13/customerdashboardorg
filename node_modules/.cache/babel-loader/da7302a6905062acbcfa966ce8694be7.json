{"ast":null,"code":"/*\n Highmaps JS v8.0.2 (2020-03-03)\n\n Highmaps as a plugin for Highcharts or Highstock.\n\n (c) 2011-2019 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function (d) {\n  \"object\" === typeof module && module.exports ? (d[\"default\"] = d, module.exports = d) : \"function\" === typeof define && define.amd ? define(\"highcharts/modules/map\", [\"highcharts\"], function (x) {\n    d(x);\n    d.Highcharts = x;\n    return d;\n  }) : d(\"undefined\" !== typeof Highcharts ? Highcharts : void 0);\n})(function (d) {\n  function x(b, n, d, e) {\n    b.hasOwnProperty(n) || (b[n] = e.apply(null, d));\n  }\n\n  d = d ? d._modules : {};\n  x(d, \"parts-map/MapAxis.js\", [d[\"parts/Globals.js\"], d[\"parts/Utilities.js\"]], function (b, n) {\n    var d = n.addEvent,\n        e = n.pick;\n    b = b.Axis;\n    d(b, \"getSeriesExtremes\", function () {\n      var m = [];\n      this.isXAxis && (this.series.forEach(function (h, b) {\n        h.useMapGeometry && (m[b] = h.xData, h.xData = []);\n      }), this.seriesXData = m);\n    });\n    d(b, \"afterGetSeriesExtremes\", function () {\n      var m = this.seriesXData,\n          h;\n\n      if (this.isXAxis) {\n        var b = e(this.dataMin, Number.MAX_VALUE);\n        var d = e(this.dataMax, -Number.MAX_VALUE);\n        this.series.forEach(function (n, q) {\n          n.useMapGeometry && (b = Math.min(b, e(n.minX, b)), d = Math.max(d, e(n.maxX, d)), n.xData = m[q], h = !0);\n        });\n        h && (this.dataMin = b, this.dataMax = d);\n        delete this.seriesXData;\n      }\n    });\n    d(b, \"afterSetAxisTranslation\", function () {\n      var m = this.chart;\n      var h = m.plotWidth / m.plotHeight;\n      m = m.xAxis[0];\n      var b;\n      \"yAxis\" === this.coll && \"undefined\" !== typeof m.transA && this.series.forEach(function (h) {\n        h.preserveAspectRatio && (b = !0);\n      });\n\n      if (b && (this.transA = m.transA = Math.min(this.transA, m.transA), h /= (m.max - m.min) / (this.max - this.min), h = 1 > h ? this : m, m = (h.max - h.min) * h.transA, h.pixelPadding = h.len - m, h.minPixelPadding = h.pixelPadding / 2, m = h.fixTo)) {\n        m = m[1] - h.toValue(m[0], !0);\n        m *= h.transA;\n        if (Math.abs(m) > h.minPixelPadding || h.min === h.dataMin && h.max === h.dataMax) m = 0;\n        h.minPixelPadding -= m;\n      }\n    });\n    d(b, \"render\", function () {\n      this.fixTo = null;\n    });\n  });\n  x(d, \"parts-map/ColorSeriesMixin.js\", [d[\"parts/Globals.js\"]], function (b) {\n    b.colorPointMixin = {\n      setVisible: function (b) {\n        var d = this,\n            e = b ? \"show\" : \"hide\";\n        d.visible = d.options.visible = !!b;\n        [\"graphic\", \"dataLabel\"].forEach(function (b) {\n          if (d[b]) d[b][e]();\n        });\n      }\n    };\n    b.colorSeriesMixin = {\n      optionalAxis: \"colorAxis\",\n      colorAxis: 0,\n      translateColors: function () {\n        var b = this,\n            d = this.options.nullColor,\n            e = this.colorAxis,\n            m = this.colorKey;\n        (this.data.length ? this.data : this.points).forEach(function (h) {\n          var n = h.getNestedProperty(m);\n          if (n = h.options.color || (h.isNull ? d : e && \"undefined\" !== typeof n ? e.toColor(n, h) : h.color || b.color)) h.color = n;\n        });\n      }\n    };\n  });\n  x(d, \"parts-map/ColorAxis.js\", [d[\"parts/Globals.js\"], d[\"parts/Color.js\"], d[\"parts/Point.js\"], d[\"parts/Legend.js\"], d[\"mixins/legend-symbol.js\"], d[\"parts/Utilities.js\"]], function (b, d, u, e, m, h) {\n    \"\";\n\n    var n = d.parse;\n    d = h.addEvent;\n    var A = h.erase,\n        t = h.extend,\n        q = h.isNumber,\n        a = h.merge,\n        k = h.pick,\n        l = h.splat,\n        p = b.Axis;\n    h = b.Chart;\n    var y = b.Series,\n        w = b.colorPointMixin,\n        B = b.noop;\n    t(y.prototype, b.colorSeriesMixin);\n    t(u.prototype, w);\n    h.prototype.collectionsWithUpdate.push(\"colorAxis\");\n    h.prototype.collectionsWithInit.colorAxis = [h.prototype.addColorAxis];\n\n    var f = b.ColorAxis = function () {\n      this.init.apply(this, arguments);\n    };\n\n    t(f.prototype, p.prototype);\n    t(f.prototype, {\n      defaultColorAxisOptions: {\n        lineWidth: 0,\n        minPadding: 0,\n        maxPadding: 0,\n        gridLineWidth: 1,\n        tickPixelInterval: 72,\n        startOnTick: !0,\n        endOnTick: !0,\n        offset: 0,\n        marker: {\n          animation: {\n            duration: 50\n          },\n          width: .01,\n          color: \"#999999\"\n        },\n        labels: {\n          overflow: \"justify\",\n          rotation: 0\n        },\n        minColor: \"#e6ebf5\",\n        maxColor: \"#003399\",\n        tickLength: 5,\n        showInLegend: !0\n      },\n      keepProps: [\"legendGroup\", \"legendItemHeight\", \"legendItemWidth\", \"legendItem\", \"legendSymbol\"].concat(p.prototype.keepProps),\n      init: function (c, g) {\n        this.coll = \"colorAxis\";\n        var v = this.buildOptions.call(c, this.defaultColorAxisOptions, g);\n        p.prototype.init.call(this, c, v);\n        g.dataClasses && this.initDataClasses(g);\n        this.initStops();\n        this.horiz = !v.opposite;\n        this.zoomEnabled = !1;\n        this.defaultLegendLength = 200;\n      },\n      initDataClasses: function (c) {\n        var g = this.chart,\n            v,\n            f = 0,\n            r = g.options.chart.colorCount,\n            k = this.options,\n            b = c.dataClasses.length;\n        this.dataClasses = v = [];\n        this.legendItems = [];\n        c.dataClasses.forEach(function (c, z) {\n          c = a(c);\n          v.push(c);\n          if (g.styledMode || !c.color) \"category\" === k.dataClassColor ? (g.styledMode || (z = g.options.colors, r = z.length, c.color = z[f]), c.colorIndex = f, f++, f === r && (f = 0)) : c.color = n(k.minColor).tweenTo(n(k.maxColor), 2 > b ? .5 : z / (b - 1));\n        });\n      },\n      hasData: function () {\n        return !(!this.tickPositions || !this.tickPositions.length);\n      },\n      setTickPositions: function () {\n        if (!this.dataClasses) return p.prototype.setTickPositions.call(this);\n      },\n      initStops: function () {\n        this.stops = this.options.stops || [[0, this.options.minColor], [1, this.options.maxColor]];\n        this.stops.forEach(function (c) {\n          c.color = n(c[1]);\n        });\n      },\n      buildOptions: function (c, g) {\n        var v = this.options.legend,\n            f = g.layout ? \"vertical\" !== g.layout : \"vertical\" !== v.layout;\n        return a(c, {\n          side: f ? 2 : 1,\n          reversed: !f\n        }, g, {\n          opposite: !f,\n          showEmpty: !1,\n          title: null,\n          visible: v.enabled && (g ? !1 !== g.visible : !0)\n        });\n      },\n      setOptions: function (c) {\n        p.prototype.setOptions.call(this, c);\n        this.options.crosshair = this.options.marker;\n      },\n      setAxisSize: function () {\n        var c = this.legendSymbol,\n            g = this.chart,\n            v = g.options.legend || {},\n            f,\n            a;\n        c ? (this.left = v = c.attr(\"x\"), this.top = f = c.attr(\"y\"), this.width = a = c.attr(\"width\"), this.height = c = c.attr(\"height\"), this.right = g.chartWidth - v - a, this.bottom = g.chartHeight - f - c, this.len = this.horiz ? a : c, this.pos = this.horiz ? v : f) : this.len = (this.horiz ? v.symbolWidth : v.symbolHeight) || this.defaultLegendLength;\n      },\n      normalizedValue: function (c) {\n        this.isLog && (c = this.val2lin(c));\n        return 1 - (this.max - c) / (this.max - this.min || 1);\n      },\n      toColor: function (c, g) {\n        var f = this.stops,\n            a = this.dataClasses,\n            r;\n        if (a) for (r = a.length; r--;) {\n          var k = a[r];\n          var b = k.from;\n          f = k.to;\n\n          if ((\"undefined\" === typeof b || c >= b) && (\"undefined\" === typeof f || c <= f)) {\n            var h = k.color;\n            g && (g.dataClass = r, g.colorIndex = k.colorIndex);\n            break;\n          }\n        } else {\n          c = this.normalizedValue(c);\n\n          for (r = f.length; r-- && !(c > f[r][0]););\n\n          b = f[r] || f[r + 1];\n          f = f[r + 1] || b;\n          c = 1 - (f[0] - c) / (f[0] - b[0] || 1);\n          h = b.color.tweenTo(f.color, c);\n        }\n        return h;\n      },\n      getOffset: function () {\n        var c = this.legendGroup,\n            g = this.chart.axisOffset[this.side];\n        c && (this.axisParent = c, p.prototype.getOffset.call(this), this.added || (this.added = !0, this.labelLeft = 0, this.labelRight = this.width), this.chart.axisOffset[this.side] = g);\n      },\n      setLegendColor: function () {\n        var c = this.reversed;\n        var g = c ? 1 : 0;\n        c = c ? 0 : 1;\n        g = this.horiz ? [g, 0, c, 0] : [0, c, 0, g];\n        this.legendColor = {\n          linearGradient: {\n            x1: g[0],\n            y1: g[1],\n            x2: g[2],\n            y2: g[3]\n          },\n          stops: this.stops\n        };\n      },\n      drawLegendSymbol: function (c, g) {\n        var f = c.padding,\n            a = c.options,\n            r = this.horiz,\n            b = k(a.symbolWidth, r ? this.defaultLegendLength : 12),\n            h = k(a.symbolHeight, r ? 12 : this.defaultLegendLength),\n            l = k(a.labelPadding, r ? 16 : 30);\n        a = k(a.itemDistance, 10);\n        this.setLegendColor();\n        g.legendSymbol = this.chart.renderer.rect(0, c.baseline - 11, b, h).attr({\n          zIndex: 1\n        }).add(g.legendGroup);\n        this.legendItemWidth = b + f + (r ? a : l);\n        this.legendItemHeight = h + f + (r ? l : 0);\n      },\n      setState: function (c) {\n        this.series.forEach(function (g) {\n          g.setState(c);\n        });\n      },\n      visible: !0,\n      setVisible: B,\n      getSeriesExtremes: function () {\n        var c = this.series,\n            g = c.length,\n            f;\n        this.dataMin = Infinity;\n\n        for (this.dataMax = -Infinity; g--;) {\n          var a = c[g];\n          var r = a.colorKey = k(a.options.colorKey, a.colorKey, a.pointValKey, a.zoneAxis, \"y\");\n          var b = a.pointArrayMap;\n          var h = a[r + \"Min\"] && a[r + \"Max\"];\n          if (a[r + \"Data\"]) var l = a[r + \"Data\"];else if (b) {\n            l = [];\n            b = b.indexOf(r);\n            var d = a.yData;\n            if (0 <= b && d) for (f = 0; f < d.length; f++) l.push(k(d[f][b], d[f]));\n          } else l = a.yData;\n          h ? (a.minColorValue = a[r + \"Min\"], a.maxColorValue = a[r + \"Max\"]) : (y.prototype.getExtremes.call(a, l), a.minColorValue = a.dataMin, a.maxColorValue = a.dataMax);\n          \"undefined\" !== typeof a.minColorValue && (this.dataMin = Math.min(this.dataMin, a.minColorValue), this.dataMax = Math.max(this.dataMax, a.maxColorValue));\n          h || y.prototype.getExtremes.call(a);\n        }\n      },\n      drawCrosshair: function (c, g) {\n        var a = g && g.plotX,\n            f = g && g.plotY,\n            r = this.pos,\n            k = this.len;\n\n        if (g) {\n          var b = this.toPixels(g.getNestedProperty(g.series.colorKey));\n          b < r ? b = r - 2 : b > r + k && (b = r + k + 2);\n          g.plotX = b;\n          g.plotY = this.len - b;\n          p.prototype.drawCrosshair.call(this, c, g);\n          g.plotX = a;\n          g.plotY = f;\n          this.cross && !this.cross.addedToColorAxis && this.legendGroup && (this.cross.addClass(\"highcharts-coloraxis-marker\").add(this.legendGroup), this.cross.addedToColorAxis = !0, this.chart.styledMode || this.cross.attr({\n            fill: this.crosshair.color\n          }));\n        }\n      },\n      getPlotLinePath: function (c) {\n        var g = c.translatedValue;\n        return q(g) ? this.horiz ? [\"M\", g - 4, this.top - 6, \"L\", g + 4, this.top - 6, g, this.top, \"Z\"] : [\"M\", this.left, g, \"L\", this.left - 6, g + 6, this.left - 6, g - 6, \"Z\"] : p.prototype.getPlotLinePath.apply(this, arguments);\n      },\n      update: function (c, g) {\n        var f = this.chart,\n            b = f.legend,\n            r = this.buildOptions.call(f, {}, c);\n        this.series.forEach(function (c) {\n          c.isDirtyData = !0;\n        });\n        (c.dataClasses && b.allItems || this.dataClasses) && this.destroyItems();\n        f.options[this.coll] = a(this.userOptions, r);\n        p.prototype.update.call(this, r, g);\n        this.legendItem && (this.setLegendColor(), b.colorizeItem(this, !0));\n      },\n      destroyItems: function () {\n        var c = this.chart;\n        this.legendItem ? c.legend.destroyItem(this) : this.legendItems && this.legendItems.forEach(function (g) {\n          c.legend.destroyItem(g);\n        });\n        c.isDirtyLegend = !0;\n      },\n      remove: function (c) {\n        this.destroyItems();\n        p.prototype.remove.call(this, c);\n      },\n      getDataClassLegendSymbols: function () {\n        var c = this,\n            g = this.chart,\n            a = this.legendItems,\n            f = g.options.legend,\n            r = f.valueDecimals,\n            b = f.valueSuffix || \"\",\n            k;\n        a.length || this.dataClasses.forEach(function (f, v) {\n          var h = !0,\n              l = f.from,\n              d = f.to,\n              z = g.numberFormatter;\n          k = \"\";\n          \"undefined\" === typeof l ? k = \"< \" : \"undefined\" === typeof d && (k = \"> \");\n          \"undefined\" !== typeof l && (k += z(l, r) + b);\n          \"undefined\" !== typeof l && \"undefined\" !== typeof d && (k += \" - \");\n          \"undefined\" !== typeof d && (k += z(d, r) + b);\n          a.push(t({\n            chart: g,\n            name: k,\n            options: {},\n            drawLegendSymbol: m.drawRectangle,\n            visible: !0,\n            setState: B,\n            isDataClass: !0,\n            setVisible: function () {\n              h = this.visible = !h;\n              c.series.forEach(function (c) {\n                c.points.forEach(function (c) {\n                  c.dataClass === v && c.setVisible(h);\n                });\n              });\n              g.legend.colorizeItem(this, h);\n            }\n          }, f));\n        });\n        return a;\n      },\n      beforePadding: !1,\n      name: \"\"\n    });\n    [\"fill\", \"stroke\"].forEach(function (c) {\n      b.Fx.prototype[c + \"Setter\"] = function () {\n        this.elem.attr(c, n(this.start).tweenTo(n(this.end), this.pos), null, !0);\n      };\n    });\n    d(h, \"afterGetAxes\", function () {\n      var c = this,\n          g = c.options;\n      this.colorAxis = [];\n      g.colorAxis && (g.colorAxis = l(g.colorAxis), g.colorAxis.forEach(function (g, a) {\n        g.index = a;\n        new f(c, g);\n      }));\n    });\n    d(y, \"bindAxes\", function () {\n      var c = this.axisTypes;\n      c ? -1 === c.indexOf(\"colorAxis\") && c.push(\"colorAxis\") : this.axisTypes = [\"colorAxis\"];\n    });\n    d(e, \"afterGetAllItems\", function (c) {\n      var g = [],\n          a,\n          f;\n      (this.chart.colorAxis || []).forEach(function (f) {\n        (a = f.options) && a.showInLegend && (a.dataClasses && a.visible ? g = g.concat(f.getDataClassLegendSymbols()) : a.visible && g.push(f), f.series.forEach(function (g) {\n          if (!g.options.showInLegend || a.dataClasses) \"point\" === g.options.legendType ? g.points.forEach(function (g) {\n            A(c.allItems, g);\n          }) : A(c.allItems, g);\n        }));\n      });\n\n      for (f = g.length; f--;) c.allItems.unshift(g[f]);\n    });\n    d(e, \"afterColorizeItem\", function (c) {\n      c.visible && c.item.legendColor && c.item.legendSymbol.attr({\n        fill: c.item.legendColor\n      });\n    });\n    d(e, \"afterUpdate\", function () {\n      var c = this.chart.colorAxis;\n      c && c.forEach(function (c, a, f) {\n        c.update({}, f);\n      });\n    });\n    d(y, \"afterTranslate\", function () {\n      (this.chart.colorAxis && this.chart.colorAxis.length || this.colorAttribs) && this.translateColors();\n    });\n  });\n  x(d, \"parts-map/ColorMapSeriesMixin.js\", [d[\"parts/Globals.js\"], d[\"parts/Point.js\"], d[\"parts/Utilities.js\"]], function (b, d, u) {\n    var e = u.defined;\n    u = b.noop;\n    var m = b.seriesTypes;\n    b.colorMapPointMixin = {\n      dataLabelOnNull: !0,\n      isValid: function () {\n        return null !== this.value && Infinity !== this.value && -Infinity !== this.value;\n      },\n      setState: function (b) {\n        d.prototype.setState.call(this, b);\n        this.graphic && this.graphic.attr({\n          zIndex: \"hover\" === b ? 1 : 0\n        });\n      }\n    };\n    b.colorMapSeriesMixin = {\n      pointArrayMap: [\"value\"],\n      axisTypes: [\"xAxis\", \"yAxis\", \"colorAxis\"],\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      getSymbol: u,\n      parallelArrays: [\"x\", \"y\", \"value\"],\n      colorKey: \"value\",\n      pointAttribs: m.column.prototype.pointAttribs,\n      colorAttribs: function (b) {\n        var h = {};\n        e(b.color) && (h[this.colorProp || \"fill\"] = b.color);\n        return h;\n      }\n    };\n  });\n  x(d, \"parts-map/MapNavigation.js\", [d[\"parts/Globals.js\"], d[\"parts/Utilities.js\"]], function (b, d) {\n    function n(a) {\n      a && (a.preventDefault && a.preventDefault(), a.stopPropagation && a.stopPropagation(), a.cancelBubble = !0);\n    }\n\n    function e(a) {\n      this.init(a);\n    }\n\n    var m = d.addEvent,\n        h = d.extend,\n        C = d.merge,\n        A = d.objectEach,\n        t = d.pick;\n    d = b.Chart;\n    var q = b.doc;\n\n    e.prototype.init = function (a) {\n      this.chart = a;\n      a.mapNavButtons = [];\n    };\n\n    e.prototype.update = function (a) {\n      var b = this.chart,\n          d = b.options.mapNavigation,\n          p,\n          e,\n          w,\n          B,\n          f,\n          c = function (c) {\n        this.handler.call(b, c);\n        n(c);\n      },\n          g = b.mapNavButtons;\n\n      a && (d = b.options.mapNavigation = C(b.options.mapNavigation, a));\n\n      for (; g.length;) g.pop().destroy();\n\n      t(d.enableButtons, d.enabled) && !b.renderer.forExport && A(d.buttons, function (a, k) {\n        p = C(d.buttonOptions, a);\n        b.styledMode || (e = p.theme, e.style = C(p.theme.style, p.style), B = (w = e.states) && w.hover, f = w && w.select);\n        a = b.renderer.button(p.text, 0, 0, c, e, B, f, 0, \"zoomIn\" === k ? \"topbutton\" : \"bottombutton\").addClass(\"highcharts-map-navigation highcharts-\" + {\n          zoomIn: \"zoom-in\",\n          zoomOut: \"zoom-out\"\n        }[k]).attr({\n          width: p.width,\n          height: p.height,\n          title: b.options.lang[k],\n          padding: p.padding,\n          zIndex: 5\n        }).add();\n        a.handler = p.onclick;\n        m(a.element, \"dblclick\", n);\n        g.push(a);\n        var v = p,\n            l = m(b, \"load\", function () {\n          a.align(h(v, {\n            width: a.width,\n            height: 2 * a.height\n          }), null, v.alignTo);\n          l();\n        });\n      });\n      this.updateEvents(d);\n    };\n\n    e.prototype.updateEvents = function (a) {\n      var b = this.chart;\n      t(a.enableDoubleClickZoom, a.enabled) || a.enableDoubleClickZoomTo ? this.unbindDblClick = this.unbindDblClick || m(b.container, \"dblclick\", function (a) {\n        b.pointer.onContainerDblClick(a);\n      }) : this.unbindDblClick && (this.unbindDblClick = this.unbindDblClick());\n      t(a.enableMouseWheelZoom, a.enabled) ? this.unbindMouseWheel = this.unbindMouseWheel || m(b.container, \"undefined\" === typeof q.onmousewheel ? \"DOMMouseScroll\" : \"mousewheel\", function (a) {\n        b.pointer.onContainerMouseWheel(a);\n        n(a);\n        return !1;\n      }) : this.unbindMouseWheel && (this.unbindMouseWheel = this.unbindMouseWheel());\n    };\n\n    h(d.prototype, {\n      fitToBox: function (a, b) {\n        [[\"x\", \"width\"], [\"y\", \"height\"]].forEach(function (d) {\n          var h = d[0];\n          d = d[1];\n          a[h] + a[d] > b[h] + b[d] && (a[d] > b[d] ? (a[d] = b[d], a[h] = b[h]) : a[h] = b[h] + b[d] - a[d]);\n          a[d] > b[d] && (a[d] = b[d]);\n          a[h] < b[h] && (a[h] = b[h]);\n        });\n        return a;\n      },\n      mapZoom: function (a, b, d, h, m) {\n        var k = this.xAxis[0],\n            e = k.max - k.min,\n            f = t(b, k.min + e / 2),\n            c = e * a;\n        e = this.yAxis[0];\n        var g = e.max - e.min,\n            v = t(d, e.min + g / 2);\n        g *= a;\n        f = this.fitToBox({\n          x: f - c * (h ? (h - k.pos) / k.len : .5),\n          y: v - g * (m ? (m - e.pos) / e.len : .5),\n          width: c,\n          height: g\n        }, {\n          x: k.dataMin,\n          y: e.dataMin,\n          width: k.dataMax - k.dataMin,\n          height: e.dataMax - e.dataMin\n        });\n        c = f.x <= k.dataMin && f.width >= k.dataMax - k.dataMin && f.y <= e.dataMin && f.height >= e.dataMax - e.dataMin;\n        h && (k.fixTo = [h - k.pos, b]);\n        m && (e.fixTo = [m - e.pos, d]);\n        \"undefined\" === typeof a || c ? (k.setExtremes(void 0, void 0, !1), e.setExtremes(void 0, void 0, !1)) : (k.setExtremes(f.x, f.x + f.width, !1), e.setExtremes(f.y, f.y + f.height, !1));\n        this.redraw();\n      }\n    });\n    m(d, \"beforeRender\", function () {\n      this.mapNavigation = new e(this);\n      this.mapNavigation.update();\n    });\n    b.MapNavigation = e;\n  });\n  x(d, \"parts-map/MapPointer.js\", [d[\"parts/Globals.js\"], d[\"parts/Utilities.js\"]], function (b, d) {\n    var n = d.extend,\n        e = d.pick;\n    d = d.wrap;\n    b = b.Pointer;\n    n(b.prototype, {\n      onContainerDblClick: function (b) {\n        var d = this.chart;\n        b = this.normalize(b);\n        d.options.mapNavigation.enableDoubleClickZoomTo ? d.pointer.inClass(b.target, \"highcharts-tracker\") && d.hoverPoint && d.hoverPoint.zoomTo() : d.isInsidePlot(b.chartX - d.plotLeft, b.chartY - d.plotTop) && d.mapZoom(.5, d.xAxis[0].toValue(b.chartX), d.yAxis[0].toValue(b.chartY), b.chartX, b.chartY);\n      },\n      onContainerMouseWheel: function (b) {\n        var d = this.chart;\n        b = this.normalize(b);\n        var e = b.detail || -(b.wheelDelta / 120);\n        d.isInsidePlot(b.chartX - d.plotLeft, b.chartY - d.plotTop) && d.mapZoom(Math.pow(d.options.mapNavigation.mouseWheelSensitivity, e), d.xAxis[0].toValue(b.chartX), d.yAxis[0].toValue(b.chartY), b.chartX, b.chartY);\n      }\n    });\n    d(b.prototype, \"zoomOption\", function (b) {\n      var d = this.chart.options.mapNavigation;\n      e(d.enableTouchZoom, d.enabled) && (this.chart.options.chart.pinchType = \"xy\");\n      b.apply(this, [].slice.call(arguments, 1));\n    });\n    d(b.prototype, \"pinchTranslate\", function (b, d, e, n, u, q, a) {\n      b.call(this, d, e, n, u, q, a);\n      \"map\" === this.chart.options.chart.type && this.hasZoom && (b = n.scaleX > n.scaleY, this.pinchTranslateDirection(!b, d, e, n, u, q, a, b ? n.scaleX : n.scaleY));\n    });\n  });\n  x(d, \"parts-map/MapSeries.js\", [d[\"parts/Globals.js\"], d[\"mixins/legend-symbol.js\"], d[\"parts/Point.js\"], d[\"parts/Utilities.js\"]], function (b, d, u, e) {\n    var m = e.extend,\n        h = e.fireEvent,\n        n = e.getNestedProperty,\n        A = e.isArray,\n        t = e.isNumber,\n        q = e.merge,\n        a = e.objectEach,\n        k = e.pick,\n        l = e.seriesType,\n        p = e.splat,\n        y = b.colorMapPointMixin,\n        w = b.noop,\n        B = b.Series,\n        f = b.seriesTypes;\n    l(\"map\", \"scatter\", {\n      animation: !1,\n      dataLabels: {\n        crop: !1,\n        formatter: function () {\n          return this.point.value;\n        },\n        inside: !0,\n        overflow: !1,\n        padding: 0,\n        verticalAlign: \"middle\"\n      },\n      marker: null,\n      nullColor: \"#f7f7f7\",\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0,\n        pointFormat: \"{point.name}: {point.value}<br/>\"\n      },\n      turboThreshold: 0,\n      allAreas: !0,\n      borderColor: \"#cccccc\",\n      borderWidth: 1,\n      joinBy: \"hc-key\",\n      states: {\n        hover: {\n          halo: null,\n          brightness: .2\n        },\n        normal: {\n          animation: !0\n        },\n        select: {\n          color: \"#cccccc\"\n        },\n        inactive: {\n          opacity: 1\n        }\n      }\n    }, q(b.colorMapSeriesMixin, {\n      type: \"map\",\n      getExtremesFromAll: !0,\n      useMapGeometry: !0,\n      forceDL: !0,\n      searchPoint: w,\n      directTouch: !0,\n      preserveAspectRatio: !0,\n      pointArrayMap: [\"value\"],\n      setOptions: function (c) {\n        c = B.prototype.setOptions.call(this, c);\n        var g = c.joinBy;\n        null === g && (g = \"_i\");\n        g = this.joinBy = p(g);\n        g[1] || (g[1] = g[0]);\n        return c;\n      },\n      getBox: function (c) {\n        var g = Number.MAX_VALUE,\n            a = -g,\n            f = g,\n            d = -g,\n            e = g,\n            h = g,\n            l = this.xAxis,\n            p = this.yAxis,\n            m;\n        (c || []).forEach(function (c) {\n          if (c.path) {\n            \"string\" === typeof c.path && (c.path = b.splitPath(c.path));\n            var v = c.path || [],\n                r = v.length,\n                l = !1,\n                z = -g,\n                p = g,\n                D = -g,\n                q = g,\n                n = c.properties;\n\n            if (!c._foundBox) {\n              for (; r--;) t(v[r]) && (l ? (z = Math.max(z, v[r]), p = Math.min(p, v[r])) : (D = Math.max(D, v[r]), q = Math.min(q, v[r])), l = !l);\n\n              c._midX = p + (z - p) * k(c.middleX, n && n[\"hc-middle-x\"], .5);\n              c._midY = q + (D - q) * k(c.middleY, n && n[\"hc-middle-y\"], .5);\n              c._maxX = z;\n              c._minX = p;\n              c._maxY = D;\n              c._minY = q;\n              c.labelrank = k(c.labelrank, (z - p) * (D - q));\n              c._foundBox = !0;\n            }\n\n            a = Math.max(a, c._maxX);\n            f = Math.min(f, c._minX);\n            d = Math.max(d, c._maxY);\n            e = Math.min(e, c._minY);\n            h = Math.min(c._maxX - c._minX, c._maxY - c._minY, h);\n            m = !0;\n          }\n        });\n        m && (this.minY = Math.min(e, k(this.minY, g)), this.maxY = Math.max(d, k(this.maxY, -g)), this.minX = Math.min(f, k(this.minX, g)), this.maxX = Math.max(a, k(this.maxX, -g)), l && \"undefined\" === typeof l.options.minRange && (l.minRange = Math.min(5 * h, (this.maxX - this.minX) / 5, l.minRange || g)), p && \"undefined\" === typeof p.options.minRange && (p.minRange = Math.min(5 * h, (this.maxY - this.minY) / 5, p.minRange || g)));\n      },\n      hasData: function () {\n        return !!this.processedXData.length;\n      },\n      getExtremes: function () {\n        B.prototype.getExtremes.call(this, this.valueData);\n        this.chart.hasRendered && this.isDirtyData && this.getBox(this.options.data);\n        this.valueMin = this.dataMin;\n        this.valueMax = this.dataMax;\n        this.dataMin = this.minY;\n        this.dataMax = this.maxY;\n      },\n      translatePath: function (c) {\n        var a = !1,\n            f = this.xAxis,\n            b = this.yAxis,\n            d = f.min,\n            k = f.transA;\n        f = f.minPixelPadding;\n        var h = b.min,\n            e = b.transA;\n        b = b.minPixelPadding;\n        var l,\n            p = [];\n        if (c) for (l = c.length; l--;) t(c[l]) ? (p[l] = a ? (c[l] - d) * k + f : (c[l] - h) * e + b, a = !a) : p[l] = c[l];\n        return p;\n      },\n      setData: function (c, g, f, d) {\n        var v = this.options,\n            k = this.chart.options.chart,\n            h = k && k.map,\n            e = v.mapData,\n            l = this.joinBy,\n            p = v.keys || this.pointArrayMap,\n            z = [],\n            m = {},\n            w = this.chart.mapTransforms;\n        !e && h && (e = \"string\" === typeof h ? b.maps[h] : h);\n        c && c.forEach(function (a, g) {\n          var f = 0;\n          if (t(a)) c[g] = {\n            value: a\n          };else if (A(a)) {\n            c[g] = {};\n            !v.keys && a.length > p.length && \"string\" === typeof a[0] && (c[g][\"hc-key\"] = a[0], ++f);\n\n            for (var b = 0; b < p.length; ++b, ++f) p[b] && \"undefined\" !== typeof a[f] && (0 < p[b].indexOf(\".\") ? u.prototype.setNestedProperty(c[g], a[f], p[b]) : c[g][p[b]] = a[f]);\n          }\n          l && \"_i\" === l[0] && (c[g]._i = g);\n        });\n        this.getBox(c);\n        (this.chart.mapTransforms = w = k && k.mapTransforms || e && e[\"hc-transform\"] || w) && a(w, function (c) {\n          c.rotation && (c.cosAngle = Math.cos(c.rotation), c.sinAngle = Math.sin(c.rotation));\n        });\n\n        if (e) {\n          \"FeatureCollection\" === e.type && (this.mapTitle = e.title, e = b.geojson(e, this.type, this));\n          this.mapData = e;\n          this.mapMap = {};\n\n          for (w = 0; w < e.length; w++) k = e[w], h = k.properties, k._i = w, l[0] && h && h[l[0]] && (k[l[0]] = h[l[0]]), m[k[l[0]]] = k;\n\n          this.mapMap = m;\n\n          if (c && l[1]) {\n            var y = l[1];\n            c.forEach(function (c) {\n              c = n(y, c);\n              m[c] && z.push(m[c]);\n            });\n          }\n\n          if (v.allAreas) {\n            this.getBox(e);\n            c = c || [];\n\n            if (l[1]) {\n              var x = l[1];\n              c.forEach(function (c) {\n                z.push(n(x, c));\n              });\n            }\n\n            z = \"|\" + z.map(function (c) {\n              return c && c[l[0]];\n            }).join(\"|\") + \"|\";\n            e.forEach(function (a) {\n              l[0] && -1 !== z.indexOf(\"|\" + a[l[0]] + \"|\") || (c.push(q(a, {\n                value: null\n              })), d = !1);\n            });\n          } else this.getBox(z);\n        }\n\n        B.prototype.setData.call(this, c, g, f, d);\n      },\n      drawGraph: w,\n      drawDataLabels: w,\n      doFullTranslate: function () {\n        return this.isDirtyData || this.chart.isResizing || this.chart.renderer.isVML || !this.baseTrans;\n      },\n      translate: function () {\n        var c = this,\n            a = c.xAxis,\n            f = c.yAxis,\n            b = c.doFullTranslate();\n        c.generatePoints();\n        c.data.forEach(function (g) {\n          t(g._midX) && t(g._midY) && (g.plotX = a.toPixels(g._midX, !0), g.plotY = f.toPixels(g._midY, !0));\n          b && (g.shapeType = \"path\", g.shapeArgs = {\n            d: c.translatePath(g.path)\n          });\n        });\n        h(c, \"afterTranslate\");\n      },\n      pointAttribs: function (c, a) {\n        a = c.series.chart.styledMode ? this.colorAttribs(c) : f.column.prototype.pointAttribs.call(this, c, a);\n        a[\"stroke-width\"] = k(c.options[this.pointAttrToOptions && this.pointAttrToOptions[\"stroke-width\"] || \"borderWidth\"], \"inherit\");\n        return a;\n      },\n      drawPoints: function () {\n        var c = this,\n            a = c.xAxis,\n            b = c.yAxis,\n            d = c.group,\n            e = c.chart,\n            h = e.renderer,\n            l = this.baseTrans;\n        c.transformGroup || (c.transformGroup = h.g().attr({\n          scaleX: 1,\n          scaleY: 1\n        }).add(d), c.transformGroup.survive = !0);\n        if (c.doFullTranslate()) e.hasRendered && !e.styledMode && c.points.forEach(function (a) {\n          a.shapeArgs && (a.shapeArgs.fill = c.pointAttribs(a, a.state).fill);\n        }), c.group = c.transformGroup, f.column.prototype.drawPoints.apply(c), c.group = d, c.points.forEach(function (a) {\n          if (a.graphic) {\n            var g = \"\";\n            a.name && (g += \"highcharts-name-\" + a.name.replace(/ /g, \"-\").toLowerCase());\n            a.properties && a.properties[\"hc-key\"] && (g += \" highcharts-key-\" + a.properties[\"hc-key\"].toLowerCase());\n            g && a.graphic.addClass(g);\n            e.styledMode && a.graphic.css(c.pointAttribs(a, a.selected && \"select\" || void 0));\n          }\n        }), this.baseTrans = {\n          originX: a.min - a.minPixelPadding / a.transA,\n          originY: b.min - b.minPixelPadding / b.transA + (b.reversed ? 0 : b.len / b.transA),\n          transAX: a.transA,\n          transAY: b.transA\n        }, this.transformGroup.animate({\n          translateX: 0,\n          translateY: 0,\n          scaleX: 1,\n          scaleY: 1\n        });else {\n          var p = a.transA / l.transAX;\n          var m = b.transA / l.transAY;\n          var q = a.toPixels(l.originX, !0);\n          var n = b.toPixels(l.originY, !0);\n          .99 < p && 1.01 > p && .99 < m && 1.01 > m && (m = p = 1, q = Math.round(q), n = Math.round(n));\n          var w = this.transformGroup;\n\n          if (e.renderer.globalAnimation) {\n            var B = w.attr(\"translateX\");\n            var y = w.attr(\"translateY\");\n            var u = w.attr(\"scaleX\");\n            var t = w.attr(\"scaleY\");\n            w.attr({\n              animator: 0\n            }).animate({\n              animator: 1\n            }, {\n              step: function (c, a) {\n                w.attr({\n                  translateX: B + (q - B) * a.pos,\n                  translateY: y + (n - y) * a.pos,\n                  scaleX: u + (p - u) * a.pos,\n                  scaleY: t + (m - t) * a.pos\n                });\n              }\n            });\n          } else w.attr({\n            translateX: q,\n            translateY: n,\n            scaleX: p,\n            scaleY: m\n          });\n        }\n        e.styledMode || d.element.setAttribute(\"stroke-width\", k(c.options[c.pointAttrToOptions && c.pointAttrToOptions[\"stroke-width\"] || \"borderWidth\"], 1) / (p || 1));\n        this.drawMapDataLabels();\n      },\n      drawMapDataLabels: function () {\n        B.prototype.drawDataLabels.call(this);\n        this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect);\n      },\n      render: function () {\n        var c = this,\n            a = B.prototype.render;\n        c.chart.renderer.isVML && 3E3 < c.data.length ? setTimeout(function () {\n          a.call(c);\n        }) : a.call(c);\n      },\n      animate: function (c) {\n        var a = this.options.animation,\n            f = this.group,\n            b = this.xAxis,\n            d = this.yAxis,\n            k = b.pos,\n            e = d.pos;\n        this.chart.renderer.isSVG && (!0 === a && (a = {\n          duration: 1E3\n        }), c ? f.attr({\n          translateX: k + b.len / 2,\n          translateY: e + d.len / 2,\n          scaleX: .001,\n          scaleY: .001\n        }) : (f.animate({\n          translateX: k,\n          translateY: e,\n          scaleX: 1,\n          scaleY: 1\n        }, a), this.animate = null));\n      },\n      animateDrilldown: function (c) {\n        var a = this.chart.plotBox,\n            f = this.chart.drilldownLevels[this.chart.drilldownLevels.length - 1],\n            b = f.bBox,\n            d = this.chart.options.drilldown.animation;\n        c || (c = Math.min(b.width / a.width, b.height / a.height), f.shapeArgs = {\n          scaleX: c,\n          scaleY: c,\n          translateX: b.x,\n          translateY: b.y\n        }, this.points.forEach(function (c) {\n          c.graphic && c.graphic.attr(f.shapeArgs).animate({\n            scaleX: 1,\n            scaleY: 1,\n            translateX: 0,\n            translateY: 0\n          }, d);\n        }), this.animate = null);\n      },\n      drawLegendSymbol: d.drawRectangle,\n      animateDrillupFrom: function (c) {\n        f.column.prototype.animateDrillupFrom.call(this, c);\n      },\n      animateDrillupTo: function (c) {\n        f.column.prototype.animateDrillupTo.call(this, c);\n      }\n    }), m({\n      applyOptions: function (c, a) {\n        var f = this.series;\n        c = u.prototype.applyOptions.call(this, c, a);\n        a = f.joinBy;\n        f.mapData && f.mapMap && (a = u.prototype.getNestedProperty.call(c, a[1]), (a = \"undefined\" !== typeof a && f.mapMap[a]) ? (f.xyFromShape && (c.x = a._midX, c.y = a._midY), m(c, a)) : c.value = c.value || null);\n        return c;\n      },\n      onMouseOver: function (c) {\n        e.clearTimeout(this.colorInterval);\n        if (null !== this.value || this.series.options.nullInteraction) u.prototype.onMouseOver.call(this, c);else this.series.onMouseOut(c);\n      },\n      zoomTo: function () {\n        var c = this.series;\n        c.xAxis.setExtremes(this._minX, this._maxX, !1);\n        c.yAxis.setExtremes(this._minY, this._maxY, !1);\n        c.chart.redraw();\n      }\n    }, y));\n    \"\";\n  });\n  x(d, \"parts-map/MapLineSeries.js\", [d[\"parts/Globals.js\"], d[\"parts/Utilities.js\"]], function (b, d) {\n    d = d.seriesType;\n    var n = b.seriesTypes;\n    d(\"mapline\", \"map\", {\n      lineWidth: 1,\n      fillColor: \"none\"\n    }, {\n      type: \"mapline\",\n      colorProp: \"stroke\",\n      pointAttrToOptions: {\n        stroke: \"color\",\n        \"stroke-width\": \"lineWidth\"\n      },\n      pointAttribs: function (b, d) {\n        b = n.map.prototype.pointAttribs.call(this, b, d);\n        b.fill = this.options.fillColor;\n        return b;\n      },\n      drawLegendSymbol: n.line.prototype.drawLegendSymbol\n    });\n    \"\";\n  });\n  x(d, \"parts-map/MapPointSeries.js\", [d[\"parts/Globals.js\"]], function (b) {\n    var d = b.merge,\n        u = b.Point,\n        e = b.Series;\n    b = b.seriesType;\n    b(\"mappoint\", \"scatter\", {\n      dataLabels: {\n        crop: !1,\n        defer: !1,\n        enabled: !0,\n        formatter: function () {\n          return this.point.name;\n        },\n        overflow: !1,\n        style: {\n          color: \"#000000\"\n        }\n      }\n    }, {\n      type: \"mappoint\",\n      forceDL: !0,\n      drawDataLabels: function () {\n        e.prototype.drawDataLabels.call(this);\n        this.dataLabelsGroup && this.dataLabelsGroup.clip(this.chart.clipRect);\n      }\n    }, {\n      applyOptions: function (b, e) {\n        b = \"undefined\" !== typeof b.lat && \"undefined\" !== typeof b.lon ? d(b, this.series.chart.fromLatLonToPoint(b)) : b;\n        return u.prototype.applyOptions.call(this, b, e);\n      }\n    });\n    \"\";\n  });\n  x(d, \"parts-more/BubbleLegend.js\", [d[\"parts/Globals.js\"], d[\"parts/Color.js\"], d[\"parts/Legend.js\"], d[\"parts/Utilities.js\"]], function (b, d, u, e) {\n    \"\";\n\n    var m = d.parse;\n    d = e.addEvent;\n    var h = e.arrayMax,\n        n = e.arrayMin,\n        A = e.isNumber,\n        t = e.merge,\n        q = e.objectEach,\n        a = e.pick,\n        k = e.stableSort,\n        l = e.wrap,\n        p = b.Series,\n        y = b.Chart,\n        w = b.noop,\n        B = b.setOptions;\n    B({\n      legend: {\n        bubbleLegend: {\n          borderColor: void 0,\n          borderWidth: 2,\n          className: void 0,\n          color: void 0,\n          connectorClassName: void 0,\n          connectorColor: void 0,\n          connectorDistance: 60,\n          connectorWidth: 1,\n          enabled: !1,\n          labels: {\n            className: void 0,\n            allowOverlap: !1,\n            format: \"\",\n            formatter: void 0,\n            align: \"right\",\n            style: {\n              fontSize: 10,\n              color: void 0\n            },\n            x: 0,\n            y: 0\n          },\n          maxSize: 60,\n          minSize: 10,\n          legendIndex: 0,\n          ranges: {\n            value: void 0,\n            borderColor: void 0,\n            color: void 0,\n            connectorColor: void 0\n          },\n          sizeBy: \"area\",\n          sizeByAbsoluteValue: !1,\n          zIndex: 1,\n          zThreshold: 0\n        }\n      }\n    });\n\n    b.BubbleLegend = function (a, c) {\n      this.init(a, c);\n    };\n\n    b.BubbleLegend.prototype = {\n      init: function (a, c) {\n        this.options = a;\n        this.visible = !0;\n        this.chart = c.chart;\n        this.legend = c;\n      },\n      setState: w,\n      addToLegend: function (a) {\n        a.splice(this.options.legendIndex, 0, this);\n      },\n      drawLegendSymbol: function (f) {\n        var c = this.chart,\n            b = this.options,\n            d = a(f.options.itemDistance, 20),\n            e = b.ranges;\n        var h = b.connectorDistance;\n        this.fontMetrics = c.renderer.fontMetrics(b.labels.style.fontSize.toString() + \"px\");\n        e && e.length && A(e[0].value) ? (k(e, function (c, a) {\n          return a.value - c.value;\n        }), this.ranges = e, this.setOptions(), this.render(), c = this.getMaxLabelSize(), e = this.ranges[0].radius, f = 2 * e, h = h - e + c.width, h = 0 < h ? h : 0, this.maxLabel = c, this.movementX = \"left\" === b.labels.align ? h : 0, this.legendItemWidth = f + h + d, this.legendItemHeight = f + this.fontMetrics.h / 2) : f.options.bubbleLegend.autoRanges = !0;\n      },\n      setOptions: function () {\n        var f = this.ranges,\n            c = this.options,\n            b = this.chart.series[c.seriesIndex],\n            d = this.legend.baseline,\n            e = {\n          \"z-index\": c.zIndex,\n          \"stroke-width\": c.borderWidth\n        },\n            k = {\n          \"z-index\": c.zIndex,\n          \"stroke-width\": c.connectorWidth\n        },\n            h = this.getLabelStyles(),\n            l = b.options.marker.fillOpacity,\n            p = this.chart.styledMode;\n        f.forEach(function (g, v) {\n          p || (e.stroke = a(g.borderColor, c.borderColor, b.color), e.fill = a(g.color, c.color, 1 !== l ? m(b.color).setOpacity(l).get(\"rgba\") : b.color), k.stroke = a(g.connectorColor, c.connectorColor, b.color));\n          f[v].radius = this.getRangeRadius(g.value);\n          f[v] = t(f[v], {\n            center: f[0].radius - f[v].radius + d\n          });\n          p || t(!0, f[v], {\n            bubbleStyle: t(!1, e),\n            connectorStyle: t(!1, k),\n            labelStyle: h\n          });\n        }, this);\n      },\n      getLabelStyles: function () {\n        var f = this.options,\n            c = {},\n            b = \"left\" === f.labels.align,\n            d = this.legend.options.rtl;\n        q(f.labels.style, function (a, b) {\n          \"color\" !== b && \"fontSize\" !== b && \"z-index\" !== b && (c[b] = a);\n        });\n        return t(!1, c, {\n          \"font-size\": f.labels.style.fontSize,\n          fill: a(f.labels.style.color, \"#000000\"),\n          \"z-index\": f.zIndex,\n          align: d || b ? \"right\" : \"left\"\n        });\n      },\n      getRangeRadius: function (a) {\n        var c = this.options;\n        return this.chart.series[this.options.seriesIndex].getRadius.call(this, c.ranges[c.ranges.length - 1].value, c.ranges[0].value, c.minSize, c.maxSize, a);\n      },\n      render: function () {\n        var a = this.chart.renderer,\n            c = this.options.zThreshold;\n        this.symbols || (this.symbols = {\n          connectors: [],\n          bubbleItems: [],\n          labels: []\n        });\n        this.legendSymbol = a.g(\"bubble-legend\");\n        this.legendItem = a.g(\"bubble-legend-item\");\n        this.legendSymbol.translateX = 0;\n        this.legendSymbol.translateY = 0;\n        this.ranges.forEach(function (a) {\n          a.value >= c && this.renderRange(a);\n        }, this);\n        this.legendSymbol.add(this.legendItem);\n        this.legendItem.add(this.legendGroup);\n        this.hideOverlappingLabels();\n      },\n      renderRange: function (a) {\n        var c = this.options,\n            b = c.labels,\n            f = this.chart.renderer,\n            d = this.symbols,\n            e = d.labels,\n            k = a.center,\n            h = Math.abs(a.radius),\n            l = c.connectorDistance,\n            p = b.align,\n            q = b.style.fontSize;\n        l = this.legend.options.rtl || \"left\" === p ? -l : l;\n        b = c.connectorWidth;\n        var w = this.ranges[0].radius,\n            m = k - h - c.borderWidth / 2 + b / 2;\n        q = q / 2 - (this.fontMetrics.h - q) / 2;\n        var n = f.styledMode;\n        \"center\" === p && (l = 0, c.connectorDistance = 0, a.labelStyle.align = \"center\");\n        p = m + c.labels.y;\n        var B = w + l + c.labels.x;\n        d.bubbleItems.push(f.circle(w, k + ((m % 1 ? 1 : .5) - (b % 2 ? 0 : .5)), h).attr(n ? {} : a.bubbleStyle).addClass((n ? \"highcharts-color-\" + this.options.seriesIndex + \" \" : \"\") + \"highcharts-bubble-legend-symbol \" + (c.className || \"\")).add(this.legendSymbol));\n        d.connectors.push(f.path(f.crispLine([\"M\", w, m, \"L\", w + l, m], c.connectorWidth)).attr(n ? {} : a.connectorStyle).addClass((n ? \"highcharts-color-\" + this.options.seriesIndex + \" \" : \"\") + \"highcharts-bubble-legend-connectors \" + (c.connectorClassName || \"\")).add(this.legendSymbol));\n        a = f.text(this.formatLabel(a), B, p + q).attr(n ? {} : a.labelStyle).addClass(\"highcharts-bubble-legend-labels \" + (c.labels.className || \"\")).add(this.legendSymbol);\n        e.push(a);\n        a.placed = !0;\n        a.alignAttr = {\n          x: B,\n          y: p + q\n        };\n      },\n      getMaxLabelSize: function () {\n        var a, c;\n        this.symbols.labels.forEach(function (b) {\n          c = b.getBBox(!0);\n          a = a ? c.width > a.width ? c : a : c;\n        });\n        return a || {};\n      },\n      formatLabel: function (a) {\n        var c = this.options,\n            b = c.labels.formatter;\n        c = c.labels.format;\n        var f = this.chart.numberFormatter;\n        return c ? e.format(c, a) : b ? b.call(a) : f(a.value, 1);\n      },\n      hideOverlappingLabels: function () {\n        var a = this.chart,\n            c = this.symbols;\n        !this.options.labels.allowOverlap && c && (a.hideOverlappingLabels(c.labels), c.labels.forEach(function (a, b) {\n          a.newOpacity ? a.newOpacity !== a.oldOpacity && c.connectors[b].show() : c.connectors[b].hide();\n        }));\n      },\n      getRanges: function () {\n        var b = this.legend.bubbleLegend,\n            c = b.options.ranges,\n            d,\n            e = Number.MAX_VALUE,\n            k = -Number.MAX_VALUE;\n        b.chart.series.forEach(function (c) {\n          c.isBubble && !c.ignoreSeries && (d = c.zData.filter(A), d.length && (e = a(c.options.zMin, Math.min(e, Math.max(n(d), !1 === c.options.displayNegative ? c.options.zThreshold : -Number.MAX_VALUE))), k = a(c.options.zMax, Math.max(k, h(d)))));\n        });\n        var l = e === k ? [{\n          value: k\n        }] : [{\n          value: e\n        }, {\n          value: (e + k) / 2\n        }, {\n          value: k,\n          autoRanges: !0\n        }];\n        c.length && c[0].radius && l.reverse();\n        l.forEach(function (a, b) {\n          c && c[b] && (l[b] = t(!1, c[b], a));\n        });\n        return l;\n      },\n      predictBubbleSizes: function () {\n        var a = this.chart,\n            c = this.fontMetrics,\n            b = a.legend.options,\n            d = \"horizontal\" === b.layout,\n            k = d ? a.legend.lastLineHeight : 0,\n            e = a.plotSizeX,\n            h = a.plotSizeY,\n            l = a.series[this.options.seriesIndex];\n        a = Math.ceil(l.minPxSize);\n        var p = Math.ceil(l.maxPxSize);\n        l = l.options.maxSize;\n        var q = Math.min(h, e);\n        if (b.floating || !/%$/.test(l)) c = p;else if (l = parseFloat(l), c = (q + k - c.h / 2) * l / 100 / (l / 100 + 1), d && h - c >= e || !d && e - c >= h) c = p;\n        return [a, Math.ceil(c)];\n      },\n      updateRanges: function (a, c) {\n        var b = this.legend.options.bubbleLegend;\n        b.minSize = a;\n        b.maxSize = c;\n        b.ranges = this.getRanges();\n      },\n      correctSizes: function () {\n        var a = this.legend,\n            c = this.chart.series[this.options.seriesIndex];\n        1 < Math.abs(Math.ceil(c.maxPxSize) - this.options.maxSize) && (this.updateRanges(this.options.minSize, c.maxPxSize), a.render());\n      }\n    };\n    d(u, \"afterGetAllItems\", function (a) {\n      var c = this.bubbleLegend,\n          d = this.options,\n          f = d.bubbleLegend,\n          e = this.chart.getVisibleBubbleSeriesIndex();\n      c && c.ranges && c.ranges.length && (f.ranges.length && (f.autoRanges = !!f.ranges[0].autoRanges), this.destroyItem(c));\n      0 <= e && d.enabled && f.enabled && (f.seriesIndex = e, this.bubbleLegend = new b.BubbleLegend(f, this), this.bubbleLegend.addToLegend(a.allItems));\n    });\n\n    y.prototype.getVisibleBubbleSeriesIndex = function () {\n      for (var a = this.series, c = 0; c < a.length;) {\n        if (a[c] && a[c].isBubble && a[c].visible && a[c].zData.length) return c;\n        c++;\n      }\n\n      return -1;\n    };\n\n    u.prototype.getLinesHeights = function () {\n      var a = this.allItems,\n          c = [],\n          b = a.length,\n          d,\n          e = 0;\n\n      for (d = 0; d < b; d++) if (a[d].legendItemHeight && (a[d].itemHeight = a[d].legendItemHeight), a[d] === a[b - 1] || a[d + 1] && a[d]._legendItemPos[1] !== a[d + 1]._legendItemPos[1]) {\n        c.push({\n          height: 0\n        });\n        var k = c[c.length - 1];\n\n        for (e; e <= d; e++) a[e].itemHeight > k.height && (k.height = a[e].itemHeight);\n\n        k.step = d;\n      }\n\n      return c;\n    };\n\n    u.prototype.retranslateItems = function (a) {\n      var c,\n          b,\n          d,\n          f = this.options.rtl,\n          e = 0;\n      this.allItems.forEach(function (g, k) {\n        c = g.legendGroup.translateX;\n        b = g._legendItemPos[1];\n        if ((d = g.movementX) || f && g.ranges) d = f ? c - g.options.maxSize / 2 : c + d, g.legendGroup.attr({\n          translateX: d\n        });\n        k > a[e].step && e++;\n        g.legendGroup.attr({\n          translateY: Math.round(b + a[e].height / 2)\n        });\n        g._legendItemPos[1] = b + a[e].height / 2;\n      });\n    };\n\n    d(p, \"legendItemClick\", function () {\n      var a = this.chart,\n          c = this.visible,\n          b = this.chart.legend;\n      b && b.bubbleLegend && (this.visible = !c, this.ignoreSeries = c, a = 0 <= a.getVisibleBubbleSeriesIndex(), b.bubbleLegend.visible !== a && (b.update({\n        bubbleLegend: {\n          enabled: a\n        }\n      }), b.bubbleLegend.visible = a), this.visible = c);\n    });\n    l(y.prototype, \"drawChartBox\", function (a, c, b) {\n      var d = this.legend,\n          f = 0 <= this.getVisibleBubbleSeriesIndex();\n\n      if (d && d.options.enabled && d.bubbleLegend && d.options.bubbleLegend.autoRanges && f) {\n        var g = d.bubbleLegend.options;\n        f = d.bubbleLegend.predictBubbleSizes();\n        d.bubbleLegend.updateRanges(f[0], f[1]);\n        g.placed || (d.group.placed = !1, d.allItems.forEach(function (a) {\n          a.legendGroup.translateY = null;\n        }));\n        d.render();\n        this.getMargins();\n        this.axes.forEach(function (a) {\n          a.visible && a.render();\n          g.placed || (a.setScale(), a.updateNames(), q(a.ticks, function (a) {\n            a.isNew = !0;\n            a.isNewLabel = !0;\n          }));\n        });\n        g.placed = !0;\n        this.getMargins();\n        a.call(this, c, b);\n        d.bubbleLegend.correctSizes();\n        d.retranslateItems(d.getLinesHeights());\n      } else a.call(this, c, b), d && d.options.enabled && d.bubbleLegend && (d.render(), d.retranslateItems(d.getLinesHeights()));\n    });\n  });\n  x(d, \"parts-more/BubbleSeries.js\", [d[\"parts/Globals.js\"], d[\"parts/Color.js\"], d[\"parts/Point.js\"], d[\"parts/Utilities.js\"]], function (b, d, u, e) {\n    var m = d.parse,\n        h = e.arrayMax,\n        n = e.arrayMin,\n        A = e.clamp,\n        t = e.extend,\n        q = e.isNumber,\n        a = e.pick,\n        k = e.pInt;\n    d = e.seriesType;\n    e = b.Axis;\n    var l = b.noop,\n        p = b.Series,\n        y = b.seriesTypes;\n    d(\"bubble\", \"scatter\", {\n      dataLabels: {\n        formatter: function () {\n          return this.point.z;\n        },\n        inside: !0,\n        verticalAlign: \"middle\"\n      },\n      animationLimit: 250,\n      marker: {\n        lineColor: null,\n        lineWidth: 1,\n        fillOpacity: .5,\n        radius: null,\n        states: {\n          hover: {\n            radiusPlus: 0\n          }\n        },\n        symbol: \"circle\"\n      },\n      minSize: 8,\n      maxSize: \"20%\",\n      softThreshold: !1,\n      states: {\n        hover: {\n          halo: {\n            size: 5\n          }\n        }\n      },\n      tooltip: {\n        pointFormat: \"({point.x}, {point.y}), Size: {point.z}\"\n      },\n      turboThreshold: 0,\n      zThreshold: 0,\n      zoneAxis: \"z\"\n    }, {\n      pointArrayMap: [\"y\", \"z\"],\n      parallelArrays: [\"x\", \"y\", \"z\"],\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      specialGroup: \"group\",\n      bubblePadding: !0,\n      zoneAxis: \"z\",\n      directTouch: !0,\n      isBubble: !0,\n      pointAttribs: function (a, b) {\n        var d = this.options.marker.fillOpacity;\n        a = p.prototype.pointAttribs.call(this, a, b);\n        1 !== d && (a.fill = m(a.fill).setOpacity(d).get(\"rgba\"));\n        return a;\n      },\n      getRadii: function (a, b, d) {\n        var c = this.zData,\n            f = this.yData,\n            e = d.minPxSize,\n            k = d.maxPxSize,\n            l = [];\n        var h = 0;\n\n        for (d = c.length; h < d; h++) {\n          var p = c[h];\n          l.push(this.getRadius(a, b, e, k, p, f[h]));\n        }\n\n        this.radii = l;\n      },\n      getRadius: function (a, b, d, c, g, e) {\n        var f = this.options,\n            k = \"width\" !== f.sizeBy,\n            l = f.zThreshold,\n            h = b - a,\n            p = .5;\n        if (null === e || null === g) return null;\n\n        if (q(g)) {\n          f.sizeByAbsoluteValue && (g = Math.abs(g - l), h = Math.max(b - l, Math.abs(a - l)), a = 0);\n          if (g < a) return d / 2 - 1;\n          0 < h && (p = (g - a) / h);\n        }\n\n        k && 0 <= p && (p = Math.sqrt(p));\n        return Math.ceil(d + p * (c - d)) / 2;\n      },\n      animate: function (a) {\n        !a && this.points.length < this.options.animationLimit && (this.points.forEach(function (a) {\n          var b = a.graphic;\n\n          if (b && b.width) {\n            var c = {\n              x: b.x,\n              y: b.y,\n              width: b.width,\n              height: b.height\n            };\n            b.attr({\n              x: a.plotX,\n              y: a.plotY,\n              width: 1,\n              height: 1\n            });\n            b.animate(c, this.options.animation);\n          }\n        }, this), this.animate = null);\n      },\n      hasData: function () {\n        return !!this.processedXData.length;\n      },\n      translate: function () {\n        var a,\n            b = this.data,\n            d = this.radii;\n        y.scatter.prototype.translate.call(this);\n\n        for (a = b.length; a--;) {\n          var c = b[a];\n          var g = d ? d[a] : 0;\n          q(g) && g >= this.minPxSize / 2 ? (c.marker = t(c.marker, {\n            radius: g,\n            width: 2 * g,\n            height: 2 * g\n          }), c.dlBox = {\n            x: c.plotX - g,\n            y: c.plotY - g,\n            width: 2 * g,\n            height: 2 * g\n          }) : c.shapeArgs = c.plotY = c.dlBox = void 0;\n        }\n      },\n      alignDataLabel: y.column.prototype.alignDataLabel,\n      buildKDTree: l,\n      applyZones: l\n    }, {\n      haloPath: function (a) {\n        return u.prototype.haloPath.call(this, 0 === a ? 0 : (this.marker ? this.marker.radius || 0 : 0) + a);\n      },\n      ttBelow: !1\n    });\n\n    e.prototype.beforePadding = function () {\n      var b = this,\n          d = this.len,\n          f = this.chart,\n          c = 0,\n          g = d,\n          e = this.isXAxis,\n          l = e ? \"xData\" : \"yData\",\n          p = this.min,\n          m = {},\n          y = Math.min(f.plotWidth, f.plotHeight),\n          u = Number.MAX_VALUE,\n          t = -Number.MAX_VALUE,\n          x = this.max - p,\n          C = d / x,\n          E = [];\n      this.series.forEach(function (c) {\n        var d = c.options;\n        !c.bubblePadding || !c.visible && f.options.chart.ignoreHiddenSeries || (b.allowZoomOutside = !0, E.push(c), e && ([\"minSize\", \"maxSize\"].forEach(function (a) {\n          var c = d[a],\n              b = /%$/.test(c);\n          c = k(c);\n          m[a] = b ? y * c / 100 : c;\n        }), c.minPxSize = m.minSize, c.maxPxSize = Math.max(m.maxSize, m.minSize), c = c.zData.filter(q), c.length && (u = a(d.zMin, A(n(c), !1 === d.displayNegative ? d.zThreshold : -Number.MAX_VALUE, u)), t = a(d.zMax, Math.max(t, h(c))))));\n      });\n      E.forEach(function (a) {\n        var d = a[l],\n            f = d.length;\n        e && a.getRadii(u, t, a);\n        if (0 < x) for (; f--;) if (q(d[f]) && b.dataMin <= d[f] && d[f] <= b.max) {\n          var k = a.radii ? a.radii[f] : 0;\n          c = Math.min((d[f] - p) * C - k, c);\n          g = Math.max((d[f] - p) * C + k, g);\n        }\n      });\n      E.length && 0 < x && !this.isLog && (g -= d, C *= (d + Math.max(0, c) - Math.min(g, d)) / d, [[\"min\", \"userMin\", c], [\"max\", \"userMax\", g]].forEach(function (c) {\n        \"undefined\" === typeof a(b.options[c[0]], b[c[1]]) && (b[c[0]] += c[2] / C);\n      }));\n    };\n\n    \"\";\n  });\n  x(d, \"parts-map/MapBubbleSeries.js\", [d[\"parts/Globals.js\"], d[\"parts/Point.js\"], d[\"parts/Utilities.js\"]], function (b, d, u) {\n    var e = u.merge;\n    u = u.seriesType;\n    var m = b.seriesTypes;\n    m.bubble && u(\"mapbubble\", \"bubble\", {\n      animationLimit: 500,\n      tooltip: {\n        pointFormat: \"{point.name}: {point.z}\"\n      }\n    }, {\n      xyFromShape: !0,\n      type: \"mapbubble\",\n      pointArrayMap: [\"z\"],\n      getMapData: m.map.prototype.getMapData,\n      getBox: m.map.prototype.getBox,\n      setData: m.map.prototype.setData,\n      setOptions: m.map.prototype.setOptions\n    }, {\n      applyOptions: function (b, n) {\n        return b && \"undefined\" !== typeof b.lat && \"undefined\" !== typeof b.lon ? d.prototype.applyOptions.call(this, e(b, this.series.chart.fromLatLonToPoint(b)), n) : m.map.prototype.pointClass.prototype.applyOptions.call(this, b, n);\n      },\n      isValid: function () {\n        return \"number\" === typeof this.z;\n      },\n      ttBelow: !1\n    });\n    \"\";\n  });\n  x(d, \"parts-map/HeatmapSeries.js\", [d[\"parts/Globals.js\"], d[\"mixins/legend-symbol.js\"], d[\"parts/Utilities.js\"]], function (b, d, u) {\n    var e = u.clamp,\n        m = u.extend,\n        h = u.fireEvent,\n        n = u.merge,\n        x = u.pick;\n    u = u.seriesType;\n    var t = b.colorMapPointMixin,\n        q = b.noop,\n        a = b.Series,\n        k = b.seriesTypes;\n    u(\"heatmap\", \"scatter\", {\n      animation: !1,\n      borderWidth: 0,\n      nullColor: \"#f7f7f7\",\n      dataLabels: {\n        formatter: function () {\n          return this.point.value;\n        },\n        inside: !0,\n        verticalAlign: \"middle\",\n        crop: !1,\n        overflow: !1,\n        padding: 0\n      },\n      marker: null,\n      pointRange: null,\n      tooltip: {\n        pointFormat: \"{point.x}, {point.y}: {point.value}<br/>\"\n      },\n      states: {\n        hover: {\n          halo: !1,\n          brightness: .2\n        }\n      }\n    }, n(b.colorMapSeriesMixin, {\n      pointArrayMap: [\"y\", \"value\"],\n      hasPointSpecificOptions: !0,\n      getExtremesFromAll: !0,\n      directTouch: !0,\n      init: function () {\n        k.scatter.prototype.init.apply(this, arguments);\n        var a = this.options;\n        a.pointRange = x(a.pointRange, a.colsize || 1);\n        this.yAxis.axisPointRange = a.rowsize || 1;\n      },\n      translate: function () {\n        this.generatePoints();\n        var a = this.options,\n            b = a.colsize,\n            d = a.pointPadding,\n            k = void 0 === d ? 0 : d;\n        a = a.rowsize;\n        d = this.points;\n\n        var q = this.xAxis,\n            f = this.yAxis,\n            c = (void 0 === b ? 1 : b) / 2,\n            g = (void 0 === a ? 1 : a) / 2,\n            m = this.pointPlacementToXValue(),\n            n = function (a) {\n          return Math.round(e(q.translate(a, !1, !1, !1, !0, m), 0, q.len));\n        };\n\n        d.forEach(function (a) {\n          var b = n(a.x - c),\n              d = n(a.x + c),\n              l = Math.round(e(f.translate(a.y - g, !1, !0, !1, !0), 0, f.len)),\n              h = Math.round(e(f.translate(a.y + g, !1, !0, !1, !0), 0, f.len)),\n              p = x(a.pointPadding, k);\n          a.plotX = a.clientX = (b + d) / 2;\n          a.plotY = (l + h) / 2;\n          a.shapeType = \"rect\";\n          a.shapeArgs = {\n            x: Math.min(b, d) + p,\n            y: Math.min(l, h) + p,\n            width: Math.max(Math.abs(d - b) - 2 * p, 0),\n            height: Math.max(Math.abs(h - l) - 2 * p, 0)\n          };\n        });\n        h(this, \"afterTranslate\");\n      },\n      drawPoints: function () {\n        var a = this.chart.styledMode ? \"css\" : \"animate\";\n        k.column.prototype.drawPoints.call(this);\n        this.points.forEach(function (b) {\n          b.graphic[a](this.colorAttribs(b));\n        }, this);\n      },\n      hasData: function () {\n        return !!this.processedXData.length;\n      },\n      getValidPoints: function (b, d) {\n        return a.prototype.getValidPoints.call(this, b, d, !0);\n      },\n      animate: q,\n      getBox: q,\n      drawLegendSymbol: d.drawRectangle,\n      alignDataLabel: k.column.prototype.alignDataLabel,\n      getExtremes: function () {\n        a.prototype.getExtremes.call(this, this.valueData);\n        this.valueMin = this.dataMin;\n        this.valueMax = this.dataMax;\n        a.prototype.getExtremes.call(this);\n      }\n    }), m({\n      haloPath: function (a) {\n        if (!a) return [];\n        var b = this.shapeArgs;\n        return [\"M\", b.x - a, b.y - a, \"L\", b.x - a, b.y + b.height + a, b.x + b.width + a, b.y + b.height + a, b.x + b.width + a, b.y - a, \"Z\"];\n      }\n    }, t));\n    \"\";\n  });\n  x(d, \"parts-map/GeoJSON.js\", [d[\"parts/Globals.js\"], d[\"parts/Utilities.js\"]], function (b, d) {\n    function n(b, a) {\n      var d,\n          e = !1,\n          h = b.x,\n          m = b.y;\n      b = 0;\n\n      for (d = a.length - 1; b < a.length; d = b++) {\n        var q = a[b][1] > m;\n        var n = a[d][1] > m;\n        q !== n && h < (a[d][0] - a[b][0]) * (m - a[b][1]) / (a[d][1] - a[b][1]) + a[b][0] && (e = !e);\n      }\n\n      return e;\n    }\n\n    var e = d.error,\n        m = d.extend,\n        h = d.format,\n        x = d.merge;\n    d = d.wrap;\n    var A = b.Chart,\n        t = b.win;\n\n    A.prototype.transformFromLatLon = function (b, a) {\n      var d,\n          h = (null === (d = this.userOptions.chart) || void 0 === d ? void 0 : d.proj4) || t.proj4;\n      if (!h) return e(21, !1, this), {\n        x: 0,\n        y: null\n      };\n      b = h(a.crs, [b.lon, b.lat]);\n      d = a.cosAngle || a.rotation && Math.cos(a.rotation);\n      h = a.sinAngle || a.rotation && Math.sin(a.rotation);\n      b = a.rotation ? [b[0] * d + b[1] * h, -b[0] * h + b[1] * d] : b;\n      return {\n        x: ((b[0] - (a.xoffset || 0)) * (a.scale || 1) + (a.xpan || 0)) * (a.jsonres || 1) + (a.jsonmarginX || 0),\n        y: (((a.yoffset || 0) - b[1]) * (a.scale || 1) + (a.ypan || 0)) * (a.jsonres || 1) - (a.jsonmarginY || 0)\n      };\n    };\n\n    A.prototype.transformToLatLon = function (b, a) {\n      if (\"undefined\" === typeof t.proj4) e(21, !1, this);else {\n        b = {\n          x: ((b.x - (a.jsonmarginX || 0)) / (a.jsonres || 1) - (a.xpan || 0)) / (a.scale || 1) + (a.xoffset || 0),\n          y: ((-b.y - (a.jsonmarginY || 0)) / (a.jsonres || 1) + (a.ypan || 0)) / (a.scale || 1) + (a.yoffset || 0)\n        };\n        var d = a.cosAngle || a.rotation && Math.cos(a.rotation),\n            h = a.sinAngle || a.rotation && Math.sin(a.rotation);\n        a = t.proj4(a.crs, \"WGS84\", a.rotation ? {\n          x: b.x * d + b.y * -h,\n          y: b.x * h + b.y * d\n        } : b);\n        return {\n          lat: a.y,\n          lon: a.x\n        };\n      }\n    };\n\n    A.prototype.fromPointToLatLon = function (b) {\n      var a = this.mapTransforms,\n          d;\n\n      if (a) {\n        for (d in a) if (Object.hasOwnProperty.call(a, d) && a[d].hitZone && n({\n          x: b.x,\n          y: -b.y\n        }, a[d].hitZone.coordinates[0])) return this.transformToLatLon(b, a[d]);\n\n        return this.transformToLatLon(b, a[\"default\"]);\n      }\n\n      e(22, !1, this);\n    };\n\n    A.prototype.fromLatLonToPoint = function (b) {\n      var a = this.mapTransforms,\n          d;\n      if (!a) return e(22, !1, this), {\n        x: 0,\n        y: null\n      };\n\n      for (d in a) if (Object.hasOwnProperty.call(a, d) && a[d].hitZone) {\n        var h = this.transformFromLatLon(b, a[d]);\n        if (n({\n          x: h.x,\n          y: -h.y\n        }, a[d].hitZone.coordinates[0])) return h;\n      }\n\n      return this.transformFromLatLon(b, a[\"default\"]);\n    };\n\n    b.geojson = function (b, a, d) {\n      var e = [],\n          k = [],\n          n = function (a) {\n        var b,\n            d = a.length;\n        k.push(\"M\");\n\n        for (b = 0; b < d; b++) 1 === b && k.push(\"L\"), k.push(a[b][0], -a[b][1]);\n      };\n\n      a = a || \"map\";\n      b.features.forEach(function (b) {\n        var d = b.geometry,\n            f = d.type;\n        d = d.coordinates;\n        b = b.properties;\n        var c;\n        k = [];\n        \"map\" === a || \"mapbubble\" === a ? (\"Polygon\" === f ? (d.forEach(n), k.push(\"Z\")) : \"MultiPolygon\" === f && (d.forEach(function (a) {\n          a.forEach(n);\n        }), k.push(\"Z\")), k.length && (c = {\n          path: k\n        })) : \"mapline\" === a ? (\"LineString\" === f ? n(d) : \"MultiLineString\" === f && d.forEach(n), k.length && (c = {\n          path: k\n        })) : \"mappoint\" === a && \"Point\" === f && (c = {\n          x: d[0],\n          y: -d[1]\n        });\n        c && e.push(m(c, {\n          name: b.name || b.NAME,\n          properties: b\n        }));\n      });\n      d && b.copyrightShort && (d.chart.mapCredits = h(d.chart.options.credits.mapText, {\n        geojson: b\n      }), d.chart.mapCreditsFull = h(d.chart.options.credits.mapTextFull, {\n        geojson: b\n      }));\n      return e;\n    };\n\n    d(A.prototype, \"addCredits\", function (b, a) {\n      a = x(!0, this.options.credits, a);\n      this.mapCredits && (a.href = null);\n      b.call(this, a);\n      this.credits && this.mapCreditsFull && this.credits.attr({\n        title: this.mapCreditsFull\n      });\n    });\n  });\n  x(d, \"parts-map/Map.js\", [d[\"parts/Globals.js\"], d[\"parts/Utilities.js\"]], function (b, d) {\n    function n(a, b, d, e, h, m, n, f) {\n      return [\"M\", a + h, b, \"L\", a + d - m, b, \"C\", a + d - m / 2, b, a + d, b + m / 2, a + d, b + m, \"L\", a + d, b + e - n, \"C\", a + d, b + e - n / 2, a + d - n / 2, b + e, a + d - n, b + e, \"L\", a + f, b + e, \"C\", a + f / 2, b + e, a, b + e - f / 2, a, b + e - f, \"L\", a, b + h, \"C\", a, b + h / 2, a + h / 2, b, a + h, b, \"Z\"];\n    }\n\n    var e = d.extend,\n        m = d.merge,\n        h = d.pick,\n        x = b.Chart;\n    d = b.defaultOptions;\n    var A = b.Renderer,\n        t = b.SVGRenderer,\n        q = b.VMLRenderer;\n    e(d.lang, {\n      zoomIn: \"Zoom in\",\n      zoomOut: \"Zoom out\"\n    });\n    d.mapNavigation = {\n      buttonOptions: {\n        alignTo: \"plotBox\",\n        align: \"left\",\n        verticalAlign: \"top\",\n        x: 0,\n        width: 18,\n        height: 18,\n        padding: 5,\n        style: {\n          fontSize: \"15px\",\n          fontWeight: \"bold\"\n        },\n        theme: {\n          \"stroke-width\": 1,\n          \"text-align\": \"center\"\n        }\n      },\n      buttons: {\n        zoomIn: {\n          onclick: function () {\n            this.mapZoom(.5);\n          },\n          text: \"+\",\n          y: 0\n        },\n        zoomOut: {\n          onclick: function () {\n            this.mapZoom(2);\n          },\n          text: \"-\",\n          y: 28\n        }\n      },\n      mouseWheelSensitivity: 1.1\n    };\n\n    b.splitPath = function (a) {\n      var b;\n      a = a.replace(/([A-Za-z])/g, \" $1 \");\n      a = a.replace(/^\\s*/, \"\").replace(/\\s*$/, \"\");\n      a = a.split(/[ ,]+/);\n\n      for (b = 0; b < a.length; b++) /[a-zA-Z]/.test(a[b]) || (a[b] = parseFloat(a[b]));\n\n      return a;\n    };\n\n    b.maps = {};\n\n    t.prototype.symbols.topbutton = function (a, b, d, e, h) {\n      return n(a - 1, b - 1, d, e, h.r, h.r, 0, 0);\n    };\n\n    t.prototype.symbols.bottombutton = function (a, b, d, e, h) {\n      return n(a - 1, b - 1, d, e, 0, 0, h.r, h.r);\n    };\n\n    A === q && [\"topbutton\", \"bottombutton\"].forEach(function (a) {\n      q.prototype.symbols[a] = t.prototype.symbols[a];\n    });\n\n    b.Map = b.mapChart = function (a, d, e) {\n      var k = \"string\" === typeof a || a.nodeName,\n          l = arguments[k ? 1 : 0],\n          n = l,\n          q = {\n        endOnTick: !1,\n        visible: !1,\n        minPadding: 0,\n        maxPadding: 0,\n        startOnTick: !1\n      },\n          f = b.getOptions().credits;\n      var c = l.series;\n      l.series = null;\n      l = m({\n        chart: {\n          panning: \"xy\",\n          type: \"map\"\n        },\n        credits: {\n          mapText: h(f.mapText, ' \\u00a9 <a href=\"{geojson.copyrightUrl}\">{geojson.copyrightShort}</a>'),\n          mapTextFull: h(f.mapTextFull, \"{geojson.copyright}\")\n        },\n        tooltip: {\n          followTouchMove: !1\n        },\n        xAxis: q,\n        yAxis: m(q, {\n          reversed: !0\n        })\n      }, l, {\n        chart: {\n          inverted: !1,\n          alignTicks: !1\n        }\n      });\n      l.series = n.series = c;\n      return k ? new x(a, l, e) : new x(l, d);\n    };\n  });\n  x(d, \"masters/modules/map.src.js\", [], function () {});\n});","map":null,"metadata":{},"sourceType":"script"}